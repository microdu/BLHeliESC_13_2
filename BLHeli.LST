MACRO ASSEMBLER BLHELI                                      08/03/15 09:08:18 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\SKYPUP_6A_REV13_2.OBJ
ASSEMBLER INVOKED BY: SET(BESCNO=189) OBJECT(OUTPUT\SKYPUP_6A_REV13_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several hundred Hz.
                        35     ; The code adapts itself to the various input modes/frequencies
                        36     ; The code ESC can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESCNO EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made its default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ; - Rev11.0 Fixed bug of programming default values for governor in MULTI mode
                       160     ;           Disabled interrupts explicitly some places, to avoid possibilities for unintentional fet switching
                       161     ;           Changed interrupt disable strategy, to always allow pwm interrupts, to avoid noise when running at low rpms
                       162     ;           Added governor middle range for MAIN mode
                       163     ;           Added bidirectional mode for TAIL and MULTI mode with PPM input
                       164     ;           Changed and improved demag compensation
                       165     ;           Miscellaneous other changes
                       166     ; - Rev11.1 Fixed bug of slow acceleration response for MAIN mode running without governor
                       167     ;           Fixed bug with PWM input, where throttle remains high even when zeroing throttle (seen on V922 tail)
                       168     ;           Fixed bug in bidirectional operation, where direction change could cause reset
                       169     ;           Improved autorotation bailout for MAIN
                       170     ;           Reduced min speed back to 1220 erpm
                       171     ;           Misc code cleanups
                       172     ; - Rev11.2 Fixed throttle calibration bug
                       173     ;           Added high side driver precharge for all-nfet ESCs
                       174     ;           Optimized timing in general and for demag compensation in particular
                       175     ;           Auto bailout functionality modified
                       176     ;           Governor is deactivated for throttle inputs below 10%
                       177     ;           Increased beacon delay times
                       178     ; - Rev12.0 Added programmable main spoolup time
                       179     ;           Added programmable temperature protection enable
                       180     ;           Bidirectional mode stop/start improved. Motor is now stopped before starting
                       181     ;           Power is limited for very low rpms (when BEMF is low), in order to avoid sync loss 
                       182     ;           Damped light mode is made more smooth and quiet, particularly at low and high rpms
                       183     ;           Comparator signal qualification scheme is changed
                       184     ;           Demag compensation scheme is significantly changed
                       185     ;           Increased jitter tolerance for PPM frequency measurement
                       186     ;           Fully damped mode removed, and damped light only supported on damped capable ESCs
                       187     ;           Default tail mode changed to damped light
                       188     ;           Miscellaneous other changes
                       189     ; - Rev12.1 Fixed bug in tail code
                       190     ;           Improved startup for Atmel
                       191     ;           Added support for multiple high BEC voltages
                       192     ;           Added support for RPM output
                       193     ; - Rev12.2 Improved running smoothness, particularly for damped light
                       194     ;           Avoiding lockup at full throttle when input signal is noisy
                       195     ;           Avoiding detection of 1-wire programming signal as valid throttle signal
                       196     ; - Rev13.0 Removed stepped start
                       197     ;           Removed throttle change rate and damping force parameters
                       198     ;           Added support for OneShot125
                       199     ;           Improved commutation timing accuracy
                       200     ; - Rev13.1 Removed startup ramp for MULTI
                       201     ;           Improved startup for some odd ESCs
                       202     ; - Rev13.2 Still tweaking startup to make it more reliable and faster for all ESC/motor combos
                       203     ;           Increased deadband for bidirectional operation
                       204     ;           Relaxed signal detection criteria
                       205     ;           Added support for running 50MHz capable SiLabs MCUs at 50MHz
                       206     ;           Added bootlader to SiLabs code
                       207     ;           Miscellaneous other changes
                       208     ;
                       209     ;
                       210     ;
                       211     ;**** **** **** **** ****
                       212     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       213     ; 768 Bytes Internal SRAM
                       214     ;
                       215     ;**** **** **** **** ****
                       216     ; Master clock is internal 24MHz oscillator
                       217     ; Timer 0 (167/500ns counts) always counts up and is used for
                       218     ; - PWM generation
                       219     ; Timer 1 (167/500ns counts) always counts up and is used for
                       220     ; - Time from pwm on/off event
                       221     ; Timer 2 (500ns counts) always counts up and is used for
                       222     ; - RC pulse timeout/skip counts and commutation times
                       223     ; Timer 3 (500ns counts) always counts up and is used for
                       224     ; - Commutation timeouts
                       225     ; PCA0 (500ns counts) always counts up and is used for
                       226     ; - RC pulse measurement
                       227     ;
                       228     ;**** **** **** **** ****
                       229     ; Interrupt handling
                       230     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                       231     ; Also some interrupt flags need to be cleared by software
                       232     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                       233     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       234     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       235     ;
                       236     ;**** **** **** **** ****
                       237     ; Motor control:
                       238     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       239     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       240     ; - Timing advance in this implementation is set to 15deg nominally
                       241     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       242     ; Motor sequence starting from zero crossing:
                       243     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       244     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       245     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       246     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       247     ;
                       248     ; Motor startup:
                       249     ; Startup is the only phase, before normal bemf commutation run begins.
                       250     ;
                       251     ;**** **** **** **** ****
                       252     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 253     XP_3A_MAIN 					EQU 1
  0002                 254     XP_3A_TAIL 					EQU 2
  0003                 255     XP_3A_MULTI 					EQU 3
  0004                 256     XP_7A_MAIN 					EQU 4
  0005                 257     XP_7A_TAIL 					EQU 5
  0006                 258     XP_7A_MULTI 					EQU 6
  0007                 259     XP_7A_FAST_MAIN 				EQU 7
  0008                 260     XP_7A_FAST_TAIL 				EQU 8
  0009                 261     XP_7A_FAST_MULTI 				EQU 9
  000A                 262     XP_12A_MAIN 					EQU 10
  000B                 263     XP_12A_TAIL 					EQU 11
  000C                 264     XP_12A_MULTI 					EQU 12
  000D                 265     XP_18A_MAIN 					EQU 13
  000E                 266     XP_18A_TAIL 					EQU 14
  000F                 267     XP_18A_MULTI 					EQU 15
  0010                 268     XP_25A_MAIN 					EQU 16
  0011                 269     XP_25A_TAIL 					EQU 17
  0012                 270     XP_25A_MULTI 					EQU 18
  0013                 271     XP_35A_SW_MAIN 				EQU 19
  0014                 272     XP_35A_SW_TAIL 				EQU 20
  0015                 273     XP_35A_SW_MULTI 				EQU 21
  0016                 274     DP_3A_MAIN 					EQU 22
  0017                 275     DP_3A_TAIL  					EQU 23
  0018                 276     DP_3A_MULTI  					EQU 24
  0019                 277     SUPERMICRO_3P5A_MAIN 			EQU 25
  001A                 278     SUPERMICRO_3P5A_TAIL 			EQU 26   
  001B                 279     SUPERMICRO_3P5A_MULTI 			EQU 27   
  001C                 280     TURNIGY_PLUSH_6A_MAIN 			EQU 28
  001D                 281     TURNIGY_PLUSH_6A_TAIL 			EQU 29   
  001E                 282     TURNIGY_PLUSH_6A_MULTI 			EQU 30   
  001F                 283     TURNIGY_PLUSH_10A_MAIN 			EQU 31
  0020                 284     TURNIGY_PLUSH_10A_TAIL 			EQU 32   
  0021                 285     TURNIGY_PLUSH_10A_MULTI 			EQU 33   
  0022                 286     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                 287     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                 288     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  0025                 289     TURNIGY_PLUSH_18A_MAIN 			EQU 37
  0026                 290     TURNIGY_PLUSH_18A_TAIL 			EQU 38   
  0027                 291     TURNIGY_PLUSH_18A_MULTI 			EQU 39   
  0028                 292     TURNIGY_PLUSH_25A_MAIN 			EQU 40
  0029                 293     TURNIGY_PLUSH_25A_TAIL 			EQU 41   
  002A                 294     TURNIGY_PLUSH_25A_MULTI 			EQU 42   
  002B                 295     TURNIGY_PLUSH_30A_MAIN 			EQU 43
  002C                 296     TURNIGY_PLUSH_30A_TAIL 			EQU 44   
  002D                 297     TURNIGY_PLUSH_30A_MULTI 			EQU 45   
  002E                 298     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                 299     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                 300     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  0031                 301     TURNIGY_PLUSH_60A_MAIN 			EQU 49
  0032                 302     TURNIGY_PLUSH_60A_TAIL 			EQU 50   
  0033                 303     TURNIGY_PLUSH_60A_MULTI 			EQU 51   
  0034                 304     TURNIGY_PLUSH_80A_MAIN 			EQU 52
  0035                 305     TURNIGY_PLUSH_80A_TAIL 			EQU 53   
  0036                 306     TURNIGY_PLUSH_80A_MULTI 			EQU 54   
  0037                 307     TURNIGY_PLUSH_NFET_18A_MAIN 		EQU 55
  0038                 308     TURNIGY_PLUSH_NFET_18A_TAIL 		EQU 56   
  0039                 309     TURNIGY_PLUSH_NFET_18A_MULTI 		EQU 57   
  003A                 310     TURNIGY_PLUSH_NFET_25A_MAIN 		EQU 58
  003B                 311     TURNIGY_PLUSH_NFET_25A_TAIL 		EQU 59   
  003C                 312     TURNIGY_PLUSH_NFET_25A_MULTI 		EQU 60   
  003D                 313     TURNIGY_PLUSH_NFET_30A_MAIN 		EQU 61
  003E                 314     TURNIGY_PLUSH_NFET_30A_TAIL 		EQU 62   
  003F                 315     TURNIGY_PLUSH_NFET_30A_MULTI 		EQU 63   
  0040                 316     TURNIGY_AE_20A_MAIN 			EQU 64
  0041                 317     TURNIGY_AE_20A_TAIL 			EQU 65   
  0042                 318     TURNIGY_AE_20A_MULTI 			EQU 66   
  0043                 319     TURNIGY_AE_25A_MAIN 			EQU 67
  0044                 320     TURNIGY_AE_25A_TAIL 			EQU 68   
  0045                 321     TURNIGY_AE_25A_MULTI 			EQU 69   
  0046                 322     TURNIGY_AE_30A_MAIN 			EQU 70
  0047                 323     TURNIGY_AE_30A_TAIL 			EQU 71   
  0048                 324     TURNIGY_AE_30A_MULTI 			EQU 72   
  0049                 325     TURNIGY_AE_45A_MAIN 			EQU 73
  004A                 326     TURNIGY_AE_45A_TAIL 			EQU 74   
  004B                 327     TURNIGY_AE_45A_MULTI 			EQU 75   
  004C                 328     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                 329     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                 330     TURNIGY_KFORCE_40A_MULTI 		EQU 78   
  004F                 331     TURNIGY_KFORCE_70A_HV_MAIN 		EQU 79   
  0050                 332     TURNIGY_KFORCE_70A_HV_TAIL 		EQU 80   
  0051                 333     TURNIGY_KFORCE_70A_HV_MULTI 		EQU 81   
  0052                 334     TURNIGY_KFORCE_120A_HV_MAIN 		EQU 82   
  0053                 335     TURNIGY_KFORCE_120A_HV_TAIL 		EQU 83   
  0054                 336     TURNIGY_KFORCE_120A_HV_MULTI 		EQU 84   
  0055                 337     TURNIGY_KFORCE_120A_HV_V2_MAIN	EQU 85   
  0056                 338     TURNIGY_KFORCE_120A_HV_V2_TAIL 	EQU 86   
  0057                 339     TURNIGY_KFORCE_120A_HV_V2_MULTI 	EQU 87   
  0058                 340     SKYWALKER_20A_MAIN 				EQU 88
  0059                 341     SKYWALKER_20A_TAIL 				EQU 89   
  005A                 342     SKYWALKER_20A_MULTI 			EQU 90   
  005B                 343     SKYWALKER_40A_MAIN 				EQU 91
  005C                 344     SKYWALKER_40A_TAIL 				EQU 92   
  005D                 345     SKYWALKER_40A_MULTI 			EQU 93   
  005E                 346     HIMODEL_COOL_22A_MAIN 			EQU 94
  005F                 347     HIMODEL_COOL_22A_TAIL 			EQU 95   
  0060                 348     HIMODEL_COOL_22A_MULTI 			EQU 96   
  0061                 349     HIMODEL_COOL_33A_MAIN 			EQU 97
  0062                 350     HIMODEL_COOL_33A_TAIL 			EQU 98   
  0063                 351     HIMODEL_COOL_33A_MULTI 			EQU 99  
  0064                 352     HIMODEL_COOL_41A_MAIN 			EQU 100
  0065                 353     HIMODEL_COOL_41A_TAIL 			EQU 101  
  0066                 354     HIMODEL_COOL_41A_MULTI 			EQU 102  
  0067                 355     RCTIMER_6A_MAIN 				EQU 103   
  0068                 356     RCTIMER_6A_TAIL 				EQU 104  
  0069                 357     RCTIMER_6A_MULTI 				EQU 105  
  006A                 358     ALIGN_RCE_BL15X_MAIN			EQU 106   
  006B                 359     ALIGN_RCE_BL15X_TAIL 			EQU 107  
  006C                 360     ALIGN_RCE_BL15X_MULTI 			EQU 108  
  006D                 361     ALIGN_RCE_BL15P_MAIN			EQU 109  
  006E                 362     ALIGN_RCE_BL15P_TAIL 			EQU 110  
  006F                 363     ALIGN_RCE_BL15P_MULTI 			EQU 111  
  0070                 364     ALIGN_RCE_BL35X_MAIN			EQU 112  
  0071                 365     ALIGN_RCE_BL35X_TAIL 			EQU 113  
  0072                 366     ALIGN_RCE_BL35X_MULTI 			EQU 114  
  0073                 367     ALIGN_RCE_BL35P_MAIN			EQU 115   
  0074                 368     ALIGN_RCE_BL35P_TAIL 			EQU 116  
  0075                 369     ALIGN_RCE_BL35P_MULTI 			EQU 117  
  0076                 370     GAUI_GE_183_18A_MAIN			EQU 118   
  0077                 371     GAUI_GE_183_18A_TAIL 			EQU 119  
  0078                 372     GAUI_GE_183_18A_MULTI 			EQU 120  
  0079                 373     H_KING_10A_MAIN				EQU 121   
  007A                 374     H_KING_10A_TAIL 				EQU 122  
  007B                 375     H_KING_10A_MULTI 				EQU 123  
  007C                 376     H_KING_20A_MAIN				EQU 124   
  007D                 377     H_KING_20A_TAIL 				EQU 125  
  007E                 378     H_KING_20A_MULTI 				EQU 126  
  007F                 379     H_KING_35A_MAIN				EQU 127   
  0080                 380     H_KING_35A_TAIL 				EQU 128 
  0081                 381     H_KING_35A_MULTI 				EQU 129  
  0082                 382     H_KING_50A_MAIN				EQU 130   
  0083                 383     H_KING_50A_TAIL 				EQU 131  
  0084                 384     H_KING_50A_MULTI 				EQU 132  
  0085                 385     POLARIS_THUNDER_12A_MAIN			EQU 133   
  0086                 386     POLARIS_THUNDER_12A_TAIL 		EQU 134  
  0087                 387     POLARIS_THUNDER_12A_MULTI 		EQU 135  
  0088                 388     POLARIS_THUNDER_20A_MAIN			EQU 136   
  0089                 389     POLARIS_THUNDER_20A_TAIL 		EQU 137  
  008A                 390     POLARIS_THUNDER_20A_MULTI 		EQU 138  
  008B                 391     POLARIS_THUNDER_30A_MAIN			EQU 139   
  008C                 392     POLARIS_THUNDER_30A_TAIL 		EQU 140  
  008D                 393     POLARIS_THUNDER_30A_MULTI 		EQU 141  
  008E                 394     POLARIS_THUNDER_40A_MAIN			EQU 142   
  008F                 395     POLARIS_THUNDER_40A_TAIL 		EQU 143  
  0090                 396     POLARIS_THUNDER_40A_MULTI 		EQU 144  
  0091                 397     POLARIS_THUNDER_60A_MAIN			EQU 145   
  0092                 398     POLARIS_THUNDER_60A_TAIL 		EQU 146  
  0093                 399     POLARIS_THUNDER_60A_MULTI 		EQU 147  
  0094                 400     POLARIS_THUNDER_80A_MAIN			EQU 148   
  0095                 401     POLARIS_THUNDER_80A_TAIL 		EQU 149  
  0096                 402     POLARIS_THUNDER_80A_MULTI 		EQU 150  
  0097                 403     POLARIS_THUNDER_100A_MAIN		EQU 151   
  0098                 404     POLARIS_THUNDER_100A_TAIL 		EQU 152  
  0099                 405     POLARIS_THUNDER_100A_MULTI 		EQU 153  
  009A                 406     PLATINUM_PRO_30A_MAIN			EQU 154   
  009B                 407     PLATINUM_PRO_30A_TAIL 			EQU 155  
  009C                 408     PLATINUM_PRO_30A_MULTI 			EQU 156  
  009D                 409     PLATINUM_PRO_150A_MAIN			EQU 157   
  009E                 410     PLATINUM_PRO_150A_TAIL 			EQU 158  
  009F                 411     PLATINUM_PRO_150A_MULTI 			EQU 159  
  00A0                 412     PLATINUM_50AV3_MAIN				EQU 160   
  00A1                 413     PLATINUM_50AV3_TAIL 			EQU 161  
  00A2                 414     PLATINUM_50AV3_MULTI 			EQU 162  
  00A3                 415     EAZY_3AV2_MAIN					EQU 163   
  00A4                 416     EAZY_3AV2_TAIL 				EQU 164  
  00A5                 417     EAZY_3AV2_MULTI 				EQU 165  
  00A6                 418     TAROT_30A_MAIN					EQU 166   
  00A7                 419     TAROT_30A_TAIL 				EQU 167  
  00A8                 420     TAROT_30A_MULTI 				EQU 168  
  00A9                 421     SKYIII_30A_MAIN				EQU 169   
  00AA                 422     SKYIII_30A_TAIL 				EQU 170  
  00AB                 423     SKYIII_30A_MULTI 				EQU 171  
  00AC                 424     EMAX_20A_MAIN					EQU 172   
  00AD                 425     EMAX_20A_TAIL 					EQU 173  
  00AE                 426     EMAX_20A_MULTI 				EQU 174  
  00AF                 427     EMAX_40A_MAIN					EQU 175   
  00B0                 428     EMAX_40A_TAIL 					EQU 176  
  00B1                 429     EMAX_40A_MULTI 				EQU 177  
  00B2                 430     XROTOR_10A_MAIN				EQU 178   
  00B3                 431     XROTOR_10A_TAIL 				EQU 179  
  00B4                 432     XROTOR_10A_MULTI 				EQU 180  
  00B5                 433     XROTOR_20A_MAIN				EQU 181   
  00B6                 434     XROTOR_20A_TAIL 				EQU 182  
  00B7                 435     XROTOR_20A_MULTI 				EQU 183  
  00B8                 436     XROTOR_40A_MAIN				EQU 184   
  00B9                 437     XROTOR_40A_TAIL 				EQU 185  
  00BA                 438     XROTOR_40A_MULTI 				EQU 186  
  00BB                 439     SKYPUP_6A_MAIN					EQU 187
  00BC                 440     SKYPUP_6A_TAIL					EQU 188
  00BD                 441     SKYPUP_6A_MULTI				EQU 189
                       442     
                       443     
                       444     ;**** **** **** **** ****
                       445     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       446     ;BESCNO EQU XP_3A_Main
                       447     ;BESCNO EQU XP_3A_Tail
                       448     ;BESCNO EQU XP_3A_Multi
                       449     ;BESCNO EQU XP_7A_Main
                       450     ;BESCNO EQU XP_7A_Tail
                       451     ;BESCNO EQU XP_7A_Multi
                       452     ;BESCNO EQU XP_7A_Fast_Main
                       453     ;BESCNO EQU XP_7A_Fast_Tail
                       454     ;BESCNO EQU XP_7A_Fast_Multi
                       455     ;BESCNO EQU XP_12A_Main
                       456     ;BESCNO EQU XP_12A_Tail 
                       457     ;BESCNO EQU XP_12A_Multi
                       458     ;BESCNO EQU XP_18A_Main 
                       459     ;BESCNO EQU XP_18A_Tail 
                       460     ;BESCNO EQU XP_18A_Multi
                       461     ;BESCNO EQU XP_25A_Main 
                       462     ;BESCNO EQU XP_25A_Tail 
                       463     ;BESCNO EQU XP_25A_Multi
                       464     ;BESCNO EQU XP_35A_SW_Main
                       465     ;BESCNO EQU XP_35A_SW_Tail 
                       466     ;BESCNO EQU XP_35A_SW_Multi
                       467     ;BESCNO EQU DP_3A_Main 						
                       468     ;BESCNO EQU DP_3A_Tail
                       469     ;BESCNO EQU DP_3A_Multi
                       470     ;BESCNO EQU Supermicro_3p5A_Main
                       471     ;BESCNO EQU Supermicro_3p5A_Tail
                       472     ;BESCNO EQU Supermicro_3p5A_Multi
                       473     ;BESCNO EQU Turnigy_Plush_6A_Main 
                       474     ;BESCNO EQU Turnigy_Plush_6A_Tail 
                       475     ;BESCNO EQU Turnigy_Plush_6A_Multi
                       476     ;BESCNO EQU Turnigy_Plush_10A_Main 
                       477     ;BESCNO EQU Turnigy_Plush_10A_Tail 
                       478     ;BESCNO EQU Turnigy_Plush_10A_Multi
                       479     ;BESCNO EQU Turnigy_Plush_12A_Main 
                       480     ;BESCNO EQU Turnigy_Plush_12A_Tail 
                       481     ;BESCNO EQU Turnigy_Plush_12A_Multi
                       482     ;BESCNO EQU Turnigy_Plush_18A_Main 
                       483     ;BESCNO EQU Turnigy_Plush_18A_Tail 
                       484     ;BESCNO EQU Turnigy_Plush_18A_Multi
                       485     ;BESCNO EQU Turnigy_Plush_25A_Main 
                       486     ;BESCNO EQU Turnigy_Plush_25A_Tail
                       487     ;BESCNO EQU Turnigy_Plush_25A_Multi
                       488     ;BESCNO EQU Turnigy_Plush_30A_Main 
                       489     ;BESCNO EQU Turnigy_Plush_30A_Tail 
                       490     ;BESCNO EQU Turnigy_Plush_30A_Multi
                       491     ;BESCNO EQU Turnigy_Plush_40A_Main  
                       492     ;BESCNO EQU Turnigy_Plush_40A_Tail 
                       493     ;BESCNO EQU Turnigy_Plush_40A_Multi
                       494     ;BESCNO EQU Turnigy_Plush_60A_Main
                       495     ;BESCNO EQU Turnigy_Plush_60A_Tail 
                       496     ;BESCNO EQU Turnigy_Plush_60A_Multi
                       497     ;BESCNO EQU Turnigy_Plush_80A_Main
                       498     ;BESCNO EQU Turnigy_Plush_80A_Tail 
                       499     ;BESCNO EQU Turnigy_Plush_80A_Multi
                       500     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Main
                       501     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Tail 
                       502     ;BESCNO EQU Turnigy_Plush_Nfet_18A_Multi
                       503     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Main 
                       504     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Tail
                       505     ;BESCNO EQU Turnigy_Plush_Nfet_25A_Multi
                       506     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Main  
                       507     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Tail 
                       508     ;BESCNO EQU Turnigy_Plush_Nfet_30A_Multi
                       509     ;BESCNO EQU Turnigy_AE_20A_Main 
                       510     ;BESCNO EQU Turnigy_AE_20A_Tail 
                       511     ;BESCNO EQU Turnigy_AE_20A_Multi
                       512     ;BESCNO EQU Turnigy_AE_25A_Main 
                       513     ;BESCNO EQU Turnigy_AE_25A_Tail 
                       514     ;BESCNO EQU Turnigy_AE_25A_Multi
                       515     ;BESCNO EQU Turnigy_AE_30A_Main 
                       516     ;BESCNO EQU Turnigy_AE_30A_Tail 
                       517     ;BESCNO EQU Turnigy_AE_30A_Multi
                       518     ;BESCNO EQU Turnigy_AE_45A_Main
                       519     ;BESCNO EQU Turnigy_AE_45A_Tail 
                       520     ;BESCNO EQU Turnigy_AE_45A_Multi
                       521     ;BESCNO EQU Turnigy_KForce_40A_Main
                       522     ;BESCNO EQU Turnigy_KForce_40A_Tail 
                       523     ;BESCNO EQU Turnigy_KForce_40A_Multi
                       524     ;BESCNO EQU Turnigy_KForce_70A_HV_Main
                       525     ;BESCNO EQU Turnigy_KForce_70A_HV_Tail 
                       526     ;BESCNO EQU Turnigy_KForce_70A_HV_Multi
                       527     ;BESCNO EQU Turnigy_KForce_120A_HV_Main
                       528     ;BESCNO EQU Turnigy_KForce_120A_HV_Tail 
                       529     ;BESCNO EQU Turnigy_KForce_120A_HV_Multi
                       530     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Main
                       531     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Tail 
                       532     ;BESCNO EQU Turnigy_KForce_120A_HV_v2_Multi
                       533     ;BESCNO EQU Skywalker_20A_Main
                       534     ;BESCNO EQU Skywalker_20A_Tail
                       535     ;BESCNO EQU Skywalker_20A_Multi
                       536     ;BESCNO EQU Skywalker_40A_Main 
                       537     ;BESCNO EQU Skywalker_40A_Tail 
                       538     ;BESCNO EQU Skywalker_40A_Multi
                       539     ;BESCNO EQU HiModel_Cool_22A_Main
                       540     ;BESCNO EQU HiModel_Cool_22A_Tail
                       541     ;BESCNO EQU HiModel_Cool_22A_Multi
                       542     ;BESCNO EQU HiModel_Cool_33A_Main
                       543     ;BESCNO EQU HiModel_Cool_33A_Tail
                       544     ;BESCNO EQU HiModel_Cool_33A_Multi
                       545     ;BESCNO EQU HiModel_Cool_41A_Main
                       546     ;BESCNO EQU HiModel_Cool_41A_Tail
                       547     ;BESCNO EQU HiModel_Cool_41A_Multi
                       548     ;BESCNO EQU RCTimer_6A_Main
                       549     ;BESCNO EQU RCTimer_6A_Tail
                       550     ;BESCNO EQU RCTimer_6A_Multi
                       551     ;BESCNO EQU Align_RCE_BL15X_Main
                       552     ;BESCNO EQU Align_RCE_BL15X_Tail
                       553     ;BESCNO EQU Align_RCE_BL15X_Multi
                       554     ;BESCNO EQU Align_RCE_BL15P_Main
                       555     ;BESCNO EQU Align_RCE_BL15P_Tail
                       556     ;BESCNO EQU Align_RCE_BL15P_Multi 
                       557     ;BESCNO EQU Align_RCE_BL35X_Main 
                       558     ;BESCNO EQU Align_RCE_BL35X_Tail
                       559     ;BESCNO EQU Align_RCE_BL35X_Multi
                       560     ;BESCNO EQU Align_RCE_BL35P_Main
                       561     ;BESCNO EQU Align_RCE_BL35P_Tail
                       562     ;BESCNO EQU Align_RCE_BL35P_Multi
                       563     ;BESCNO EQU Gaui_GE_183_18A_Main
                       564     ;BESCNO EQU Gaui_GE_183_18A_Tail
                       565     ;BESCNO EQU Gaui_GE_183_18A_Multi
                       566     ;BESCNO EQU H_King_10A_Main 
                       567     ;BESCNO EQU H_King_10A_Tail 
                       568     ;BESCNO EQU H_King_10A_Multi
                       569     ;BESCNO EQU H_King_20A_Main
                       570     ;BESCNO EQU H_King_20A_Tail
                       571     ;BESCNO EQU H_King_20A_Multi
                       572     ;BESCNO EQU H_King_35A_Main
                       573     ;BESCNO EQU H_King_35A_Tail
                       574     ;BESCNO EQU H_King_35A_Multi
                       575     ;BESCNO EQU H_King_50A_Main
                       576     ;BESCNO EQU H_King_50A_Tail
                       577     ;BESCNO EQU H_King_50A_Multi
                       578     ;BESCNO EQU Polaris_Thunder_12A_Main
                       579     ;BESCNO EQU Polaris_Thunder_12A_Tail
                       580     ;BESCNO EQU Polaris_Thunder_12A_Multi
                       581     ;BESCNO EQU Polaris_Thunder_20A_Main
                       582     ;BESCNO EQU Polaris_Thunder_20A_Tail
                       583     ;BESCNO EQU Polaris_Thunder_20A_Multi
                       584     ;BESCNO EQU Polaris_Thunder_30A_Main
                       585     ;BESCNO EQU Polaris_Thunder_30A_Tail
                       586     ;BESCNO EQU Polaris_Thunder_30A_Multi
                       587     ;BESCNO EQU Polaris_Thunder_40A_Main
                       588     ;BESCNO EQU Polaris_Thunder_40A_Tail
                       589     ;BESCNO EQU Polaris_Thunder_40A_Multi
                       590     ;BESCNO EQU Polaris_Thunder_60A_Main
                       591     ;BESCNO EQU Polaris_Thunder_60A_Tail
                       592     ;BESCNO EQU Polaris_Thunder_60A_Multi
                       593     ;BESCNO EQU Polaris_Thunder_80A_Main
                       594     ;BESCNO EQU Polaris_Thunder_80A_Tail
                       595     ;BESCNO EQU Polaris_Thunder_80A_Multi
                       596     ;BESCNO EQU Polaris_Thunder_100A_Main
                       597     ;BESCNO EQU Polaris_Thunder_100A_Tail
                       598     ;BESCNO EQU Polaris_Thunder_100A_Multi
                       599     ;BESCNO EQU Platinum_Pro_30A_Main
                       600     ;BESCNO EQU Platinum_Pro_30A_Tail
                       601     ;BESCNO EQU Platinum_Pro_30A_Multi
                       602     ;BESCNO EQU Platinum_Pro_150A_Main
                       603     ;BESCNO EQU Platinum_Pro_150A_Tail
                       604     ;BESCNO EQU Platinum_Pro_150A_Multi
                       605     ;BESCNO EQU Platinum_50Av3_Main
                       606     ;BESCNO EQU Platinum_50Av3_Tail
                       607     ;BESCNO EQU Platinum_50Av3_Multi 
                       608     ;BESCNO EQU EAZY_3Av2_Main
                       609     ;BESCNO EQU EAZY_3Av2_Tail
                       610     ;BESCNO EQU EAZY_3Av2_Multi
                       611     ;BESCNO EQU Tarot_30A_Main
                       612     ;BESCNO EQU Tarot_30A_Tail
                       613     ;BESCNO EQU Tarot_30A_Multi
                       614     ;BESCNO EQU SkyIII_30A_Main
                       615     ;BESCNO EQU SkyIII_30A_Tail
                       616     ;BESCNO EQU SkyIII_30A_Multi
                       617     ;BESCNO EQU EMAX_20A_Main
                       618     ;BESCNO EQU EMAX_20A_Tail
                       619     ;BESCNO EQU EMAX_20A_Multi 
                       620     ;BESCNO EQU EMAX_40A_Main
                       621     ;BESCNO EQU EMAX_40A_Tail
                       622     ;BESCNO EQU EMAX_40A_Multi
                       623     ;BESCNO EQU XRotor_10A_Main
                       624     ;BESCNO EQU XRotor_10A_Tail
                       625     ;BESCNO EQU XRotor_10A_Multi 
                       626     ;BESCNO EQU XRotor_20A_Main
                       627     ;BESCNO EQU XRotor_20A_Tail
                       628     ;BESCNO EQU XRotor_20A_Multi
                       629     ;BESCNO EQU XRotor_40A_Main
                       630     ;BESCNO EQU XRotor_40A_Tail
                       631     ;BESCNO EQU XRotor_40A_Multi
                       632     ;BESCNO EQU Skypup_6A_Main
                       633     ;BESCNO EQU Skypup_6A_Tail
                       634     ;BESCNO EQU Skypup_6A_Multi
                       635     
                       636     
                       637     
                       638     ;**** **** **** **** ****
                       639     ; ESC selection statements
                       640     IF BESCNO == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       644     
                       645     IF BESCNO == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       649     
                       650     IF BESCNO == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       654     
                       655     IF BESCNO == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       659     
                       660     IF BESCNO == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       664     
                       665     IF BESCNO == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       669     
                       670     IF BESCNO == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       674     
                       675     IF BESCNO == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       679     
                       680     IF BESCNO == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       684     
                       685     IF BESCNO == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       689     
                       690     IF BESCNO == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       694     
                       695     IF BESCNO == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       699     
                       700     IF BESCNO == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       704     
                       705     IF BESCNO == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       709     
                       710     IF BESCNO == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       714     
                       715     IF BESCNO == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       719     
                       720     IF BESCNO == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       724     
                       725     IF BESCNO == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       729     
                       730     IF BESCNO == XP_35A_SW_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       734     
                       735     IF BESCNO == XP_35A_SW_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       739     
                       740     IF BESCNO == XP_35A_SW_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_35A_SW.INC)			; Select XP 35A SW pinout
                               ENDIF
                       744     
                       745     IF BESCNO == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       749     
                       750     IF BESCNO == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       754     
                       755     IF BESCNO == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       759     
                       760     IF BESCNO == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       764     
                       765     IF BESCNO == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       769     
                       770     IF BESCNO == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       774     
                       775     IF BESCNO == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       779     
                       780     IF BESCNO == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       784     
                       785     IF BESCNO == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       789     
                       790     IF BESCNO == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       794     
                       795     IF BESCNO == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       799     
                       800     IF BESCNO == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       804     
                       805     IF BESCNO == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       809     
                       810     IF BESCNO == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       814     
                       815     IF BESCNO == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       819     
                       820     IF BESCNO == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       824     
                       825     IF BESCNO == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       829     
                       830     IF BESCNO == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       834     
                       835     IF BESCNO == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       839     
                       840     IF BESCNO == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       844     
                       845     IF BESCNO == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       849     
                       850     IF BESCNO == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       854     
                       855     IF BESCNO == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       859     
                       860     IF BESCNO == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       864     
                       865     IF BESCNO == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       869     
                       870     IF BESCNO == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       874     
                       875     IF BESCNO == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       879     
                       880     IF BESCNO == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       884     
                       885     IF BESCNO == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       889     
                       890     IF BESCNO == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       894     
                       895     IF BESCNO == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       899     
                       900     IF BESCNO == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       904     
                       905     IF BESCNO == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       909     
                       910     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       914     
                       915     IF BESCNO == TURNIGY_PLUSH_NFET_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       919     
                       920     IF BESCNO == TURNIGY_PLUSH_NFET_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_18A.INC)	; Select Turnigy Plush Nfet 18A pinout
                               ENDIF
                       924     
                       925     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                       929     
                       930     IF BESCNO == TURNIGY_PLUSH_NFET_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                       934     
                       935     IF BESCNO == TURNIGY_PLUSH_NFET_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_25A.INC)	; Select Turnigy Plush Nfet 25A pinout
                               ENDIF
                       939     
                       940     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                       944     
                       945     IF BESCNO == TURNIGY_PLUSH_NFET_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                       949     
                       950     IF BESCNO == TURNIGY_PLUSH_NFET_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_NFET_30A.INC)	; Select Turnigy Plush Nfet 30A pinout
                               ENDIF
                       954     
                       955     IF BESCNO == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       959     
                       960     IF BESCNO == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       964     
                       965     IF BESCNO == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       969     
                       970     IF BESCNO == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       974     
                       975     IF BESCNO == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       979     
                       980     IF BESCNO == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       984     
                       985     IF BESCNO == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       989     
                       990     IF BESCNO == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       994     
                       995     IF BESCNO == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       999     
                      1000     IF BESCNO == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1004     
                      1005     IF BESCNO == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1009     
                      1010     IF BESCNO == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                      1014     
                      1015     IF BESCNO == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1019     
                      1020     IF BESCNO == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1024     
                      1025     IF BESCNO == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                      1029     
                      1030     IF BESCNO == TURNIGY_KFORCE_70A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1034     
                      1035     IF BESCNO == TURNIGY_KFORCE_70A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1039     
                      1040     IF BESCNO == TURNIGY_KFORCE_70A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_70A_HV.INC)	; Select Turnigy KForce 70A HV pinout
                               ENDIF
                      1044     
                      1045     IF BESCNO == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1049     
                      1050     IF BESCNO == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1054     
                      1055     IF BESCNO == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                      1059     
                      1060     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1064     
                      1065     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1069     
                      1070     IF BESCNO == TURNIGY_KFORCE_120A_HV_V2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV_V2.INC); Select Turnigy KForce 120A HV v2 pinout
                               ENDIF
                      1074     
                      1075     IF BESCNO == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1079     
                      1080     IF BESCNO == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1084     
                      1085     IF BESCNO == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                      1089     
                      1090     IF BESCNO == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1094     
                      1095     IF BESCNO == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1099     
                      1100     IF BESCNO == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                      1104     
                      1105     IF BESCNO == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1109     
                      1110     IF BESCNO == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1114     
                      1115     IF BESCNO == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1119     
                      1120     IF BESCNO == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1124     
                      1125     IF BESCNO == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1129     
                      1130     IF BESCNO == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                      1134     
                      1135     IF BESCNO == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1139     
                      1140     IF BESCNO == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1144     
                      1145     IF BESCNO == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                      1149     
                      1150     IF BESCNO == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1154     
                      1155     IF BESCNO == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1159     
                      1160     IF BESCNO == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                      1164     
                      1165     IF BESCNO == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1169     
                      1170     IF BESCNO == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1174     
                      1175     IF BESCNO == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                      1179     
                      1180     IF BESCNO == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1184     
                      1185     IF BESCNO == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1189     
                      1190     IF BESCNO == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                      1194     
                      1195     IF BESCNO == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1199     
                      1200     IF BESCNO == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1204     
                      1205     IF BESCNO == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                      1209     
                      1210     IF BESCNO == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1214     
                      1215     IF BESCNO == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1219     
                      1220     IF BESCNO == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                      1224     
                      1225     IF BESCNO == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1229     
                      1230     IF BESCNO == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1234     
                      1235     IF BESCNO == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1239     
                      1240     IF BESCNO == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1244     
                      1245     IF BESCNO == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1249     
                      1250     IF BESCNO == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1254     
                      1255     IF BESCNO == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1259     
                      1260     IF BESCNO == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1264     
                      1265     IF BESCNO == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1269     
                      1270     IF BESCNO == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1274     
                      1275     IF BESCNO == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1279     
                      1280     IF BESCNO == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1284     
                      1285     IF BESCNO == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1289     
                      1290     IF BESCNO == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1294     
                      1295     IF BESCNO == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1299     
                      1300     IF BESCNO == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1304     
                      1305     IF BESCNO == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1309     
                      1310     IF BESCNO == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1314     
                      1315     IF BESCNO == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1319     
                      1320     IF BESCNO == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1324     
                      1325     IF BESCNO == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1329     
                      1330     IF BESCNO == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1334     
                      1335     IF BESCNO == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1339     
                      1340     IF BESCNO == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1344     
                      1345     IF BESCNO == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1349     
                      1350     IF BESCNO == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1354     
                      1355     IF BESCNO == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1359     
                      1360     IF BESCNO == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1364     
                      1365     IF BESCNO == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1369     
                      1370     IF BESCNO == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1374     
                      1375     IF BESCNO == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1379     
                      1380     IF BESCNO == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1384     
                      1385     IF BESCNO == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1389     
                      1390     IF BESCNO == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1394     
                      1395     IF BESCNO == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1399     
                      1400     IF BESCNO == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1404     
                      1405     IF BESCNO == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1409     
                      1410     IF BESCNO == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1414     
                      1415     IF BESCNO == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1419     
                      1420     IF BESCNO == PLATINUM_PRO_150A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1424     
                      1425     IF BESCNO == PLATINUM_PRO_150A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1429     
                      1430     IF BESCNO == PLATINUM_PRO_150A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_150A.INC)	; Select Platinum Pro 150A pinout
                               ENDIF
                      1434     
                      1435     IF BESCNO == PLATINUM_50AV3_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1439     
                      1440     IF BESCNO == PLATINUM_50AV3_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1444     
                      1445     IF BESCNO == PLATINUM_50AV3_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_50AV3.INC)		; Select Platinum 50A v3 pinout
                               ENDIF
                      1449     
                      1450     IF BESCNO == EAZY_3AV2_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1454     
                      1455     IF BESCNO == EAZY_3AV2_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1459     
                      1460     IF BESCNO == EAZY_3AV2_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EAZY_3AV2.INC)			; Select Eazy 3A v2 pinout
                               ENDIF
                      1464     
                      1465     IF BESCNO == TAROT_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1469     
                      1470     IF BESCNO == TAROT_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1474     
                      1475     IF BESCNO == TAROT_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TAROT_30A.INC)			; Select Tarot 30A pinout
                               ENDIF
                      1479     
                      1480     IF BESCNO == SKYIII_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1484     
                      1485     IF BESCNO == SKYIII_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1489     
                      1490     IF BESCNO == SKYIII_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYIII_30A.INC)		; Select SkyIII 30A pinout
                               ENDIF
                      1494     
                      1495     IF BESCNO == EMAX_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1499     
                      1500     IF BESCNO == EMAX_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1504     
                      1505     IF BESCNO == EMAX_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_20A.INC)			; Select EMAX 20A pinout
                               ENDIF
                      1509     
                      1510     IF BESCNO == EMAX_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1514     
                      1515     IF BESCNO == EMAX_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1519     
                      1520     IF BESCNO == EMAX_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (EMAX_40A.INC)			; Select EMAX 40A pinout
                               ENDIF
                      1524     
                      1525     IF BESCNO == XROTOR_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1529     
                      1530     IF BESCNO == XROTOR_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1534     
                      1535     IF BESCNO == XROTOR_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_10A.INC)		; Select XRotor 10A pinout
                               ENDIF
                      1539     
                      1540     IF BESCNO == XROTOR_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1544     
                      1545     IF BESCNO == XROTOR_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1549     
                      1550     IF BESCNO == XROTOR_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_20A.INC)		; Select XRotor 20A pinout
                               ENDIF
                      1554     
                      1555     IF BESCNO == XROTOR_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1559     
                      1560     IF BESCNO == XROTOR_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1564     
                      1565     IF BESCNO == XROTOR_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XROTOR_40A.INC)		; Select XRotor 40A pinout
                               ENDIF
                      1569     
                      1570     IF BESCNO == SKYPUP_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYPUP_6A.INC)			; Select Skypup 6A pinout
                               ENDIF
                      1574     
                      1575     IF BESCNO == SKYPUP_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYPUP_6A.INC)			; Select Skypup 6A pinout
                               ENDIF
                      1579     
                      1580     IF BESCNO == SKYPUP_6A_MULTI
  0002                1581     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                      1582     $INCLUDE (SKYPUP_6A.INC)			; Select Skypup 6A pinout
                      2191     ENDIF
                      2192     
                      2193     
                      2194     ;**** **** **** **** ****
                      2195     ; TX programming defaults
                      2196     ;
                      2197     ; Parameter dependencies:
                      2198     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      2199     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      2200     ;
                      2201     ; MAIN
  0007                2202     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                2203     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                2204     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                2205     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                2206     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2207     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2208     IF DAMPED_MODE_ENABLE == 1
  0002                2209     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
                      2210     ELSE
                               DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low	
                               ENDIF
  0001                2213     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2214     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                2215     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                2216     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                2217     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                2218     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                2219     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                2220     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2221     
                      2222     ; TAIL
  0003                2223     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                2224     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                2225     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2226     IF DAMPED_MODE_ENABLE == 1
  0003                2227     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low 		3=DampedLight 
                      2228     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		
                               ENDIF
  0001                2231     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                2232     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2233     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                2234     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                2235     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                2236     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2237     
                      2238     ; MULTI
  0009                2239     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                2240     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                2241     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                2242     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                2243     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                2244     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
                      2245     IF DAMPED_MODE_ENABLE == 1
  0001                2246     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight 
                      2247     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low
                               ENDIF
  0002                2250     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                2251     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                2252     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
                      2253     IF BESCNO == SKYPUP_6A_MULTI
  00C8                2254     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 200	; , 
                      2255     ELSE
                               DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
                               ENDIF
  0050                2258     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0005                2259     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                      2260     
                      2261     ; COMMON
  0000                2262     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1=Enabled 	0=Disabled
  0003                2263     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                2264     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                2265     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (used in bidirectional mode)
  0000                2266     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1+= High or higher	
  0000                2267     DEFAULT_PGM_ENABLE_TEMP_PROT	 	EQU 0 	; 1=Enabled 	0=Disabled
                      2268     
                      2269     ;**** **** **** **** ****
                      2270     ; Constant definitions for main
                      2271     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_RED		EQU 	1	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2291     ; Constant definitions for tail
                      2292     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_START			EQU	50 	; PWM used as max power during start
                               
                               COMM_TIME_RED		EQU 	1	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      2312     ; Constant definitions for multi
                      2313     IF MODE == 2
                      2314     
  0001                2315     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
  000A                2316     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                2317     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                2318     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                2319     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                2320     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                2321     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                2322     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                2323     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      2324     
  0032                2325     PWM_START			EQU	50 	; PWM used as max power during start
                      2326     
  0001                2327     COMM_TIME_RED		EQU 	1	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                2328     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      2329     
  0008                2330     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      2331     
                      2332     ENDIF
                      2333     
                      2334     ;**** **** **** **** ****
                      2335     ; Temporary register definitions
  REG                 2336     TEMP1		EQU	R0
  REG                 2337     TEMP2		EQU	R1
  REG                 2338     TEMP3		EQU	R2
  REG                 2339     TEMP4		EQU	R3
  REG                 2340     TEMP5		EQU	R4
  REG                 2341     TEMP6		EQU	R5
  REG                 2342     TEMP7		EQU	R6
  REG                 2343     TEMP8		EQU	R7
                      2344     
                      2345     ;**** **** **** **** ****
                      2346     ; Register definitions
------                2347     DSEG AT 20H					; Variables segment 
                      2348     
0020                  2349     BIT_ACCESS: 				DS	1		; MUST BE AT THIS ADDRESS. Variable at bit accessible address (for non interrupt routines)
0021                  2350     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      2351     
0022                  2352     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  2353     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  2354     CURRENT_PWM: 				DS	1		; Current pwm
0025                  2355     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                  2356     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                  2357     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                  2358     RCP_OUTSIDE_RANGE_CNT: 		DS	1		; RC pulse outside range counter (incrementing) 
0029                  2359     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
002A                  2360     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002B                  2361     _SPARE_REG: 				DS	1		; Spare register 
                      2362     
002C                  2363     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                2364     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                2365     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                2366     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                2367     PWM_TIMER0_OVERFLOW			EQU	3		; Set for 50MHz MCUs when PWM timer 0 overflows
  0004                2368     DEMAG_ENABLED				EQU 	4		; Set when demag compensation is enabled (above a min speed and throttle)
  0005                2369     DEMAG_DETECTED				EQU 	5		; Set when excessive demag time is detected
  0006                2370     DEMAG_CUT_POWER			EQU 	6		; Set when demag compensation cuts power
                      2371     ;						EQU 	7
                      2372     
002D                  2373     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                2374     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                2375     STARTUP_PHASE				EQU 	1		; Set when in startup phase
  0002                2376     INITIAL_RUN_PHASE			EQU	2		; Set when in initial run phase, before synchronized run is achieved
  0003                2377     DIR_CHANGE_BRAKE			EQU 	3		; Set when braking before direction change
                      2378     ;						EQU 	4
                      2379     ;						EQU 	5
                      2380     ;						EQU 	6
                      2381     ;						EQU 	7
                      2382     
002E                  2383     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                2384     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                2385     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                2386     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode
  0003                2387     PGM_PWM_HIGH_FREQ			EQU	3		; Progremmed pwm high frequency
  0004                2388     RCP_PPM					EQU 	4		; RC pulse ppm type input (set also when oneshot is set)
  0005                2389     RCP_PPM_ONESHOT125			EQU 	5		; RC pulse ppm type input is OneShot125
                      2390     ;						EQU 	6	
                      2391     ;						EQU 	7	
                      2392     
002F                  2393     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                2394     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                2395     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                2396     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                2397     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                2398     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                2399     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                2400     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                2401     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      2402     
                      2403     
                      2404     ;**** **** **** **** ****
                      2405     ; RAM definitions
------                2406     DSEG AT 30H						; Ram data segment, direct addressing
                      2407     
0030                  2408     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      2409     
0031                  2410     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  2411     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      2412     
0033                  2413     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0034                  2414     STARTUP_OK_CNT: 			DS	1		; Startup phase ok comparator waits counter (incrementing)
0035                  2415     DEMAG_DETECTED_METRIC: 		DS	1		; Metric used to gauge demag event frequency
0036                  2416     DEMAG_PWR_OFF_THRESH: 		DS	1		; Metric threshold above which power is cut
0037                  2417     LOW_RPM_PWR_SLOPE: 			DS	1		; Sets the slope of power increase for low rpms
                      2418     
0038                  2419     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
0039                  2420     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003A                  2421     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003B                  2422     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003C                  2423     COMM_PHASE: 				DS	1		; Current commutation phase
003D                  2424     COMPARATOR_READ_CNT:  		DS	1		; Number of comparator reads done
                      2425     
003E                  2426     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
003F                  2427     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0040                  2428     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0041                  2429     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0042                  2430     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0043                  2431     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0044                  2432     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0045                  2433     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0046                  2434     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0047                  2435     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                      2436     
0048                  2437     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
0049                  2438     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004A                  2439     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004B                  2440     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004C                  2441     WT_ZC_TIMEOUT_L: 			DS	1		; Timer3 counts for zero cross scan timeout (lo byte)
004D                  2442     WT_ZC_TIMEOUT_H: 			DS	1		; Timer3 counts for zero cross scan timeout (hi byte)
004E                  2443     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                  2444     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                  2445     NEXT_WT_L: 				DS	1		; Timer3 counts for next wait period (lo byte)
0051                  2446     NEXT_WT_H: 				DS	1		; Timer3 counts for next wait period (hi byte)
                      2447     
0052                  2448     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                  2449     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                  2450     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                  2451     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                  2452     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                  2453     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                  2454     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                  2455     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                  2456     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                  2457     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                  2458     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                  2459     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      2460     
005E                  2461     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                  2462     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup
0060                  2463     PWM_LIMIT_LOW_RPM: 			DS	1		; Maximum allowed pwm for low rpms
0061                  2464     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0062                  2465     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0063                  2466     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
                      2467     
0064                  2468     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                  2469     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
0066                  2470     MAIN_SPOOLUP_TIME_3X: 		DS	1		; Main spoolup time x3
0067                  2471     MAIN_SPOOLUP_TIME_10X: 		DS	1		; Main spoolup time x10
0068                  2472     MAIN_SPOOLUP_TIME_15X: 		DS	1		; Main spoolup time x15
                      2473     
0069                  2474     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
006A                  2475     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006B                  2476     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006C                  2477     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006D                  2478     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      2479     
006E                  2480     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      2481     
006F                  2482     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
0070                  2483     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      2484     
0071                  2485     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0072                  2486     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0073                  2487     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      2488     
0074                  2489     SKIP_T2_INT: 				DS	1		; Set for 50MHz MCUs when timer 2 interrupt shall be ignored 
0075                  2490     SKIP_T2H_INT: 				DS	1		; Set for 50MHz MCUs when timer 2 high interrupt shall be ignored 
0076                  2491     TIMER0_OVERFLOW_VALUE: 		DS	1		; Remaining timer 0 wait time used with 50MHz MCUs
0077                  2492     CLOCK_SET_AT_50MHZ: 			DS	1		; Variable set if 50MHz MCUs run at 50MHz
                      2493     
                      2494     ; Indirect addressing data segment. The variables below must be in this sequence
------                2495     ISEG AT 080H					
0080                  2496     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  2497     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  2498     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  2499     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  2500     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  2501     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  2502     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  2503     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  2504     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  2505     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  2506     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  2507     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  2508     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  2509     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  2510     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  2511     _PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm (unused - place holder)
0090                  2512     _PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration (unused - place holder)
0091                  2513     _PGM_VOLT_COMP: 			DS	1		; Place holder
0092                  2514     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  2515     _PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force (unused - place holder)
0094                  2516     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  2517     _PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method (unused - place holder)
0096                  2518     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  2519     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  2520     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  2521     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  2522     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  2523     _PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate (unused - place holder)
009C                  2524     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  2525     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  2526     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
009F                  2527     PGM_MAIN_SPOOLUP_TIME: 		DS	1		; Programmed main spoolup time
00A0                  2528     PGM_ENABLE_TEMP_PROT: 		DS	1		; Programmed temperature protection enable
                      2529     
                      2530     ; The sequence of the variables below is no longer of importance
00A1                  2531     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A2                  2532     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A3                  2533     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
                      2534     
                      2535     
                      2536     ; Indirect addressing data segment
------                2537     ISEG AT 0D0H					
00D0                  2538     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      2539     
                      2540     
                      2541     ;**** **** **** **** ****
------                2542     CSEG AT 1A00H            ; "Eeprom" segment
  000D                2543     EEPROM_FW_MAIN_REVISION		EQU	13		; Main revision of the firmware
  0002                2544     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0013                2545     EEPROM_LAYOUT_REVISION		EQU	19		; Revision of the EEPROM layout
                      2546     
1A00    0D            2547     EEP_FW_MAIN_REVISION:  DB 13 
1A01    02            2548     EEP_FW_SUB_REVISION:  DB 2 
1A02    13            2549     EEP_LAYOUT_REVISION:  DB 19 
                      2550     
                      2551     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH	
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH	
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH						
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH	
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH	
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               EEP_PGM_MAIN_SPOOLUP_TIME:	DB	DEFAULT_PGM_MAIN_SPOOLUP_TIME		; EEPROM copy of programmed main spoolup time
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               ENDIF
                      2586     
                      2587     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               _EEP_PGM_STARTUP_RPM:		DB	0FFH
                               _EEP_PGM_STARTUP_ACCEL:		DB	0FFH
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               _EEP_PGM_DAMPING_FORCE:		DB	0FFH
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               _EEP_PGM_STARTUP_METHOD:		DB	0FFH
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               _EEP_PGM_THROTTLE_RATE:		DB	0FFH
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               _EEP_PGM_MAIN_SPOOLUP_TIME:	DB	0FFH
                               EEP_PGM_TEMP_PROT_ENABLE:	DB	DEFAULT_PGM_ENABLE_TEMP_PROT		; EEPROM copy of programmed temperature protection enable
                               ENDIF
                      2622     
                      2623     IF MODE == 2
1A03    09            2624     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            2625     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            2626     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            2627     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            2628     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            2629     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    0B            2630     EEP_PGM_STARTUP_PWR:  DB 11 
1A0A    01            2631     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            2632     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            2633     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            2634     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            2635     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            2636     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            2637     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            2638     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    FF            2639     _EEP_PGM_STARTUP_RPM: 		DB	0FFH
1A13    FF            2640     _EEP_PGM_STARTUP_ACCEL: 		DB	0FFH
1A14    FF            2641     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            2642     EEP_PGM_COMM_TIMING:  DB 3 
1A16    FF            2643     _EEP_PGM_DAMPING_FORCE: 		DB	0FFH
1A17    FF            2644     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    FF            2645     _EEP_PGM_STARTUP_METHOD: 		DB	0FFH
1A19    03            2646     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            2647     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    C8            2648     EEP_PGM_BEEP_STRENGTH:  DB 200 
1A1C    50            2649     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    05            2650     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    FF            2651     _EEP_PGM_THROTTLE_RATE: 		DB	0FFH
1A1F    02            2652     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            2653     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            2654     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
1A22    FF            2655     _EEP_PGM_MAIN_SPOOLUP_TIME: 	DB	0FFH
1A23    00            2656     EEP_PGM_TEMP_PROT_ENABLE:  DB 0 
                      2657     ENDIF
                      2658     
1A24    FF            2659     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      2660     
------                2661     CSEG AT 1A60H
1A60    20202020      2662     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      2663     
                      2664     ;**** **** **** **** ****
                      2665      INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                2665+1   CSEG AT 0  ; CODE SEGMENT START
0000    0210E2        2665+1   JMP RESET 
------                2665+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200A5        2665+1   JMP T0_INT 
------                2665+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0202AE        2665+1   JMP T2_INT 
------                2665+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    02040C        2665+1   JMP PCA_INT 
------                2665+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    0203E6        2665+1   JMP T3_INT 
------                2666     CSEG AT 80H			; Code segment after interrupt vectors 
                      2667     
                      2668     ;**** **** **** **** ****
                      2669     
                      2670     ; Table definitions
0080    02030406      2671     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    0406080C      2672     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
0091    10182030
0095    406080A0
0099    C0
                      2673     IF MODE == 0
                                 IF DAMPED_MODE_ENABLE == 1
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                                 ENDIF
                               ENDIF
                      2681     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               	TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 3, 3, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 13, 5, 2, 3, 3, 2
                                 ENDIF
                               ENDIF
                      2689     IF MODE == 2
                      2690       IF DAMPED_MODE_ENABLE == 1
009A    0D0D0405      2691     	TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 13, 5, 3, 3, 3, 2
009E    060D0503
00A2    030302
                      2692       ENDIF
                      2693       IF DAMPED_MODE_ENABLE == 0
                               	TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 13, 5, 2, 3, 3, 2
                                 ENDIF
                      2696     ENDIF
                      2697     
                      2698     
                      2699     
                      2700     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2701     ;
                      2702     ; Timer0 interrupt routine
                      2703     ;
                      2704     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      2705     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      2706     ;
                      2707     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2708     T0_INT: 	; Used for pwm control
                      2709     IF MCU_50MHZ == 1
                               	; Check overflow flag
                               	JNB	FLAGS0.PWM_TIMER0_OVERFLOW, T0_INT_START; Execute this interrupt
                               
                               	CLR	FLAGS0.PWM_TIMER0_OVERFLOW
                               	MOV	TL0, TIMER0_OVERFLOW_VALUE	; Set timer 
                               	RETI
                               
                               T0_INT_START:
                               ENDIF
00A5    C2AF          2719     	CLR 	EA			; Disable all interrupts
00A7    C0D0          2720     	PUSH	PSW			; Preserve registers through interrupt
00A9    C0E0          2721     	PUSH	ACC		
                      2722     	; Check if pwm is on
00AB    20620C        2723     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      2724     
                      2725     	; Do not execute pwm when stopped
00AE    206802        2726     JB FLAGS1 . 0 , ( $+5 ) 
00B1    419D          2727     	AJMP	T0_INT_PWM_ON_EXIT
                      2728     	; Do not execute pwm on during demag recovery
00B3    306602        2729     JNB FLAGS0 . 6 , ( $+5 ) 
00B6    415D          2730     	AJMP	T0_INT_PWM_ON_EXIT_PFETS_OFF
                      2731     	; Pwm on cycle. 
                      2732     IF MODE == 1				; Tail
                               	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                               ENDIF
                      2735     
                      2736     T0_INT_PWM_ON_EXECUTE: 
00B8    E4            2737     	CLR	A					
00B9    73            2738     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      2739     
                      2740     IF MODE == 1				; Tail
                               T0_INT_PWM_ON_LOW_PWM:
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	JB	FLAGS1.STARTUP_PHASE, T0_INT_PWM_ON_EXECUTE
                               
                               IF MCU_50MHZ == 0
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	T0_INT_PWM_ON_LOW_PWM_DONE
                               
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               
                               ELSE
                               	MOV	TL0, #0				
                               	MOV	TH1, #0		
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	T0_INT_PWM_ON_LOW_PWM_DONE
                               
                               	MOV	TL0, #0				
                               	MOV	TH1, #0		
                               	SETB	FLAGS0.PWM_TIMER0_OVERFLOW
                               	MOV	TIMER0_OVERFLOW_VALUE, #0		
                               
                               ENDIF
                               T0_INT_PWM_ON_LOW_PWM_DONE:
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      2776     
                      2777     T0_INT_PWM_OFF: 
                      2778     	; Pwm off cycle
                      2779     IF MCU_50MHZ == 0
00BA    85258A        2780     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      2781     ELSE
                               	CLR	C
                               	MOV	A, CURRENT_PWM_LIMITED
                               	RLC	A
                               	JC	T0_INT_PWM_OFF_SET_TIMER 
                               
                               	MOV	TL0, #0
                               	SETB	FLAGS0.PWM_TIMER0_OVERFLOW
                               	MOV	TIMER0_OVERFLOW_VALUE, A
                               	AJMP	T0_INT_PWM_OFF_TIMER_SET
                               
                               T0_INT_PWM_OFF_SET_TIMER:
                               	MOV	TL0, A
                               T0_INT_PWM_OFF_TIMER_SET:
                               ENDIF
                      2796     	; Clear pwm on flag
00BD    C262          2797     CLR FLAGS0 . 2 
                      2798     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00BF    E525          2799     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00C1    F4            2800     	CPL	A						; Full pwm?
00C2    7002          2801     	JNZ	($+4)					; No - branch
00C4    2124          2802     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      2803     
                      2804     	; Do not execute pwm when stopped
00C6    206802        2805     JB FLAGS1 . 0 , ( $+5 ) 
00C9    2111          2806     	AJMP	T0_INT_PWM_OFF_EXIT_NFETS_OFF
                      2807     
                      2808     IF DAMPED_MODE_ENABLE == 1
                      2809     	; If damped operation, set pFETs on in pwm_off
00CB    207210        2810     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      2811     ENDIF
                      2812     
                      2813     	; Separate exit commands here for minimum delay
00CE    758B00        2814     	MOV	TL1, #0		; Reset timer1	
                      2815     IF MCU_50MHZ == 1
                               	MOV	TH1, #0		
                               ENDIF
00D1    D0E0          2818     	POP	ACC			; Restore preserved registers
00D3    D0D0          2819     	POP	PSW
                      2820     	ALL_NFETS_OFF 		; Switch off all nfets
00D5    D291          2820+1   SETB P1 . 1 
00D7    D293          2820+1   SETB P1 . 3 
00D9    D295          2820+1   SETB P1 . 5 
00DB    D2AF          2821     	SETB	EA			; Enable all interrupts
00DD    32            2822     	RETI
                      2823     
                      2824     T0_INT_PWM_OFF_DAMPED: 
                      2825     	ALL_NFETS_OFF 					; Switch off all nfets
00DE    D291          2825+1   SETB P1 . 1 
00E0    D293          2825+1   SETB P1 . 3 
00E2    D295          2825+1   SETB P1 . 5 
00E4    7401          2826     MOV A , # 1 
00E6    D5E0FD        2827     	DJNZ	ACC, $	
00E9    E53C          2828     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
00EB    14            2829     	DEC	A
00EC    20E215        2830     	JB	ACC.2, T0_INT_PWM_OFF_COMM_5_6
00EF    20E10D        2831     	JB	ACC.1, T0_INT_PWM_OFF_COMM_3_4
                      2832     
                      2833     	CPFET_ON			; Comm phase 1 or 2 - turn on C
00F2    207D02        2833+1   JB FLAGS3 . 5 , ( $+5 ) 
00F5    D294          2833+1   SETB P1 . 4 
00F7    307D02        2833+1   JNB FLAGS3 . 5 , ( $+5 ) 
00FA    D290          2833+1   SETB P1 . 0 
00FC    020121        2834     	JMP	T0_INT_PWM_OFF_EXIT
                      2835     
                      2836     T0_INT_PWM_OFF_COMM_3_4: 
                      2837     	BPFET_ON			; Comm phase 3 or 4 - turn on B
00FF    D292          2837+1   SETB P1 . 2 
0101    020121        2838     	JMP	T0_INT_PWM_OFF_EXIT
                      2839     
                      2840     T0_INT_PWM_OFF_COMM_5_6: 
                      2841     	APFET_ON			; Comm phase 5 or 6 - turn on A
0104    207D02        2841+1   JB FLAGS3 . 5 , ( $+5 ) 
0107    D290          2841+1   SETB P1 . 0 
0109    307D02        2841+1   JNB FLAGS3 . 5 , ( $+5 ) 
010C    D294          2841+1   SETB P1 . 4 
010E    020121        2842     	JMP	T0_INT_PWM_OFF_EXIT
                      2843     
                      2844     T0_INT_PWM_OFF_EXIT_NFETS_OFF: 	; Exit from pwm off cycle
0111    758B00        2845     	MOV	TL1, #0		; Reset timer1	
                      2846     IF MCU_50MHZ == 1
                               	MOV	TH1, #0		
                               ENDIF
0114    D0E0          2849     	POP	ACC			; Restore preserved registers
0116    D0D0          2850     	POP	PSW
                      2851     	ALL_NFETS_OFF 		; Switch off all nfets
0118    D291          2851+1   SETB P1 . 1 
011A    D293          2851+1   SETB P1 . 3 
011C    D295          2851+1   SETB P1 . 5 
011E    D2AF          2852     	SETB	EA			; Enable all interrupts
0120    32            2853     	RETI
                      2854     
                      2855     T0_INT_PWM_OFF_EXIT: 
0121    758B00        2856     	MOV	TL1, #0		; Reset timer1	
                      2857     IF MCU_50MHZ == 1
                               	MOV	TH1, #0		
                               ENDIF
                      2860     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	
0124    D0E0          2861     	POP	ACC			; Restore preserved registers
0126    D0D0          2862     	POP	PSW
0128    D2AF          2863     	SETB	EA			; Enable all interrupts
012A    32            2864     	RETI
                      2865     
                      2866     
                      2867     PWM_NOFET_ON: 	; Dummy pwm on cycle
012B    419D          2868     	AJMP	T0_INT_PWM_ON_EXIT
                      2869     
                      2870     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      2871     	ANFET_ON	
012D    E525          2871+1   MOV A , CURRENT_PWM_LIMITED 
012F    600A          2871+1   JZ ( $+12 ) 
0131    207D02        2871+1   JB FLAGS3 . 5 , ( $+5 ) 
0134    C291          2871+1   CLR P1 . 1 
0136    307D02        2871+1   JNB FLAGS3 . 5 , ( $+5 ) 
0139    C295          2871+1   CLR P1 . 5 
                      2872     	BNFET_OFF
013B    D293          2872+1   SETB P1 . 3 
013D    419D          2873     	AJMP	T0_INT_PWM_ON_EXIT
                      2874     
                      2875     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      2876     	BNFET_ON
013F    E525          2876+1   MOV A , CURRENT_PWM_LIMITED 
0141    6002          2876+1   JZ ( $+4 ) 
0143    C293          2876+1   CLR P1 . 3 
                      2877     	CNFET_OFF
0145    207D02        2877+1   JB FLAGS3 . 5 , ( $+5 ) 
0148    D295          2877+1   SETB P1 . 5 
014A    307D02        2877+1   JNB FLAGS3 . 5 , ( $+5 ) 
014D    D291          2877+1   SETB P1 . 1 
014F    419D          2878     	AJMP	T0_INT_PWM_ON_EXIT
                      2879     
                      2880     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      2881     	CNFET_ON
0151    E525          2881+1   MOV A , CURRENT_PWM_LIMITED 
0153    600A          2881+1   JZ ( $+12 ) 
0155    207D02        2881+1   JB FLAGS3 . 5 , ( $+5 ) 
0158    C295          2881+1   CLR P1 . 5 
015A    307D02        2881+1   JNB FLAGS3 . 5 , ( $+5 ) 
015D    C291          2881+1   CLR P1 . 1 
                      2882     	ANFET_OFF
015F    207D02        2882+1   JB FLAGS3 . 5 , ( $+5 ) 
0162    D291          2882+1   SETB P1 . 1 
0164    307D02        2882+1   JNB FLAGS3 . 5 , ( $+5 ) 
0167    D295          2882+1   SETB P1 . 5 
0169    419D          2883     	AJMP	T0_INT_PWM_ON_EXIT
                      2884     
                      2885     PWM_ANFET_BPFET_ON: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      2886     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2887     	APFET_OFF
016B    207D02        2887+1   JB FLAGS3 . 5 , ( $+5 ) 
016E    C290          2887+1   CLR P1 . 0 
0170    307D02        2887+1   JNB FLAGS3 . 5 , ( $+5 ) 
0173    C294          2887+1   CLR P1 . 4 
                      2888     	CPFET_OFF
0175    207D02        2888+1   JB FLAGS3 . 5 , ( $+5 ) 
0178    C294          2888+1   CLR P1 . 4 
017A    307D02        2888+1   JNB FLAGS3 . 5 , ( $+5 ) 
017D    C290          2888+1   CLR P1 . 0 
017F    7428          2889     MOV A , # 40 
0181    D5E0FD        2890     	DJNZ ACC,	$
                      2891     	ANFET_ON								; Switch nFETs
0184    E525          2891+1   MOV A , CURRENT_PWM_LIMITED 
0186    600A          2891+1   JZ ( $+12 ) 
0188    207D02        2891+1   JB FLAGS3 . 5 , ( $+5 ) 
018B    C291          2891+1   CLR P1 . 1 
018D    307D02        2891+1   JNB FLAGS3 . 5 , ( $+5 ) 
0190    C295          2891+1   CLR P1 . 5 
                      2892     	BNFET_OFF 							
0192    D293          2892+1   SETB P1 . 3 
0194    419D          2893     	AJMP	T0_INT_PWM_ON_EXIT
                      2894     
                      2895     PWM_ANFET_CPFET_ON: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      2896     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2897     	APFET_OFF
0196    207D02        2897+1   JB FLAGS3 . 5 , ( $+5 ) 
0199    C290          2897+1   CLR P1 . 0 
019B    307D02        2897+1   JNB FLAGS3 . 5 , ( $+5 ) 
019E    C294          2897+1   CLR P1 . 4 
                      2898     	BPFET_OFF
01A0    C292          2898+1   CLR P1 . 2 
01A2    7428          2899     MOV A , # 40 
01A4    D5E0FD        2900     	DJNZ ACC,	$
                      2901     	ANFET_ON								; Switch nFETs
01A7    E525          2901+1   MOV A , CURRENT_PWM_LIMITED 
01A9    600A          2901+1   JZ ( $+12 ) 
01AB    207D02        2901+1   JB FLAGS3 . 5 , ( $+5 ) 
01AE    C291          2901+1   CLR P1 . 1 
01B0    307D02        2901+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B3    C295          2901+1   CLR P1 . 5 
                      2902     	BNFET_OFF								
01B5    D293          2902+1   SETB P1 . 3 
01B7    419D          2903     	AJMP	T0_INT_PWM_ON_EXIT
                      2904     
                      2905     PWM_BNFET_CPFET_ON: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      2906     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2907     	BPFET_OFF
01B9    C292          2907+1   CLR P1 . 2 
                      2908     	APFET_OFF
01BB    207D02        2908+1   JB FLAGS3 . 5 , ( $+5 ) 
01BE    C290          2908+1   CLR P1 . 0 
01C0    307D02        2908+1   JNB FLAGS3 . 5 , ( $+5 ) 
01C3    C294          2908+1   CLR P1 . 4 
01C5    7428          2909     MOV A , # 40 
01C7    D5E0FD        2910     	DJNZ ACC,	$
                      2911     	BNFET_ON								; Switch nFETs
01CA    E525          2911+1   MOV A , CURRENT_PWM_LIMITED 
01CC    6002          2911+1   JZ ( $+4 ) 
01CE    C293          2911+1   CLR P1 . 3 
                      2912     	CNFET_OFF								
01D0    207D02        2912+1   JB FLAGS3 . 5 , ( $+5 ) 
01D3    D295          2912+1   SETB P1 . 5 
01D5    307D02        2912+1   JNB FLAGS3 . 5 , ( $+5 ) 
01D8    D291          2912+1   SETB P1 . 1 
01DA    419D          2913     	AJMP	T0_INT_PWM_ON_EXIT
                      2914     
                      2915     PWM_BNFET_APFET_ON: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      2916     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2917     	BPFET_OFF
01DC    C292          2917+1   CLR P1 . 2 
                      2918     	CPFET_OFF
01DE    207D02        2918+1   JB FLAGS3 . 5 , ( $+5 ) 
01E1    C294          2918+1   CLR P1 . 4 
01E3    307D02        2918+1   JNB FLAGS3 . 5 , ( $+5 ) 
01E6    C290          2918+1   CLR P1 . 0 
01E8    7428          2919     MOV A , # 40 
01EA    D5E0FD        2920     	DJNZ ACC,	$
                      2921     	BNFET_ON								; Switch nFETs
01ED    E525          2921+1   MOV A , CURRENT_PWM_LIMITED 
01EF    6002          2921+1   JZ ( $+4 ) 
01F1    C293          2921+1   CLR P1 . 3 
                      2922     	CNFET_OFF								
01F3    207D02        2922+1   JB FLAGS3 . 5 , ( $+5 ) 
01F6    D295          2922+1   SETB P1 . 5 
01F8    307D02        2922+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FB    D291          2922+1   SETB P1 . 1 
01FD    419D          2923     	AJMP	T0_INT_PWM_ON_EXIT
                      2924     
                      2925     PWM_CNFET_APFET_ON: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      2926     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2927     	CPFET_OFF
01FF    207D02        2927+1   JB FLAGS3 . 5 , ( $+5 ) 
0202    C294          2927+1   CLR P1 . 4 
0204    307D02        2927+1   JNB FLAGS3 . 5 , ( $+5 ) 
0207    C290          2927+1   CLR P1 . 0 
                      2928     	BPFET_OFF
0209    C292          2928+1   CLR P1 . 2 
020B    7428          2929     MOV A , # 40 
020D    D5E0FD        2930     	DJNZ ACC,	$
                      2931     	CNFET_ON								; Switch nFETs
0210    E525          2931+1   MOV A , CURRENT_PWM_LIMITED 
0212    600A          2931+1   JZ ( $+12 ) 
0214    207D02        2931+1   JB FLAGS3 . 5 , ( $+5 ) 
0217    C295          2931+1   CLR P1 . 5 
0219    307D02        2931+1   JNB FLAGS3 . 5 , ( $+5 ) 
021C    C291          2931+1   CLR P1 . 1 
                      2932     	ANFET_OFF								
021E    207D02        2932+1   JB FLAGS3 . 5 , ( $+5 ) 
0221    D291          2932+1   SETB P1 . 1 
0223    307D02        2932+1   JNB FLAGS3 . 5 , ( $+5 ) 
0226    D295          2932+1   SETB P1 . 5 
0228    419D          2933     	AJMP	T0_INT_PWM_ON_EXIT
                      2934     
                      2935     PWM_CNFET_BPFET_ON: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      2936     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2937     	CPFET_OFF
022A    207D02        2937+1   JB FLAGS3 . 5 , ( $+5 ) 
022D    C294          2937+1   CLR P1 . 4 
022F    307D02        2937+1   JNB FLAGS3 . 5 , ( $+5 ) 
0232    C290          2937+1   CLR P1 . 0 
                      2938     	APFET_OFF
0234    207D02        2938+1   JB FLAGS3 . 5 , ( $+5 ) 
0237    C290          2938+1   CLR P1 . 0 
0239    307D02        2938+1   JNB FLAGS3 . 5 , ( $+5 ) 
023C    C294          2938+1   CLR P1 . 4 
023E    7428          2939     MOV A , # 40 
0240    D5E0FD        2940     	DJNZ ACC,	$
                      2941     	CNFET_ON								; Switch nFETs
0243    E525          2941+1   MOV A , CURRENT_PWM_LIMITED 
0245    600A          2941+1   JZ ( $+12 ) 
0247    207D02        2941+1   JB FLAGS3 . 5 , ( $+5 ) 
024A    C295          2941+1   CLR P1 . 5 
024C    307D02        2941+1   JNB FLAGS3 . 5 , ( $+5 ) 
024F    C291          2941+1   CLR P1 . 1 
                      2942     	ANFET_OFF								
0251    207D02        2942+1   JB FLAGS3 . 5 , ( $+5 ) 
0254    D291          2942+1   SETB P1 . 1 
0256    307D02        2942+1   JNB FLAGS3 . 5 , ( $+5 ) 
0259    D295          2942+1   SETB P1 . 5 
025B    419D          2943     	AJMP	T0_INT_PWM_ON_EXIT
                      2944     
                      2945     T0_INT_PWM_ON_EXIT_PFETS_OFF: 
025D    30723D        2946     JNB FLAGS2 . 2 , T0_INT_PWM_ON_EXIT 
0260    E53C          2947     	MOV	A, COMM_PHASE				; Turn off pfets according to commutation phase
0262    20E21A        2948     	JB	ACC.2, T0_INT_PFETS_OFF_COMM_4_5_6
0265    20E129        2949     	JB	ACC.1, T0_INT_PFETS_OFF_COMM_2_3
                      2950     
                      2951     T0_INT_PFETS_OFF_COMM_1_6: 
                      2952     	APFET_OFF			; Comm phase 1 and 6 - turn off A and C
0268    207D02        2952+1   JB FLAGS3 . 5 , ( $+5 ) 
026B    C290          2952+1   CLR P1 . 0 
026D    307D02        2952+1   JNB FLAGS3 . 5 , ( $+5 ) 
0270    C294          2952+1   CLR P1 . 4 
                      2953     	CPFET_OFF			
0272    207D02        2953+1   JB FLAGS3 . 5 , ( $+5 ) 
0275    C294          2953+1   CLR P1 . 4 
0277    307D02        2953+1   JNB FLAGS3 . 5 , ( $+5 ) 
027A    C290          2953+1   CLR P1 . 0 
027C    02029D        2954     	JMP	T0_INT_PWM_ON_EXIT
                      2955     
                      2956     T0_INT_PFETS_OFF_COMM_4_5_6: 
027F    20E1E6        2957     	JB	ACC.1, T0_INT_PFETS_OFF_COMM_1_6
                      2958     	APFET_OFF			; Comm phase 4 and 5 - turn off A and B
0282    207D02        2958+1   JB FLAGS3 . 5 , ( $+5 ) 
0285    C290          2958+1   CLR P1 . 0 
0287    307D02        2958+1   JNB FLAGS3 . 5 , ( $+5 ) 
028A    C294          2958+1   CLR P1 . 4 
                      2959     	BPFET_OFF			
028C    C292          2959+1   CLR P1 . 2 
028E    02029D        2960     	JMP	T0_INT_PWM_ON_EXIT
                      2961     
                      2962     T0_INT_PFETS_OFF_COMM_2_3: 
                      2963     	BPFET_OFF			; Comm phase 2 and 3 - turn off B and C
0291    C292          2963+1   CLR P1 . 2 
                      2964     	CPFET_OFF			
0293    207D02        2964+1   JB FLAGS3 . 5 , ( $+5 ) 
0296    C294          2964+1   CLR P1 . 4 
0298    307D02        2964+1   JNB FLAGS3 . 5 , ( $+5 ) 
029B    C290          2964+1   CLR P1 . 0 
                      2965     
                      2966     T0_INT_PWM_ON_EXIT: 
                      2967     	; Set timer for coming on cycle length
029D    E525          2968     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
029F    F4            2969     	CPL	A						; cpl is 255-x
                      2970     IF MCU_50MHZ == 0
02A0    F58A          2971     	MOV	TL0, A					; Write start point for timer
                      2972     ELSE
                               	CLR	C
                               	RLC	A
                               	JC	T0_INT_PWM_ON_SET_TIMER
                               
                               	MOV	TL0, #0
                               	SETB	FLAGS0.PWM_TIMER0_OVERFLOW
                               	MOV	TIMER0_OVERFLOW_VALUE, A
                               	AJMP	T0_INT_PWM_ON_TIMER_SET
                               
                               T0_INT_PWM_ON_SET_TIMER:
                               	MOV	TL0, A
                               T0_INT_PWM_ON_TIMER_SET:
                               ENDIF
                      2986     	; Set other variables
02A2    758B00        2987     	MOV	TL1, #0					; Reset timer1	
                      2988     IF MCU_50MHZ == 1
                               	MOV	TH1, #0		
                               ENDIF
                      2991     IF MODE == 1				; Tail
                               	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
                               ENDIF
02A5    D262          2994     SETB FLAGS0 . 2 
                      2995     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      2996     	; Exit interrupt
02A7    D0E0          2997     	POP	ACC			; Restore preserved registers
02A9    D0D0          2998     	POP	PSW
02AB    D2AF          2999     	SETB	EA			; Enable all interrupts
02AD    32            3000     	RETI
                      3001     
                      3002     
                      3003     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3004     ;
                      3005     ; Timer2 interrupt routine
                      3006     ;
                      3007     ; No assumptions
                      3008     ;
                      3009     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3010     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
02AE    C2AF          3011     	CLR	EA
02B0    C2AD          3012     	CLR	ET2			; Disable timer2 interrupts
02B2    53E6EF        3013     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
02B5    C0D0          3014     	PUSH	PSW			; Preserve registers through interrupt
02B7    C0E0          3015     	PUSH	ACC
02B9    D2D3          3016     	SETB	PSW.3		; Select register bank 1 for interrupt routines
02BB    D2AF          3017     	SETB	EA
                      3018     IF MCU_50MHZ == 1
                               	MOV	A, CLOCK_SET_AT_50MHZ
                               	JZ 	T2_INT_START
                               
                               	; Check skip variable
                               	MOV	A, SKIP_T2_INT
                               	JZ	T2_INT_START				; Execute this interrupt
                               
                               	MOV	SKIP_T2_INT, #0
                               	AJMP	T2_INT_EXIT
                               
                               T2_INT_START:
                               	MOV	SKIP_T2_INT, #1			; Skip next interrupt
                               ENDIF
                      3032     	; Clear low byte interrupt flag
02BD    C2CE          3033     	CLR	TF2L						; Clear interrupt flag
                      3034     	; Check RC pulse timeout counter
02BF    E529          3035     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
02C1    6007          3036     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      3037     
                      3038     	; Decrement timeout counter (if PWM)
02C3    207446        3039     JB FLAGS2 . 4 , T2_INT_SKIP_START 
                      3040     
02C6    1529          3041     	DEC	RCP_TIMEOUT_CNT			; No - decrement
02C8    610C          3042     	AJMP	T2_INT_SKIP_START
                      3043     
                      3044     T2_INT_PULSES_ABSENT: 
                      3045     	; Timeout counter has reached zero, pulses are absent
02CA    7800          3046     MOV R0 , # 0 
02CC    7900          3047     MOV R1 , # 0 
                      3048     	READ_RCP_INT 					; Look at value of Rcp_In
02CE    E580          3048+1   MOV A , P0 
02D0    307E01        3048+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
02D3    F4            3048+1   CPL A  ; YES - INVERT
02D4    30E402        3049     JNB ACC . 4 , ( $+5 ) 
02D7    78FF          3050     MOV R0 , # 255 
                      3051     	RCP_INT_FIRST 					; Set interrupt trig to first again
02D9    53DACF        3051+1   ANL PCA0CPM0 , # 0CFH 
02DC    207E03        3051+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
02DF    43DA20        3051+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
02E2    307E03        3051+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
02E5    43DA10        3051+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3052     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
02E8    C2D8          3052+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
02EA    C271          3053     CLR FLAGS2 . 1 
                      3054     	READ_RCP_INT 					; Look once more at value of Rcp_In
02EC    E580          3054+1   MOV A , P0 
02EE    307E01        3054+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
02F1    F4            3054+1   CPL A  ; YES - INVERT
02F2    30E402        3055     JNB ACC . 4 , ( $+5 ) 
02F5    79FF          3056     MOV R1 , # 255 
02F7    C3            3057     	CLR	C
02F8    E8            3058     MOV A , R0 
02F9    99            3059     SUBB A , R1 
02FA    70CE          3060     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      3061     
02FC    306103        3062     JNB FLAGS0 . 1 , ( $+6 ) 
                      3063     
02FF    752918        3064     MOV RCP_TIMEOUT_CNT , # 24 
                      3065     
0302    207403        3066     JB FLAGS2 . 4 , T2_INT_PPM_TIMEOUT_SET 
                      3067     
0305    752918        3068     MOV RCP_TIMEOUT_CNT , # 24 
                      3069     
                      3070     T2_INT_PPM_TIMEOUT_SET: 
0308    8859          3071     MOV NEW_RCP , R0 
030A    D270          3072     SETB FLAGS2 . 0 
                      3073     
                      3074     T2_INT_SKIP_START: 
                      3075     	; Check RC pulse skip counter
030C    E52A          3076     	MOV	A, RCP_SKIP_CNT			
030E    6004          3077     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      3078     	
                      3079     	; Decrement skip counter (only if edge counter is zero)
0310    152A          3080     	DEC	RCP_SKIP_CNT				; Decrement
0312    611C          3081     	AJMP	T2_INT_RCP_UPDATE_START
                      3082     
                      3083     T2_INT_SKIP_END: 
0314    207405        3084     JB FLAGS2 . 4 , T2_INT_RCP_UPDATE_START 
                      3085     
                      3086     	; Skip counter has reached zero, start looking for RC pulses again
                      3087     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0317    43DA01        3087+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      3088     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
031A    C2D8          3088+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3089     	
                      3090     T2_INT_RCP_UPDATE_START: 
                      3091     	; Process updated RC pulse
031C    207002        3092     JB FLAGS2 . 0 , ( $+5 ) 
031F    6183          3093     	AJMP	T2_INT_CURRENT_PWM_DONE		; No - update pwm limits and exit
                      3094     
0321    A859          3095     MOV R0 , NEW_RCP 
0323    206102        3096     JB FLAGS0 . 1 , ( $+5 ) 
                      3097     
0326    C270          3098     CLR FLAGS2 . 0 
                      3099     
                      3100     	; Use a gain of 1.0625x for pwm input if not governor mode
0328    207436        3101     JB FLAGS2 . 4 , T2_INT_PWM_MIN_RUN 
                      3102     
                      3103     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ELSE
                      3106     
                      3107     IF MODE == 2	; Multi 
032B    7982          3108     MOV R1 , # PGM_GOV_MODE 
032D    B70431        3109     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      3110     ENDIF
                      3111     
                      3112     	; Limit the maximum value to avoid wrap when scaled to pwm range
0330    C3            3113     	CLR	C
0331    E8            3114     MOV A , R0 
0332    94F0          3115     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0334    4003          3116     	JC	T2_INT_RCP_UPDATE_MULT
                      3117     
0336    74F0          3118     	MOV	A, #240			; Set requested pwm to max
0338    F8            3119     MOV R0 , A 
                      3120     
                      3121     T2_INT_RCP_UPDATE_MULT: 	
                      3122     	; Multiply by 1.0625 (optional adjustment gyro gain)
0339    E8            3123     MOV A , R0 
033A    C4            3124     	SWAP	A			; After this "0.0625"
033B    540F          3125     	ANL	A, #0FH
033D    28            3126     ADD A , R0 
033E    F8            3127     MOV R0 , A 
                      3128     	; Adjust tail gain
033F    7984          3129     MOV R1 , # PGM_MOTOR_GAIN 
0341    B70302        3130     CJNE @ R1 , # 3 , ( $+5 ) 
0344    6161          3131     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      3132     
0346    C3            3133     	CLR	C
0347    13            3134     	RRC	A			; After this "0.5"
0348    C3            3135     	CLR	C
0349    13            3136     	RRC	A			; After this "0.25"
034A    8721          3137     MOV BIT_ACCESS_INT , @ R1 
034C    200802        3138     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      3139     
034F    C3            3140     	CLR	C
0350    13            3141     	RRC	A			; After this "0.125"
                      3142     
                      3143     T2_INT_RCP_GAIN_CORR: 
0351    200A06        3144     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      3145     
0354    C3            3146     	CLR	C
0355    C8            3147     XCH A , R0 
0356    98            3148     SUBB A , R0 
0357    F8            3149     MOV R0 , A 
0358    6161          3150     	AJMP	T2_INT_PWM_MIN_RUN
                      3151     
                      3152     T2_INT_RCP_GAIN_POS: 
035A    28            3153     ADD A , R0 
035B    F8            3154     MOV R0 , A 
035C    5003          3155     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      3156     
035E    74FF          3157     	MOV	A, #0FFH					; Yes - limit
0360    F8            3158     MOV R0 , A 
                      3159     ENDIF
                      3160     
                      3161     T2_INT_PWM_MIN_RUN:  
                      3162     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      3172     
                      3173     T2_INT_PWM_UPDATE:  
                      3174     	; Update requested_pwm
0361    8822          3175     MOV REQUESTED_PWM , R0 
                      3176     	; Limit pwm during direct start
0363    306915        3177     JNB FLAGS1 . 1 , T2_INT_CURRENT_PWM_UPDATE 
                      3178     
                      3179     IF MODE == 2	; Multi
0366    E522          3180     	MOV	A, REQUESTED_PWM
0368    2408          3181     	ADD	A, #8					; Add an extra power boost during start
036A    F522          3182     	MOV	REQUESTED_PWM, A
                      3183     
036C    5003          3184     	JNC	($+5)
036E    7522FF        3185     	MOV	REQUESTED_PWM, #0FFH
                      3186     ENDIF
0371    C3            3187     	CLR	C
0372    E522          3188     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
0374    955E          3189     	SUBB	A, PWM_LIMIT
0376    4003          3190     	JC	T2_INT_CURRENT_PWM_UPDATE
                      3191     
0378    855E22        3192     	MOV	REQUESTED_PWM, PWM_LIMIT
                      3193     
                      3194     T2_INT_CURRENT_PWM_UPDATE:  
                      3195     IF MODE == 0 OR MODE == 2	; Main or multi
037B    7882          3196     MOV R0 , # PGM_GOV_MODE 
037D    B60418        3197     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      3198     ENDIF
                      3199     
0380    852224        3200     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      3201     T2_INT_CURRENT_PWM_DONE: 
                      3202     IF MODE >= 1	; Tail or multi
                      3203     	; Set current_pwm_limited
0383    A824          3204     MOV R0 , CURRENT_PWM 
0385    C3            3205     	CLR	C
0386    E524          3206     	MOV	A, CURRENT_PWM				; Check against limit
0388    955E          3207     	SUBB	A, PWM_LIMIT
038A    4002          3208     	JC	($+4)					; If current pwm below limit - branch
                      3209     
038C    A85E          3210     MOV R0 , PWM_LIMIT 
                      3211     
                      3212     IF MODE == 2	; Multi
                      3213     	; Limit pwm for low rpms
038E    C3            3214     	CLR	C
038F    E8            3215     MOV A , R0 
0390    9560          3216     	SUBB	A, PWM_LIMIT_LOW_RPM
0392    4002          3217     	JC	($+4)					; If current pwm below limit - branch
                      3218     
0394    A860          3219     MOV R0 , PWM_LIMIT_LOW_RPM 
                      3220     
                      3221     ENDIF
0396    8825          3222     MOV CURRENT_PWM_LIMITED , R0 
                      3223     ENDIF
                      3224     T2_INT_PWM_EXIT: 	
                      3225     	; Set demag enabled if pwm is above limit
0398    C3            3226     	CLR	C
0399    E525          3227     	MOV	A, CURRENT_PWM_LIMITED	
039B    9440          3228     	SUBB	A, #40H					; Set if above 25%
039D    4002          3229     	JC	($+4)
                      3230     
039F    D264          3231     SETB FLAGS0 . 4 
                      3232     
                      3233     T2_INT_EXIT: 	
                      3234     	; Check if high byte flag is set
03A1    20CF0C        3235     	JB	TF2H, T2H_INT		
03A4    D0E0          3236     	POP	ACC			; Restore preserved registers
03A6    D0D0          3237     	POP	PSW
03A8    C2D3          3238     	CLR	PSW.3		; Select register bank 0 for main program routines	
03AA    43E610        3239     	ORL	EIE1, #10H	; Enable PCA0 interrupts
03AD    D2AD          3240     	SETB	ET2			; Enable timer2 interrupts
03AF    32            3241     	RETI
                      3242     
                      3243     T2H_INT: 
                      3244     IF MCU_50MHZ == 1
                               	MOV	A, CLOCK_SET_AT_50MHZ
                               	JZ 	T2H_INT_START
                               
                               	; Check skip variable
                               	MOV	A, SKIP_T2H_INT
                               	JZ	T2H_INT_START				; Execute this interrupt
                               
                               	MOV	SKIP_T2H_INT, #0
                               	AJMP	T2H_INT_EXIT
                               
                               T2H_INT_START:
                               	MOV	SKIP_T2H_INT, #1			; Skip next interrupt
                               ENDIF
                      3258     	; High byte interrupt (happens every 32ms)
03B0    C2CF          3259     	CLR	TF2H					; Clear interrupt flag
03B2    7801          3260     MOV R0 , # 1 
                      3261     	; Check RC pulse timeout counter (used here for PPM only)
03B4    E529          3262     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03B6    6005          3263     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      3264     
                      3265     	; Decrement timeout counter (if PPM)
03B8    307402        3266     JNB FLAGS2 . 4 , T2H_INT_RCP_STOP_CHECK 
                      3267     
03BB    1529          3268     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      3269     
                      3270     T2H_INT_RCP_STOP_CHECK: 
                      3271     	; Check RC pulse against stop value
03BD    C3            3272     	CLR	C
03BE    E559          3273     	MOV	A, NEW_RCP				; Load new pulse value
03C0    9401          3274     SUBB A , # 1 
03C2    4005          3275     	JC	T2H_INT_RCP_STOP
                      3276     
                      3277     	; RC pulse higher than stop value, reset stop counter
03C4    755C00        3278     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
03C7    61DA          3279     	AJMP	T2H_INT_RCP_GOV_PWM
                      3280     
                      3281     T2H_INT_RCP_STOP: 	
                      3282     	; RC pulse less than stop value
03C9    755D00        3283     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
03CC    756400        3284     	MOV	SPOOLUP_LIMIT_CNT, #0
03CF    E55C          3285     	MOV	A, RCP_STOP_CNT			; Increment stop counter
03D1    2401          3286     	ADD	A, #1
03D3    F55C          3287     	MOV	RCP_STOP_CNT, A
03D5    5003          3288     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      3289     
03D7    755CFF        3290     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      3291     
                      3292     T2H_INT_RCP_GOV_PWM: 
                      3293     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_3X			; No spoolup until 3*N*32ms
                               
                               	JC	T2H_INT_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_10X			; Slow spoolup until "100"*N*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, MAIN_SPOOLUP_TIME_15X			; Faster spoolup until "150"*N*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, MAIN_SPOOLUP_TIME_3X	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_EXIT					; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      3422     T2H_INT_EXIT: 
03DA    D0E0          3423     	POP	ACC			; Restore preserved registers
03DC    D0D0          3424     	POP	PSW
03DE    C2D3          3425     	CLR	PSW.3		; Select register bank 0 for main program routines	
03E0    43E610        3426     	ORL	EIE1, #10H	; Enable PCA0 interrupts
03E3    D2AD          3427     	SETB	ET2			; Enable timer2 interrupts
03E5    32            3428     	RETI
                      3429     
                      3430     
                      3431     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3432     ;
                      3433     ; Timer3 interrupt routine
                      3434     ;
                      3435     ; No assumptions
                      3436     ;
                      3437     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3438     T3_INT: 	; Used for commutation timing
03E6    C0D0          3439     	PUSH	PSW				; Preserve registers through interrupt
03E8    C0E0          3440     	PUSH	ACC
03EA    C2AF          3441     	CLR 	EA				; Disable all interrupts
03EC    53917F        3442     	ANL	TMR3CN, #7FH		; Clear timer3 interrupt flag
03EF    53E67F        3443     	ANL	EIE1, #7FH		; Disable timer3 interrupts
03F2    C260          3444     CLR FLAGS0 . 0 
                      3445     IF MCU_50MHZ == 1
                               	CLR	C
                               	MOV	A, NEXT_WT_L
                               	RLC	A
                               	MOV	NEXT_WT_L, A
                               	MOV	A, NEXT_WT_H
                               	RLC	A
                               	MOV	NEXT_WT_H, A
                               ENDIF
                      3454     	; Set up next wait
03F4    759100        3455     	MOV	TMR3CN, #00H		; Timer3 disabled
03F7    C3            3456     	CLR	C
03F8    E4            3457     	CLR	A
03F9    9550          3458     	SUBB	A, NEXT_WT_L		; Set wait value
03FB    F594          3459     	MOV	TMR3L, A	
03FD    E4            3460     	CLR	A
03FE    9551          3461     	SUBB	A, NEXT_WT_H		
0400    F595          3462     	MOV	TMR3H, A
0402    759104        3463     	MOV	TMR3CN, #04H		; Timer3 enabled
0405    D0E0          3464     	POP	ACC				; Restore preserved registers
0407    D0D0          3465     	POP	PSW
0409    D2AF          3466     	SETB	EA				; Enable all interrupts
040B    32            3467     	RETI
                      3468     
                      3469     
                      3470     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3471     ;
                      3472     ; PCA interrupt routine
                      3473     ;
                      3474     ; No assumptions
                      3475     ;
                      3476     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3477     PCA_INT: 	; Used for RC pulse timing
040C    C2AF          3478     	CLR	EA
040E    53E6EF        3479     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
0411    C2AD          3480     	CLR	ET2			; Disable timer2 interrupts
0413    C0D0          3481     	PUSH	PSW			; Preserve registers through interrupt
0415    C0E0          3482     	PUSH	ACC
0417    C0F0          3483     	PUSH	B
0419    D2D3          3484     	SETB	PSW.3		; Select register bank 1 for interrupt routines
041B    D2AF          3485     	SETB	EA
                      3486     	; Get the PCA counter values
                      3487     	GET_RCP_CAPTURE_VALUES
041D    A8FB          3487+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
041F    A9FC          3487+1   MOV R1 , PCA0CPH0 
                      3488     	; Clear interrupt flag
                      3489     	RCP_CLEAR_INT_FLAG 				
0421    C2D8          3489+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3490     	; Check which edge it is
0423    307102        3491     JNB FLAGS2 . 1 , ( $+5 ) 
0426    8173          3492     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      3493     
                      3494     	RCP_INT_SECOND					; Yes - set second edge trig
0428    53DACF        3494+1   ANL PCA0CPM0 , # 0CFH 
042B    207E03        3494+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
042E    43DA10        3494+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
0431    307E03        3494+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0434    43DA20        3494+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0437    D271          3495     SETB FLAGS2 . 1 
                      3496     	; Read RC signal level
                      3497     	READ_RCP_INT			
0439    E580          3497+1   MOV A , P0 
043B    307E01        3497+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
043E    F4            3497+1   CPL A  ; YES - INVERT
                      3498     	; Test RC signal level
043F    20E402        3499     JB ACC . 4 , ( $+5 ) 
0442    814A          3500     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      3501     
                      3502     	; RC pulse was high, store RC pulse start timestamp
0444    8826          3503     MOV RCP_PREV_EDGE_L , R0 
0446    8927          3504     MOV RCP_PREV_EDGE_H , R1 
0448    C1AF          3505     	AJMP	PCA_INT_EXIT				; Exit
                      3506     
                      3507     PCA_INT_FAIL_MINIMUM: 
                      3508     	; Prepare for next interrupt
                      3509     	RCP_INT_FIRST					; Set interrupt trig to first again
044A    53DACF        3509+1   ANL PCA0CPM0 , # 0CFH 
044D    207E03        3509+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0450    43DA20        3509+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0453    307E03        3509+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0456    43DA10        3509+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3510     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0459    C2D8          3510+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
045B    C271          3511     CLR FLAGS2 . 1 
045D    307402        3512     JNB FLAGS2 . 4 , ( $+5 ) 
                      3513     
0460    C19B          3514     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      3515     
0462    7800          3516     MOV R0 , # 0 
                      3517     	READ_RCP_INT 					; Test RC signal level again
0464    E580          3517+1   MOV A , P0 
0466    307E01        3517+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0469    F4            3517+1   CPL A  ; YES - INVERT
046A    30E402        3518     JNB ACC . 4 , ( $+5 ) 
                      3519     
046D    C19B          3520     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      3521     
046F    8859          3522     MOV NEW_RCP , R0 
0471    C182          3523     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      3524     
                      3525     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      3526     	; Prepare for next interrupt
                      3527     	RCP_INT_FIRST 					; Set first edge trig
0473    53DACF        3527+1   ANL PCA0CPM0 , # 0CFH 
0476    207E03        3527+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0479    43DA20        3527+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
047C    307E03        3527+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
047F    43DA10        3527+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
0482    C271          3528     CLR FLAGS2 . 1 
                      3529     	; Check if pwm frequency shall be measured
0484    206102        3530     JB FLAGS0 . 1 , ( $+5 ) 
0487    A143          3531     	AJMP	PCA_INT_FALL				; No - skip measurements
                      3532     
                      3533     	; Set second edge trig only during pwm frequency measurement
                      3534     	RCP_INT_SECOND 				; Set second edge trig
0489    53DACF        3534+1   ANL PCA0CPM0 , # 0CFH 
048C    207E03        3534+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
048F    43DA10        3534+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
0492    307E03        3534+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0495    43DA20        3534+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      3535     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0498    C2D8          3535+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
049A    D271          3536     SETB FLAGS2 . 1 
                      3537     	; Store edge data to RAM
049C    8854          3538     MOV RCP_EDGE_L , R0 
049E    8955          3539     MOV RCP_EDGE_H , R1 
                      3540     	; Calculate pwm frequency
04A0    C3            3541     	CLR	C
04A1    E8            3542     MOV A , R0 
04A2    9552          3543     	SUBB	A, RCP_PREPREV_EDGE_L	
04A4    F8            3544     MOV R0 , A 
04A5    E9            3545     MOV A , R1 
04A6    9553          3546     	SUBB	A, RCP_PREPREV_EDGE_H
04A8    F9            3547     MOV R1 , A 
04A9    E4            3548     	CLR	A
04AA    FB            3549     MOV R3 , A 
04AB    7E02          3550     MOV R6 , # 2 
04AD    7A00          3551     MOV R2 , # 0 
                      3552     	; Check if pulse is too short
04AF    C3            3553     	CLR	C
04B0    E8            3554     MOV A , R0 
04B1    948C          3555     	SUBB	A, #LOW(140)				; If pulse below 70us, not accepted
04B3    E9            3556     MOV A , R1 
04B4    9400          3557     	SUBB	A, #HIGH(140)
04B6    5005          3558     	JNC	RCP_INT_CHECK_12KHZ
                      3559     
04B8    755800        3560     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0	; Set not accepted 
04BB    A133          3561     	AJMP	PCA_INT_STORE_DATA
                      3562     
                      3563     RCP_INT_CHECK_12KHZ: 
                      3564     	; Check if pwm frequency is 12kHz
04BD    C3            3565     	CLR	C
04BE    E8            3566     MOV A , R0 
04BF    94C8          3567     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
04C1    E9            3568     MOV A , R1 
04C2    9400          3569     	SUBB	A, #HIGH(200)
04C4    5008          3570     	JNC	PCA_INT_CHECK_8KHZ
                      3571     
04C6    E4            3572     	CLR	A
04C7    D2E4          3573     SETB ACC . 4 
04C9    FB            3574     MOV R3 , A 
04CA    7A0A          3575     MOV R2 , # 10 
04CC    A110          3576     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3577     
                      3578     PCA_INT_CHECK_8KHZ: 
                      3579     	; Check if pwm frequency is 8kHz
04CE    C3            3580     	CLR	C
04CF    E8            3581     MOV A , R0 
04D0    9468          3582     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
04D2    E9            3583     MOV A , R1 
04D3    9401          3584     	SUBB	A, #HIGH(360)
04D5    5008          3585     	JNC	PCA_INT_CHECK_4KHZ
                      3586     
04D7    E4            3587     	CLR	A
04D8    D2E3          3588     SETB ACC . 3 
04DA    FB            3589     MOV R3 , A 
04DB    7A0F          3590     MOV R2 , # 15 
04DD    A110          3591     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3592     
                      3593     PCA_INT_CHECK_4KHZ: 
                      3594     	; Check if pwm frequency is 4kHz
04DF    C3            3595     	CLR	C
04E0    E8            3596     MOV A , R0 
04E1    94D0          3597     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
04E3    E9            3598     MOV A , R1 
04E4    9402          3599     	SUBB	A, #HIGH(720)
04E6    5008          3600     	JNC	PCA_INT_CHECK_2KHZ
                      3601     
04E8    E4            3602     	CLR	A
04E9    D2E2          3603     SETB ACC . 2 
04EB    FB            3604     MOV R3 , A 
04EC    7A1E          3605     MOV R2 , # 30 
04EE    A110          3606     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3607     
                      3608     PCA_INT_CHECK_2KHZ: 
                      3609     	; Check if pwm frequency is 2kHz
04F0    C3            3610     	CLR	C
04F1    E8            3611     MOV A , R0 
04F2    94A0          3612     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
04F4    E9            3613     MOV A , R1 
04F5    9405          3614     	SUBB	A, #HIGH(1440)
04F7    5008          3615     	JNC	PCA_INT_CHECK_1KHZ
                      3616     
04F9    E4            3617     	CLR	A
04FA    D2E1          3618     SETB ACC . 1 
04FC    FB            3619     MOV R3 , A 
04FD    7A3C          3620     MOV R2 , # 60 
04FF    A110          3621     	AJMP	PCA_INT_RESTORE_EDGE_SET_MSB
                      3622     
                      3623     PCA_INT_CHECK_1KHZ: 
                      3624     	; Check if pwm frequency is 1kHz
0501    C3            3625     	CLR	C
0502    E8            3626     MOV A , R0 
0503    9498          3627     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0505    E9            3628     MOV A , R1 
0506    9408          3629     	SUBB	A, #HIGH(2200)
0508    5008          3630     	JNC	PCA_INT_RESTORE_EDGE
                      3631     
050A    E4            3632     	CLR	A
050B    D2E0          3633     SETB ACC . 0 
050D    FB            3634     MOV R3 , A 
050E    7A78          3635     MOV R2 , # 120 
                      3636     
                      3637     PCA_INT_RESTORE_EDGE_SET_MSB: 
0510    7E00          3638     MOV R6 , # 0 
                      3639     PCA_INT_RESTORE_EDGE: 
                      3640     	; Calculate difference between this period and previous period
0512    C3            3641     	CLR	C
0513    E8            3642     MOV A , R0 
0514    9556          3643     	SUBB	A, RCP_PREV_PERIOD_L
0516    FC            3644     MOV R4 , A 
0517    E9            3645     MOV A , R1 
0518    9557          3646     	SUBB	A, RCP_PREV_PERIOD_H
051A    FD            3647     MOV R5 , A 
                      3648     	; Make positive
051B    30E708        3649     	JNB	ACC.7, PCA_INT_CHECK_DIFF
051E    EC            3650     MOV A , R4 
051F    F4            3651     	CPL	A
0520    2401          3652     	ADD	A, #1
0522    FC            3653     MOV R4 , A 
0523    ED            3654     MOV A , R5 
0524    F4            3655     	CPL	A
0525    FD            3656     MOV R5 , A 
                      3657     
                      3658     PCA_INT_CHECK_DIFF: 
                      3659     	; Check difference
0526    755800        3660     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0529    C3            3661     	CLR	C
052A    EC            3662     MOV A , R4 
052B    9A            3663     SUBB A , R2 
052C    ED            3664     MOV A , R5 
052D    9E            3665     SUBB A , R6 
052E    5003          3666     	JNC	PCA_INT_STORE_DATA
                      3667     
0530    755801        3668     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      3669     
                      3670     PCA_INT_STORE_DATA: 
                      3671     	; Store previous period
0533    8856          3672     MOV RCP_PREV_PERIOD_L , R0 
0535    8957          3673     MOV RCP_PREV_PERIOD_H , R1 
                      3674     	; Restore edge data from RAM
0537    A854          3675     MOV R0 , RCP_EDGE_L 
0539    A955          3676     MOV R1 , RCP_EDGE_H 
                      3677     	; Store pre previous edge
053B    8852          3678     MOV RCP_PREPREV_EDGE_L , R0 
053D    8953          3679     MOV RCP_PREPREV_EDGE_H , R1 
053F    7802          3680     MOV R0 , # 2 
0541    C182          3681     	AJMP	PCA_INT_LIMITED
                      3682     
                      3683     PCA_INT_FALL: 
                      3684     	; RC pulse edge was second, calculate new pulse length
0543    C3            3685     	CLR	C
0544    E8            3686     MOV A , R0 
0545    9526          3687     	SUBB	A, RCP_PREV_EDGE_L	
0547    F8            3688     MOV R0 , A 
0548    E9            3689     MOV A , R1 
0549    9527          3690     	SUBB	A, RCP_PREV_EDGE_H
054B    F9            3691     MOV R1 , A 
054C    307C02        3692     JNB FLAGS3 . 4 , ( $+5 ) 
054F    C166          3693     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3694     
0551    307B02        3695     JNB FLAGS3 . 3 , ( $+5 ) 
0554    C166          3696     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3697     
0556    307A02        3698     JNB FLAGS3 . 2 , ( $+5 ) 
0559    C15F          3699     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3700     
055B    207502        3701     JB FLAGS2 . 5 , ( $+5 ) 
055E    A166          3702     	AJMP	RCP_INT_FALL_NOT_ONESHOT
                      3703     
0560    E9            3704     MOV A , R1 
0561    FD            3705     MOV R5 , A 
0562    E8            3706     MOV A , R0 
0563    FC            3707     MOV R4 , A 
0564    A185          3708     	AJMP	RCP_INT_FALL_CHECK_RANGE
                      3709     
                      3710     RCP_INT_FALL_NOT_ONESHOT: 
0566    E9            3711     MOV A , R1 
0567    C3            3712     	CLR	C
0568    13            3713     	RRC	A
0569    F9            3714     MOV R1 , A 
056A    E8            3715     MOV A , R0 
056B    13            3716     	RRC	A
056C    F8            3717     MOV R0 , A 
                      3718     
056D    307902        3719     JNB FLAGS3 . 1 , ( $+5 ) 
0570    C15F          3720     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3721     
0572    E9            3722     MOV A , R1 
0573    C3            3723     	CLR	C
0574    13            3724     	RRC	A
0575    F9            3725     MOV R1 , A 
0576    E8            3726     MOV A , R0 
0577    13            3727     	RRC	A
0578    F8            3728     MOV R0 , A 
                      3729     
0579    307802        3730     JNB FLAGS3 . 0 , ( $+5 ) 
057C    C15F          3731     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3732     
057E    E9            3733     MOV A , R1 
057F    C3            3734     	CLR	C
0580    13            3735     	RRC	A
0581    FD            3736     MOV R5 , A 
0582    E8            3737     MOV A , R0 
0583    13            3738     	RRC	A
0584    FC            3739     MOV R4 , A 
                      3740     RCP_INT_FALL_CHECK_RANGE: 
                      3741     	; Skip range limitation if pwm frequency measurement
0585    206126        3742     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      3743     
                      3744     	; Check if 2160us or above (in order to ignore false pulses)
0588    C3            3745     	CLR	C
0589    EC            3746     MOV A , R4 
058A    941C          3747     	SUBB	A, #28
058C    ED            3748     MOV A , R5 
058D    9402          3749     	SUBB A, #2
058F    4002          3750     	JC	($+4)						; No - proceed
                      3751     
0591    A19C          3752     	AJMP	PCA_INT_PPM_OUTSIDE_RANGE		; Yes - ignore pulse
                      3753     
                      3754     PCA_INT_PPM_BELOW_FULL_RANGE: 
                      3755     	; Check if below 800us (in order to ignore false pulses)
0593    ED            3756     MOV A , R5 
0594    7018          3757     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      3758     
0596    C3            3759     	CLR	C
0597    EC            3760     MOV A , R4 
0598    94C8          3761     	SUBB	A, #200
059A    5012          3762     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      3763     
                      3764     PCA_INT_PPM_OUTSIDE_RANGE: 
059C    0528          3765     	INC	RCP_OUTSIDE_RANGE_CNT
059E    C3            3766     	CLR	C
059F    E528          3767     	MOV	A, RCP_OUTSIDE_RANGE_CNT
05A1    940A          3768     	SUBB	A, #10						; Allow a given number of outside pulses
05A3    5002          3769     	JNC	($+4)			
05A5    C19B          3770     	AJMP	PCA_INT_SET_TIMEOUT				; If below limit - ignore pulse
                      3771     
05A7    755900        3772     	MOV	NEW_RCP, #0					; Set pulse length to zero
05AA    D270          3773     SETB FLAGS2 . 0 
05AC    C19B          3774     	AJMP	PCA_INT_SET_TIMEOUT			
                      3775     
                      3776     PCA_INT_PPM_CHECK_FULL_RANGE: 
05AE    E528          3777     	MOV	A, RCP_OUTSIDE_RANGE_CNT
05B0    6002          3778     	JZ	($+4)
                      3779     
05B2    1528          3780     	DEC	RCP_OUTSIDE_RANGE_CNT
                      3781     
                      3782     	; Calculate "1000us" plus throttle minimum
05B4    7400          3783     	MOV	A, #0						; Set 1000us as default minimum
05B6    207F0B        3784     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      3785     
                      3786     IF MODE >= 1	; Tail or multi
05B9    7888          3787     MOV R0 , # PGM_DIRECTION 
05BB    E6            3788     MOV A , @ R0 
                      3789     ENDIF
05BC    7896          3790     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      3791     IF MODE >= 1	; Tail or multi
05BE    B40302        3792     	CJNE	A, #3, ($+5)
                      3793     
05C1    789E          3794     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      3795     ENDIF
05C3    E6            3796     MOV A , @ R0 
                      3797     
                      3798     PCA_INT_PPM_CALCULATE: 
05C4    24FA          3799     	ADD	A, #250						; Add 1000us to minimum
05C6    FE            3800     MOV R6 , A 
05C7    E4            3801     	CLR	A
05C8    3400          3802     	ADDC	A, #0
05CA    FF            3803     MOV R7 , A 
                      3804     
05CB    C3            3805     	CLR	C
05CC    EC            3806     MOV A , R4 
05CD    9E            3807     SUBB A , R6 
05CE    FC            3808     MOV R4 , A 
05CF    ED            3809     MOV A , R5 
05D0    9F            3810     SUBB A , R7 
05D1    FD            3811     MOV R5 , A 
                      3812     IF MODE >= 1	; Tail or multi
05D2    9208          3813     	MOV	BIT_ACCESS_INT.0, C
05D4    7888          3814     MOV R0 , # PGM_DIRECTION 
05D6    E6            3815     MOV A , @ R0 
05D7    B40327        3816     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      3817     
05DA    A208          3818     	MOV	C, BIT_ACCESS_INT.0
05DC    5009          3819     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      3820     
                      3821     PCA_INT_PPM_BIDIR_REV: 
05DE    207D20        3822     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      3823     
05E1    C2AF          3824     	CLR	EA							; Direction change, turn off all fets
05E3    D27D          3825     SETB FLAGS3 . 5 
05E5    A1EE          3826     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      3827     
                      3828     PCA_INT_PPM_BIDIR_FWD: 
05E7    307D17        3829     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      3830     
05EA    C2AF          3831     	CLR	EA							; Direction change, turn off all fets
05EC    C27D          3832     CLR FLAGS3 . 5 
                      3833     
                      3834     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      3835     	ALL_NFETS_OFF
05EE    D291          3835+1   SETB P1 . 1 
05F0    D293          3835+1   SETB P1 . 3 
05F2    D295          3835+1   SETB P1 . 5 
                      3836     	ALL_PFETS_OFF
05F4    C290          3836+1   CLR P1 . 0 
05F6    C292          3836+1   CLR P1 . 2 
05F8    C294          3836+1   CLR P1 . 4 
05FA    206902        3837     JB FLAGS1 . 1 , ( $+5 ) 
                      3838     
05FD    D26B          3839     SETB FLAGS1 . 3 
                      3840     
05FF    D2AF          3841     	SETB	EA
                      3842     PCA_INT_PPM_BIDIR_DIR_SET: 
0601    A208          3843     	MOV	C, BIT_ACCESS_INT.0
                      3844     ENDIF
0603    5017          3845     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      3846     
                      3847     IF MODE >= 1	; Tail or multi
0605    E6            3848     MOV A , @ R0 
0606    B4030D        3849     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      3850     
0609    EC            3851     MOV A , R4 
060A    F4            3852     	CPL	A
060B    2401          3853     	ADD	A, #1
060D    FC            3854     MOV R4 , A 
060E    ED            3855     MOV A , R5 
060F    F4            3856     	CPL	A
0610    3400          3857     	ADDC	A, #0
0612    FD            3858     MOV R5 , A 
0613    02061C        3859     	JMP	PCA_INT_PPM_NEG_CHECKED
                      3860     
                      3861     PCA_INT_PPM_UNIDIR_NEG: 
                      3862     ENDIF
0616    7800          3863     MOV R0 , # 0 
0618    7900          3864     MOV R1 , # 0 
061A    C166          3865     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      3866     
                      3867     PCA_INT_PPM_NEG_CHECKED: 
                      3868     IF MODE >= 1	; Tail or multi
061C    7888          3869     MOV R0 , # PGM_DIRECTION 
061E    E6            3870     MOV A , @ R0 
061F    B40315        3871     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      3872     
0622    EC            3873     MOV A , R4 
0623    33            3874     	RLC	A
0624    FC            3875     MOV R4 A 
0625    ED            3876     MOV A , R5 
0626    33            3877     	RLC	A
0627    FD            3878     MOV R5 A 
0628    C3            3879     	CLR	C							; Subtract deadband
0629    EC            3880     MOV A , R4 
062A    940A          3881     	SUBB	A, #10		
062C    FC            3882     MOV R4 , A 
062D    ED            3883     MOV A , R5 
062E    9400          3884     	SUBB	A, #0
0630    FD            3885     MOV R5 , A 
0631    5004          3886     	JNC	PCA_INT_PPM_BIDIR_DONE
                      3887     
0633    7C00          3888     MOV R4 , # 0 
0635    7D00          3889     MOV R5 , # 0 
                      3890     
                      3891     PCA_INT_PPM_BIDIR_DONE: 
                      3892     ENDIF
0637    C3            3893     	CLR	C							; Check that RC pulse is within legal range (max 255)
0638    EC            3894     MOV A , R4 
0639    94FF          3895     SUBB A , # 255 
063B    ED            3896     MOV A , R5 
063C    9400          3897     	SUBB	A, #0
063E    4006          3898     	JC	PCA_INT_PPM_MAX_CHECKED
                      3899     
0640    78FF          3900     MOV R0 , # 255 
0642    7900          3901     MOV R1 , # 0 
0644    C166          3902     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      3903     
                      3904     PCA_INT_PPM_MAX_CHECKED: 
0646    EC            3905     MOV A , R4 
0647    856FF0        3906     	MOV	B, PPM_THROTTLE_GAIN
064A    A4            3907     	MUL	AB
064B    C5F0          3908     	XCH	A, B
064D    A2F7          3909     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
064F    33            3910     	RLC	A
0650    F8            3911     MOV R0 , A 
0651    7900          3912     MOV R1 , # 0 
0653    4003          3913     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      3914     	
0655    020682        3915     	JMP	PCA_INT_LIMITED			
                      3916     
                      3917     PCA_INT_PPM_LIMIT_AFTER_MULT: 
0658    78FF          3918     MOV R0 , # 255 
065A    7900          3919     MOV R1 , # 0 
065C    020682        3920     	JMP	PCA_INT_LIMITED			
                      3921     
                      3922     PCA_INT_PWM_DIVIDE: 
065F    E9            3923     MOV A , R1 
0660    C3            3924     	CLR	C
0661    13            3925     	RRC	A
0662    F9            3926     MOV R1 , A 
0663    E8            3927     MOV A , R0 
0664    13            3928     	RRC	A
0665    F8            3929     MOV R0 , A 
                      3930     
                      3931     PCA_INT_PWM_DIVIDE_DONE: 
0666    307C0E        3932     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
0669    E9            3933     MOV A , R1 
066A    6002          3934     	JZ	($+4)
                      3935     
066C    78FF          3936     MOV R0 , # 255 
                      3937     
066E    C3            3938     	CLR	C
066F    E8            3939     MOV A , R0 
0670    13            3940     	RRC	A
0671    38            3941     ADDC A , R0 
0672    F8            3942     MOV R0 , A 
0673    E4            3943     	CLR	A
0674    3400          3944     	ADDC	A, #0
0676    F9            3945     MOV R1 , A 
                      3946     
                      3947     PCA_INT_CHECK_LEGAL_RANGE: 
                      3948     	; Check that RC pulse is within legal range
0677    C3            3949     	CLR	C
0678    E8            3950     MOV A , R0 
0679    94FF          3951     SUBB A , # 255 
067B    E9            3952     MOV A , R1 
067C    9400          3953     	SUBB	A, #0
067E    4002          3954     	JC	PCA_INT_LIMITED
                      3955     
0680    78FF          3956     MOV R0 , # 255 
                      3957     
                      3958     PCA_INT_LIMITED: 
                      3959     	; RC pulse value accepted
0682    8859          3960     MOV NEW_RCP , R0 
0684    D270          3961     SETB FLAGS2 . 0 
0686    206102        3962     JB FLAGS0 . 1 , ( $+5 ) 
                      3963     
0689    C19B          3964     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      3965     
068B    741F          3966     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
068D    F4            3967     	CPL	A
068E    552F          3968     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0690    4B            3969     ORL A , R3 
0691    F52F          3970     	MOV	FLAGS3, A
0693    C274          3971     CLR FLAGS2 . 4 
0695    E4            3972     	CLR	A
0696    2B            3973     ADD A , R3 
0697    7002          3974     	JNZ	PCA_INT_SET_TIMEOUT
                      3975     
0699    D274          3976     SETB FLAGS2 . 4 
                      3977     
                      3978     PCA_INT_SET_TIMEOUT: 
069B    752918        3979     MOV RCP_TIMEOUT_CNT , # 24 
069E    307403        3980     JNB FLAGS2 . 4 , PCA_INT_PPM_TIMEOUT_SET 
                      3981     
06A1    75290A        3982     MOV RCP_TIMEOUT_CNT , # 10 
                      3983     
                      3984     PCA_INT_PPM_TIMEOUT_SET: 
06A4    306102        3985     JNB FLAGS0 . 1 , ( $+5 ) 
                      3986     
06A7    C1AF          3987     	AJMP PCA_INT_EXIT				; Yes - exit
                      3988     
06A9    207403        3989     JB FLAGS2 . 4 , PCA_INT_EXIT 
                      3990     
                      3991     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
06AC    53DAFE        3991+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      3992     
                      3993     PCA_INT_EXIT: 	; Exit interrupt routine	
06AF    752A06        3994     MOV RCP_SKIP_CNT , # 6 
06B2    307403        3995     JNB FLAGS2 . 4 , ( $+6 ) 
                      3996     
06B5    752A0A        3997     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      3998     
06B8    D0F0          3999     	POP	B			; Restore preserved registers
06BA    D0E0          4000     	POP	ACC			
06BC    D0D0          4001     	POP	PSW
06BE    C2D3          4002     	CLR	PSW.3		; Select register bank 0 for main program routines	
06C0    D2AD          4003     	SETB	ET2			; Enable timer2 interrupts
06C2    43E610        4004     	ORL	EIE1, #10H	; Enable PCA0 interrupts
06C5    32            4005     	RETI
                      4006     
                      4007     
                      4008     
                      4009     
                      4010     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4011     ;
                      4012     ; Wait xms ~(x*4*250)  (Different entry points)	
                      4013     ;
                      4014     ; No assumptions
                      4015     ;
                      4016     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4017     WAIT1MS: 	
06C6    7901          4018     MOV R1 , # 1 
06C8    0206E4        4019     	JMP	WAITXMS_O
                      4020     
                      4021     WAIT3MS: 	
06CB    7903          4022     MOV R1 , # 3 
06CD    0206E4        4023     	JMP	WAITXMS_O
                      4024     
                      4025     WAIT10MS: 	
06D0    790A          4026     MOV R1 , # 10 
06D2    0206E4        4027     	JMP	WAITXMS_O
                      4028     
                      4029     WAIT30MS: 	
06D5    791E          4030     MOV R1 , # 30 
06D7    0206E4        4031     	JMP	WAITXMS_O
                      4032     
                      4033     WAIT100MS: 	
06DA    7964          4034     MOV R1 , # 100 
06DC    0206E4        4035     	JMP	WAITXMS_O
                      4036     
                      4037     WAIT200MS: 	
06DF    79C8          4038     MOV R1 , # 200 
06E1    0206E4        4039     	JMP	WAITXMS_O
                      4040     
                      4041     WAITXMS_O: 	; Outer loop
06E4    7817          4042     MOV R0 , # 23 
                      4043     WAITXMS_M: 	; Middle loop
06E6    E4            4044     	CLR	A
06E7    D5E0FD        4045      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
06EA    D8FA          4046     DJNZ R0 , WAITXMS_M 
06EC    D9F6          4047     DJNZ R1 , WAITXMS_O 
06EE    22            4048     	RET
                      4049     
                      4050     
                      4051     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4052     ;
                      4053     ; Beeper routines (4 different entry points) 
                      4054     ;
                      4055     ; No assumptions
                      4056     ;
                      4057     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4058     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
06EF    7A14          4059     MOV R2 , # 20 
06F1    7B78          4060     MOV R3 , # 120 
06F3    02070B        4061     	JMP	BEEP
                      4062     
                      4063     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
06F6    7A10          4064     MOV R2 , # 16 
06F8    7B8C          4065     MOV R3 , # 140 
06FA    02070B        4066     	JMP	BEEP
                      4067     
                      4068     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
06FD    7A0D          4069     MOV R2 , # 13 
06FF    7BB4          4070     MOV R3 , # 180 
0701    02070B        4071     	JMP	BEEP
                      4072     
                      4073     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0704    7A0B          4074     MOV R2 , # 11 
0706    7BC8          4075     MOV R3 , # 200 
0708    02070B        4076     	JMP	BEEP
                      4077     
                      4078     BEEP: 	; Beep loop start
070B    AC25          4079     MOV R4 , CURRENT_PWM_LIMITED 
070D    752501        4080     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
0710    7902          4081     MOV R1 , # 2 
                      4082     BEEP_ONOFF: 
0712    B27D          4083     CPL FLAGS3 . 5 
0714    E4            4084     	CLR	A
                      4085     	BPFET_OFF			; BpFET off
0715    C292          4085+1   CLR P1 . 2 
0717    D5E0FD        4086     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      4087     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
071A    E525          4087+1   MOV A , CURRENT_PWM_LIMITED 
071C    6002          4087+1   JZ ( $+4 ) 
071E    C293          4087+1   CLR P1 . 3 
0720    D5E0FD        4088     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      4089     	BNFET_OFF			; BnFET off again
0723    D293          4089+1   SETB P1 . 3 
0725    D5E0FD        4090     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      4091     	BPFET_ON			; BpFET on
0728    D292          4091+1   SETB P1 . 2 
072A    D5E0FD        4092     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      4093     	; Turn on nfet
                      4094     	ANFET_ON			; AnFET on
072D    E525          4094+1   MOV A , CURRENT_PWM_LIMITED 
072F    600A          4094+1   JZ ( $+12 ) 
0731    207D02        4094+1   JB FLAGS3 . 5 , ( $+5 ) 
0734    C291          4094+1   CLR P1 . 1 
0736    307D02        4094+1   JNB FLAGS3 . 5 , ( $+5 ) 
0739    C295          4094+1   CLR P1 . 5 
073B    E570          4095     	MOV	A, BEEP_STRENGTH
073D    D5E0FD        4096     	DJNZ	ACC, $		
                      4097     	; Turn off nfet
                      4098     	ANFET_OFF			; AnFET off
0740    207D02        4098+1   JB FLAGS3 . 5 , ( $+5 ) 
0743    D291          4098+1   SETB P1 . 1 
0745    307D02        4098+1   JNB FLAGS3 . 5 , ( $+5 ) 
0748    D295          4098+1   SETB P1 . 5 
074A    7496          4099     	MOV	A, #150		; 25s off
074C    D5E0FD        4100     	DJNZ	ACC, $		
074F    D9C1          4101     DJNZ R1 , BEEP_ONOFF 
                      4102     	; Copy variable
0751    EA            4103     MOV A , R2 
0752    F8            4104     MOV R0 , A 
                      4105     BEEP_OFF: 		; Fets off loop
0753    D5E0FD        4106     	DJNZ	ACC, $
0756    D8FB          4107     DJNZ R0 , BEEP_OFF 
0758    DBB1          4108     DJNZ R3 , BEEP 
                      4109     	BPFET_OFF			; BpFET off
075A    C292          4109+1   CLR P1 . 2 
075C    8C25          4110     MOV CURRENT_PWM_LIMITED , R4 
075E    22            4111     	RET
                      4112     
                      4113     
                      4114     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4115     ;
                      4116     ; Division 16bit unsigned by 16bit unsigned
                      4117     ;
                      4118     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      4119     ; Result will be in Temp2/Temp1
                      4120     ;
                      4121     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4122     DIV_U16_BY_U16: 	
075F    C3            4123     	CLR	C       
0760    7C00          4124     MOV R4 , # 0 
0762    7D00          4125     MOV R5 , # 0 
0764    75F000        4126     	MOV	B, #0
                      4127     DIV_U16_BY_U16_DIV1: 
0767    05F0          4128     	INC	B      			; Increment counter for each left shift
0769    EA            4129     MOV A , R2 
076A    33            4130     	RLC	A      		
076B    FA            4131     MOV R2 , A 
076C    EB            4132     MOV A , R3 
076D    33            4133     	RLC	A      	  	
076E    FB            4134     MOV R3 , A 
076F    50F6          4135     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      4136     DIV_U16_BY_U16_DIV2:         
0771    EB            4137     MOV A , R3 
0772    13            4138     	RRC	A      
0773    FB            4139     MOV R3 , A 
0774    EA            4140     MOV A , R2 
0775    13            4141     	RRC	A      
0776    FA            4142     MOV R2 , A 
0777    C3            4143     	CLR	C      
0778    E9            4144     MOV A , R1 
0779    FF            4145     MOV R7 , A 
077A    E8            4146     MOV A , R0 
077B    FE            4147     MOV R6 , A 
077C    E8            4148     MOV A , R0 
077D    9A            4149     SUBB A , R2 
077E    F8            4150     MOV R0 , A 
077F    E9            4151     MOV A , R1 
0780    9B            4152     SUBB A , R3 
0781    F9            4153     MOV R1 , A 
0782    5004          4154     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0784    EF            4155     MOV A , R7 
0785    F9            4156     MOV R1 , A 
0786    EE            4157     MOV A , R6 
0787    F8            4158     MOV R0 , A 
                      4159     DIV_U16_BY_U16_DIV3: 
0788    B3            4160     	CPL	C      			; Invert carry, so it can be directly copied into result
0789    EC            4161     MOV A , R4 
078A    33            4162     	RLC	A      			; Shift carry flag into temporary result
078B    FC            4163     MOV R4 , A 
078C    ED            4164     MOV A , R5 
078D    33            4165     	RLC	A
078E    FD            4166     MOV R5 , A 
078F    D5F0DF        4167     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
0792    ED            4168     MOV A , R5 
0793    F9            4169     MOV R1 , A 
0794    EC            4170     MOV A , R4 
0795    F8            4171     MOV R0 , A 
0796    22            4172     	RET
                      4173     
                      4174     
                      4175     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4176     ;
                      4177     ; Multiplication 16bit signed by 8bit unsigned
                      4178     ;
                      4179     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      4180     ; Result will be in Temp2/Temp1. Result will divided by 16
                      4181     ;
                      4182     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4183     MULT_S16_BY_U8_DIV_16: 
0797    E8            4184     MOV A , R0 
0798    89F0          4185     MOV B , R1 
079A    8A20          4186     MOV BIT_ACCESS , R2 
079C    D2D4          4187     	SETB	PSW.4		; Select register bank 2 for math routines
079E    F8            4188     MOV R0 , A 
079F    A9F0          4189     MOV R1 , B 
07A1    7B00          4190     MOV R3 , # 0 
07A3    30F70B        4191     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      4192     
07A6    7BFF          4193     MOV R3 , # 0FFH 
07A8    F4            4194     	CPL	A
07A9    2401          4195     	ADD	A, #1
07AB    F8            4196     MOV R0 , A 
07AC    E9            4197     MOV A , R1 
07AD    F4            4198     	CPL	A
07AE    3400          4199     	ADDC	A, #0
07B0    F9            4200     MOV R1 , A 
                      4201     MULT_S16_BY_U8_POSITIVE: 
07B1    E8            4202     MOV A , R0 
07B2    8520F0        4203     	MOV	B, BIT_ACCESS
07B5    A4            4204     	MUL	AB
07B6    ADF0          4205     MOV R5 , B 
07B8    F8            4206     MOV R0 , A 
07B9    E9            4207     MOV A , R1 
07BA    8520F0        4208     	MOV	B, BIT_ACCESS
07BD    A4            4209     	MUL	AB
07BE    AFF0          4210     MOV R7 , B 
07C0    FE            4211     MOV R6 , A 
07C1    ED            4212     MOV A , R5 
07C2    2E            4213     ADD A , R6 
07C3    F9            4214     MOV R1 , A 
07C4    7400          4215     	MOV	A, #0
07C6    3F            4216     ADDC A , R7 
07C7    FA            4217     MOV R2 , A 
07C8    7C04          4218     MOV R4 , # 4 
                      4219     MULT_S16_BY_U8_DIV_LOOP: 
07CA    C3            4220     	CLR	C			; Rotate right 
07CB    EA            4221     MOV A , R2 
07CC    13            4222     	RRC	A
07CD    FA            4223     MOV R2 , A 
07CE    E9            4224     MOV A , R1 
07CF    13            4225     	RRC	A
07D0    F9            4226     MOV R1 , A 
07D1    E8            4227     MOV A , R0 
07D2    13            4228     	RRC	A
07D3    F8            4229     MOV R0 , A 
07D4    DCF4          4230     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      4231     
07D6    8BF0          4232     MOV B , R3 
07D8    30F70A        4233     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      4234     
07DB    E8            4235     MOV A , R0 
07DC    F4            4236     	CPL	A
07DD    2401          4237     	ADD	A, #1
07DF    F8            4238     MOV R0 , A 
07E0    E9            4239     MOV A , R1 
07E1    F4            4240     	CPL	A
07E2    3400          4241     	ADDC	A, #0
07E4    F9            4242     MOV R1 , A 
                      4243     
                      4244     MULT_S16_BY_U8_EXIT: 
07E5    E8            4245     MOV A , R0 
07E6    89F0          4246     MOV B , R1 
07E8    C2D4          4247     	CLR	PSW.4		; Select normal register bank
07EA    F8            4248     MOV R0 , A 
07EB    A9F0          4249     MOV R1 , B 
07ED    22            4250     	RET
                      4251     
                      4252     
                      4253     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4254     ;
                      4255     ; Calculate governor routines
                      4256     ;
                      4257     ; No assumptions
                      4258     ;
                      4259     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      4260     ; The governor task is split into several routines in order to distribute processing time
                      4261     ;
                      4262     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4263     ; First governor routine - calculate governor target
                      4264     IF MODE == 0	; Main
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      4404     IF MODE == 1	; Tail
                               CALC_GOVERNOR_TARGET:
                               	RET						
                               ENDIF
                      4408     IF MODE == 2	; Multi
                      4409     CALC_GOVERNOR_TARGET: 
07EE    7882          4410     MOV R0 , # PGM_GOV_MODE 
07F0    B60403        4411     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
07F3    02084B        4412     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      4413     
                      4414     GOVERNOR_TARGET_CALC: 
                      4415     	; Stop governor for stop RC pulse	
07F6    C3            4416     	CLR	C
07F7    E559          4417     	MOV	A, NEW_RCP				; Check RC pulse against stop value
07F9    9401          4418     SUBB A , # 1 
07FB    4003          4419     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      4420     
07FD    020813        4421     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      4422     
                      4423     GOVERNOR_DEACTIVATE: 
0800    852224        4424     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0803    E4            4425     	CLR	A
0804    F53E          4426     	MOV	GOV_TARGET_L, A			; Set target to zero
0806    F53F          4427     	MOV	GOV_TARGET_H, A
0808    F540          4428     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
080A    F541          4429     	MOV	GOV_INTEGRAL_H, A
080C    F542          4430     	MOV	GOV_INTEGRAL_X, A
080E    F547          4431     	MOV	GOV_ACTIVE, A
0810    02084B        4432     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      4433     
                      4434     GOVERNOR_ACTIVATE: 
0813    7882          4435     MOV R0 , # PGM_GOV_MODE 
0815    E6            4436     MOV A , @ R0 
0816    FC            4437     MOV R4 , A 
0817    754701        4438     	MOV	GOV_ACTIVE, #1
081A    E522          4439     	MOV	A, REQUESTED_PWM			; Load requested pwm
081C    F523          4440     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      4441     	; Calculate comm period target 2*(51000/Requested_Pwm)
081E    7838          4442     MOV R0 , # 38H 
0820    79C7          4443     MOV R1 , # 0C7H 
0822    AA3A          4444     MOV R2 , COMM_PERIOD4X_L 
0824    AB3B          4445     MOV R3 , COMM_PERIOD4X_H 
                      4446     	; Set speed range. Bare Comm_Period4x corresponds to 400k eRPM, because it is 500n units
0826    C3            4447     	CLR	C
0827    EB            4448     MOV A , R3 
0828    13            4449     	RRC	A
0829    FB            4450     MOV R3 , A 
082A    EA            4451     MOV A , R2 
082B    13            4452     	RRC	A
082C    FA            4453     MOV R2 , A 
                      4454     	; Check range
082D    EC            4455     MOV A , R4 
082E    14            4456     	DEC	A
082F    6013          4457     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      4458     GOVERNOR_ACTIVATE_100K: 
0831    C3            4459     	CLR	C
0832    EB            4460     MOV A , R3 
0833    13            4461     	RRC	A
0834    FB            4462     MOV R3 , A 
0835    EA            4463     MOV A , R2 
0836    13            4464     	RRC	A
0837    FA            4465     MOV R2 , A 
0838    EC            4466     MOV A , R4 
0839    14            4467     	DEC	A
083A    14            4468     	DEC	A
083B    6007          4469     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      4470     GOVERNOR_ACTIVATE_50K: 
083D    C3            4471     	CLR	C
083E    EB            4472     MOV A , R3 
083F    13            4473     	RRC	A
0840    FB            4474     MOV R3 , A 
0841    EA            4475     MOV A , R2 
0842    13            4476     	RRC	A
0843    FA            4477     MOV R2 , A 
                      4478     GOVERNOR_ACTIVATE_RANGE_SET: 
0844    12075F        4479     	CALL	DIV_U16_BY_U16
                      4480     	; Store governor target
0847    883E          4481     MOV GOV_TARGET_L , R0 
0849    893F          4482     MOV GOV_TARGET_H , R1 
                      4483     CALC_GOVERNOR_TARGET_EXIT: 
084B    22            4484     	RET						
                      4485     ENDIF
                      4486     
                      4487     
                      4488     ; Second governor routine - calculate governor proportional error
                      4489     CALC_GOVERNOR_PROP_ERROR: 
                      4490     	; Exit if governor is inactive
084C    E547          4491     	MOV	A, GOV_ACTIVE
084E    6034          4492     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      4493     
                      4494     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      4512     IF MODE == 2	; Multi
                      4513     	; Calculate error
0850    C3            4514     	CLR	C
0851    E53E          4515     	MOV	A, GOV_TARGET_L
0853    9523          4516     	SUBB	A, GOVERNOR_REQ_PWM
0855    F8            4517     MOV R0 , A 
0856    E53F          4518     	MOV	A, GOV_TARGET_H
0858    9400          4519     	SUBB	A, #0
085A    F9            4520     MOV R1 , A 
                      4521     ENDIF
                      4522     	; Check error and limit
085B    500C          4523     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      4524     
085D    C3            4525     	CLR	C
085E    E8            4526     MOV A , R0 
085F    9480          4527     	SUBB	A, #80H					; Is error too negative?
0861    E9            4528     MOV A , R1 
0862    94FF          4529     	SUBB	A, #0FFH
0864    4016          4530     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0866    020880        4531     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4532     
                      4533     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0869    C3            4534     	CLR	C
086A    E8            4535     MOV A , R0 
086B    947F          4536     	SUBB	A, #7FH					; Is error too positive?
086D    E9            4537     MOV A , R1 
086E    9400          4538     	SUBB	A, #00H
0870    5003          4539     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0872    020880        4540     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4541     
                      4542     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0875    787F          4543     MOV R0 , # 7FH 
0877    7900          4544     MOV R1 , # 00H 
0879    020880        4545     	JMP	GOVERNOR_STORE_PROP_ERROR
                      4546     
                      4547     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
087C    7880          4548     MOV R0 , # 80H 
087E    79FF          4549     MOV R1 , # 0FFH 
                      4550     
                      4551     GOVERNOR_STORE_PROP_ERROR: 
                      4552     	; Store proportional
0880    8843          4553     MOV GOV_PROPORTIONAL_L , R0 
0882    8944          4554     MOV GOV_PROPORTIONAL_H , R1 
                      4555     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0884    22            4556     	RET						
                      4557     
                      4558     
                      4559     ; Third governor routine - calculate governor integral error
                      4560     CALC_GOVERNOR_INT_ERROR: 
                      4561     	; Exit if governor is inactive
0885    E547          4562     	MOV	A, GOV_ACTIVE
0887    6058          4563     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      4564     
                      4565     	; Add proportional to integral
0889    E543          4566     	MOV	A, GOV_PROPORTIONAL_L
088B    2540          4567     	ADD	A, GOV_INTEGRAL_L
088D    F8            4568     MOV R0 , A 
088E    E544          4569     	MOV	A, GOV_PROPORTIONAL_H
0890    3541          4570     	ADDC	A, GOV_INTEGRAL_H
0892    F9            4571     MOV R1 , A 
0893    854420        4572     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
0896    E4            4573     	CLR	A
0897    300701        4574     	JNB	BIT_ACCESS.7, ($+4)			
089A    F4            4575     	CPL	A
089B    3542          4576     	ADDC	A, GOV_INTEGRAL_X
089D    FA            4577     MOV R2 , A 
                      4578     	; Check integral and limit
089E    30E709        4579     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      4580     
08A1    C3            4581     	CLR	C
08A2    EA            4582     MOV A , R2 
08A3    94F0          4583     	SUBB	A, #0F0H					; Is error too negative?
08A5    4015          4584     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
08A7    0208C2        4585     	JMP	GOVERNOR_CHECK_PWM
                      4586     
                      4587     GOVERNOR_CHECK_INT_LIMIT_POS: 
08AA    C3            4588     	CLR	C
08AB    EA            4589     MOV A , R2 
08AC    940F          4590     	SUBB	A, #0FH					; Is error too positive?
08AE    5003          4591     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
08B0    0208C2        4592     	JMP	GOVERNOR_CHECK_PWM
                      4593     
                      4594     GOVERNOR_LIMIT_INT_ERROR_POS: 
08B3    78FF          4595     MOV R0 , # 0FFH 
08B5    79FF          4596     MOV R1 , # 0FFH 
08B7    7A0F          4597     MOV R2 , # 0FH 
08B9    0208C2        4598     	JMP	GOVERNOR_CHECK_PWM
                      4599     
                      4600     GOVERNOR_LIMIT_INT_ERROR_NEG: 
08BC    7800          4601     MOV R0 , # 00H 
08BE    7900          4602     MOV R1 , # 00H 
08C0    7AF0          4603     MOV R2 , # 0F0H 
                      4604     
                      4605     GOVERNOR_CHECK_PWM: 
                      4606     	; Check current pwm
08C2    C3            4607     	CLR	C
08C3    E524          4608     	MOV	A, CURRENT_PWM
08C5    955E          4609     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
08C7    5006          4610     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      4611     
08C9    E524          4612     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
08CB    6009          4613     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      4614     
08CD    01DB          4615     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      4616     
                      4617     GOVERNOR_INT_MAX_PWM: 
08CF    E544          4618     	MOV	A, GOV_PROPORTIONAL_H
08D1    20E70D        4619     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      4620     
08D4    01DB          4621     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      4622     
                      4623     GOVERNOR_INT_MIN_PWM: 
08D6    E544          4624     	MOV	A, GOV_PROPORTIONAL_H
08D8    30E706        4625     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      4626     
                      4627     GOVERNOR_STORE_INT_ERROR: 
                      4628     	; Store integral
08DB    8840          4629     MOV GOV_INTEGRAL_L , R0 
08DD    8941          4630     MOV GOV_INTEGRAL_H , R1 
08DF    8A42          4631     MOV GOV_INTEGRAL_X , R2 
                      4632     CALC_GOVERNOR_INT_ERROR_EXIT: 
08E1    22            4633     	RET						
                      4634     
                      4635     
                      4636     ; Fourth governor routine - calculate governor proportional correction
                      4637     CALC_GOVERNOR_PROP_CORRECTION: 
                      4638     	; Exit if governor is inactive
08E2    E547          4639     	MOV	A, GOV_ACTIVE
08E4    7003          4640     	JNZ	CALC_GOVERNOR_PROP_CORR
08E6    020946        4641     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      4642     
                      4643     CALC_GOVERNOR_PROP_CORR: 
                      4644     	; Load proportional gain
08E9    78A1          4645     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
08EB    E6            4646     MOV A , @ R0 
08EC    FA            4647     MOV R2 , A 
                      4648     	; Load proportional
08ED    C3            4649     	CLR	C
08EE    E543          4650     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
08F0    33            4651     	RLC	A
08F1    F8            4652     MOV R0 , A 
08F2    E544          4653     	MOV	A, GOV_PROPORTIONAL_H
08F4    33            4654     	RLC	A
08F5    F9            4655     MOV R1 , A 
                      4656     	; Apply gain
08F6    120797        4657     	CALL	MULT_S16_BY_U8_DIV_16
                      4658     	; Check error and limit (to low byte)
08F9    E9            4659     MOV A , R1 
08FA    30E70B        4660     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      4661     
08FD    C3            4662     	CLR	C
08FE    E8            4663     MOV A , R0 
08FF    9480          4664     	SUBB	A, #80H					; Is error too negative?
0901    E9            4665     MOV A , R1 
0902    94FF          4666     	SUBB	A, #0FFH
0904    4013          4667     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0906    211D          4668     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4669     
                      4670     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0908    C3            4671     	CLR	C
0909    E8            4672     MOV A , R0 
090A    947F          4673     	SUBB	A, #7FH					; Is error too positive?
090C    E9            4674     MOV A , R1 
090D    9400          4675     	SUBB	A, #00H
090F    5002          4676     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0911    211D          4677     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4678     
                      4679     GOVERNOR_LIMIT_PROP_CORR_POS: 
0913    787F          4680     MOV R0 , # 7FH 
0915    7900          4681     MOV R1 , # 00H 
0917    211D          4682     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4683     
                      4684     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0919    7880          4685     MOV R0 , # 80H 
091B    79FF          4686     MOV R1 , # 0FFH 
                      4687     
                      4688     GOVERNOR_APPLY_PROP_CORR: 
                      4689     	; Test proportional sign
091D    E8            4690     MOV A , R0 
091E    20E715        4691     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      4692     
                      4693     	; Subtract positive proportional
0921    C3            4694     	CLR	C
0922    E523          4695     	MOV	A, GOVERNOR_REQ_PWM
0924    98            4696     SUBB A , R0 
0925    F8            4697     MOV R0 , A 
                      4698     	; Check result
0926    4009          4699     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      4700     
0928    C3            4701     	CLR	C
0929    E8            4702     MOV A , R0 
092A    9401          4703     	SUBB	A, #1
092C    4003          4704     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
092E    020944        4705     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4706     
                      4707     GOVERNOR_CORR_PROP_MIN_PWM: 
0931    7801          4708     MOV R0 , # 1 
0933    020944        4709     	JMP	GOVERNOR_STORE_PROP_CORR
                      4710     
                      4711     GOVERNOR_CORR_NEG_PROP: 
                      4712     	; Add negative proportional
0936    E8            4713     MOV A , R0 
0937    F4            4714     	CPL	A
0938    2401          4715     	ADD	A, #1
093A    2523          4716     	ADD	A, GOVERNOR_REQ_PWM
093C    F8            4717     MOV R0 , A 
                      4718     	; Check result
093D    4003          4719     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
093F    020944        4720     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4721     
                      4722     GOVERNOR_CORR_PROP_MAX_PWM: 
0942    78FF          4723     MOV R0 , # 255 
                      4724     GOVERNOR_STORE_PROP_CORR: 
                      4725     	; Store proportional pwm
0944    8845          4726     MOV GOV_PROP_PWM , R0 
                      4727     CALC_GOVERNOR_PROP_CORR_EXIT: 
0946    22            4728     	RET
                      4729     
                      4730     
                      4731     ; Fifth governor routine - calculate governor integral correction
                      4732     CALC_GOVERNOR_INT_CORRECTION: 
                      4733     	; Exit if governor is inactive
0947    E547          4734     	MOV	A, GOV_ACTIVE
0949    7003          4735     	JNZ	CALC_GOVERNOR_INT_CORR
094B    0209A9        4736     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      4737     
                      4738     CALC_GOVERNOR_INT_CORR: 
                      4739     	; Load integral gain
094E    78A2          4740     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0950    E6            4741     MOV A , @ R0 
0951    FA            4742     MOV R2 , A 
                      4743     	; Load integral
0952    A841          4744     MOV R0 , GOV_INTEGRAL_H 
0954    A942          4745     MOV R1 , GOV_INTEGRAL_X 
                      4746     	; Apply gain
0956    120797        4747     	CALL	MULT_S16_BY_U8_DIV_16
                      4748     	; Check integral and limit
0959    E9            4749     MOV A , R1 
095A    30E70C        4750     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      4751     
095D    C3            4752     	CLR	C
095E    E8            4753     MOV A , R0 
095F    9401          4754     	SUBB	A, #01H					; Is integral too negative?
0961    E9            4755     MOV A , R1 
0962    94FF          4756     	SUBB	A, #0FFH
0964    4016          4757     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0966    020980        4758     	JMP	GOVERNOR_APPLY_INT_CORR
                      4759     
                      4760     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0969    C3            4761     	CLR	C
096A    E8            4762     MOV A , R0 
096B    94FF          4763     	SUBB	A, #0FFH					; Is integral too positive?
096D    E9            4764     MOV A , R1 
096E    9400          4765     	SUBB	A, #00H
0970    5003          4766     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0972    020980        4767     	JMP	GOVERNOR_APPLY_INT_CORR
                      4768     
                      4769     GOVERNOR_LIMIT_INT_CORR_POS: 
0975    78FF          4770     MOV R0 , # 0FFH 
0977    7900          4771     MOV R1 , # 00H 
0979    020980        4772     	JMP	GOVERNOR_APPLY_INT_CORR
                      4773     
                      4774     GOVERNOR_LIMIT_INT_CORR_NEG: 
097C    7801          4775     MOV R0 , # 01H 
097E    79FF          4776     MOV R1 , # 0FFH 
                      4777     
                      4778     GOVERNOR_APPLY_INT_CORR: 
                      4779     	; Test integral sign
0980    E9            4780     MOV A , R1 
0981    20E715        4781     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      4782     
                      4783     	; Subtract positive integral
0984    C3            4784     	CLR	C
0985    E545          4785     	MOV	A, GOV_PROP_PWM
0987    98            4786     SUBB A , R0 
0988    F8            4787     MOV R0 , A 
                      4788     	; Check result
0989    4009          4789     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      4790     
098B    C3            4791     	CLR	C
098C    E8            4792     MOV A , R0 
098D    9401          4793     	SUBB	A, #1
098F    4003          4794     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0991    0209A7        4795     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4796     
                      4797     GOVERNOR_CORR_INT_MIN_PWM: 
0994    7800          4798     MOV R0 , # 0 
0996    0209A7        4799     	JMP	GOVERNOR_STORE_INT_CORR
                      4800     
                      4801     GOVERNOR_CORR_NEG_INT: 
                      4802     	; Add negative integral
0999    E8            4803     MOV A , R0 
099A    F4            4804     	CPL	A
099B    2401          4805     	ADD	A, #1
099D    2545          4806     	ADD	A, GOV_PROP_PWM
099F    F8            4807     MOV R0 , A 
                      4808     	; Check result
09A0    4003          4809     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
09A2    0209A7        4810     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4811     
                      4812     GOVERNOR_CORR_INT_MAX_PWM: 
09A5    78FF          4813     MOV R0 , # 255 
                      4814     GOVERNOR_STORE_INT_CORR: 
                      4815     	; Store current pwm
09A7    8824          4816     MOV CURRENT_PWM , R0 
                      4817     CALC_GOVERNOR_INT_CORR_EXIT: 
09A9    22            4818     	RET
                      4819     
                      4820     
                      4821     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4822     ;
                      4823     ; Set pwm limit low rpm
                      4824     ;
                      4825     ; No assumptions
                      4826     ;
                      4827     ; Sets power limit for low rpms and disables demag for low rpms
                      4828     ;
                      4829     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4830     SET_PWM_LIMIT_LOW_RPM: 
                      4831     	; Set pwm limit and demag disable for low rpms
09AA    78FF          4832     MOV R0 , # 0FFH 
09AC    C264          4833     CLR FLAGS0 . 4 
09AE    E52D          4834     	MOV	A, FLAGS1
09B0    5406          4835     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
09B2    702F          4836     	JNZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Exit if any startup phase set
                      4837     
09B4    D264          4838     SETB FLAGS0 . 4 
09B6    C3            4839     	CLR	C
09B7    E53B          4840     	MOV	A, COMM_PERIOD4X_H
09B9    940A          4841     	SUBB	A, #0AH						; ~31250 eRPM
09BB    4009          4842     	JC	SET_PWM_DEMAG_DONE				; If speed above - branch
                      4843     
09BD    C3            4844     	CLR	C
09BE    E525          4845     	MOV	A, CURRENT_PWM_LIMITED	
09C0    9440          4846     	SUBB	A, #40H						; Do not disable if pwm above 25%
09C2    5002          4847     	JNC	SET_PWM_DEMAG_DONE
                      4848     
09C4    C264          4849     CLR FLAGS0 . 4 
                      4850     
                      4851     SET_PWM_DEMAG_DONE: 
09C6    E53B          4852     	MOV	A, COMM_PERIOD4X_H
09C8    6019          4853     	JZ	SET_PWM_LIMIT_LOW_RPM_EXIT		; Avoid divide by zero
                      4854     
09CA    74FF          4855     	MOV	A, #255						; Divide 255 by Comm_Period4x_H
09CC    853BF0        4856     	MOV	B, COMM_PERIOD4X_H
09CF    84            4857     	DIV	AB
09D0    8537F0        4858     	MOV	B, LOW_RPM_PWR_SLOPE			; Multiply by slope
09D3    A4            4859     	MUL	AB
09D4    F8            4860     MOV R0 , A 
09D5    C5F0          4861     	XCH	A, B
09D7    6002          4862     	JZ	($+4)						; Limit to max
                      4863     	
09D9    78FF          4864     MOV R0 , # 0FFH 
                      4865     
09DB    C3            4866     	CLR	C
09DC    E8            4867     MOV A , R0 
09DD    9561          4868     	SUBB	A, PWM_SPOOLUP_BEG
09DF    5002          4869     	JNC	SET_PWM_LIMIT_LOW_RPM_EXIT
                      4870     
09E1    A861          4871     MOV R0 , PWM_SPOOLUP_BEG 
                      4872     
                      4873     SET_PWM_LIMIT_LOW_RPM_EXIT: 
09E3    8860          4874     MOV PWM_LIMIT_LOW_RPM , R0 
09E5    22            4875     	RET
                      4876     	
                      4877     	
                      4878     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4879     ;
                      4880     ; Measure lipo cells
                      4881     ;
                      4882     ; No assumptions
                      4883     ;
                      4884     ; Measure voltage and calculate lipo cells
                      4885     ;
                      4886     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4887     MEASURE_LIPO_CELLS: 
                      4888     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      4892     MEASURE_LIPO_START: 
                      4893     	; Load programmed low voltage limit
09E6    7883          4894     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
09E8    E6            4895     MOV A , @ R0 
09E9    F520          4896     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      4897     	; Set commutation to BpFET on
09EB    120F03        4898     	CALL	COMM5COMM6			
                      4899     	; Start adc
                      4900     	START_ADC 
09EE    75E890        4900+1   MOV ADC0CN , # 90H  ; ADC START
                      4901     	; Wait for ADC reference to settle, and then start again
09F1    1206C6        4902     	CALL	WAIT1MS
                      4903     	START_ADC
09F4    75E890        4903+1   MOV ADC0CN , # 90H  ; ADC START
                      4904     	; Wait for ADC conversion to complete
                      4905     MEASURE_LIPO_WAIT_ADC: 
                      4906     	GET_ADC_STATUS 
09F7    E5E8          4906+1   MOV A , ADC0CN 
09F9    20ECFB        4907     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      4908     	; Read ADC result
                      4909     	READ_ADC_RESULT
09FC    A8BD          4909+1   MOV R0 , ADC0L 
09FE    A9BE          4909+1   MOV R1 , ADC0H 
                      4910     	; Stop ADC
                      4911     	STOP_ADC
                      4912     	; Switch power off
0A00    120F99        4913     	CALL	SWITCH_POWER_OFF		
                      4914     	; Set limit step
0A03    756B55        4915     MOV LIPO_ADC_LIMIT_L , # 85 
0A06    756C00        4916     MOV LIPO_ADC_LIMIT_H , # 0 
0A09    C3            4917     	CLR	C
0A0A    7400          4918     MOV A , # 0 
0A0C    13            4919     	RRC	A
0A0D    FD            4920     MOV R5 , A 
0A0E    7455          4921     MOV A , # 85 
0A10    13            4922     	RRC	A
0A11    FC            4923     MOV R4 , A 
0A12    7455          4924     MOV A , # 85 
0A14    2C            4925     ADD A , R4 
0A15    FC            4926     MOV R4 , A 
0A16    7400          4927     MOV A , # 0 
0A18    3D            4928     ADDC A , R5 
0A19    FD            4929     MOV R5 , A 
0A1A    EC            4930     MOV A , R4 
0A1B    FA            4931     MOV R2 , A 
0A1C    ED            4932     MOV A , R5 
0A1D    FB            4933     MOV R3 , A 
                      4934     MEASURE_LIPO_CELL_LOOP: 
                      4935     	; Check voltage against xS lower limit
0A1E    C3            4936     	CLR	C
0A1F    E8            4937     MOV A , R0 
0A20    9A            4938     SUBB A , R2 
0A21    E9            4939     MOV A , R1 
0A22    9B            4940     SUBB A , R3 
0A23    4014          4941     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      4942     
                      4943     	; Set xS voltage limit
0A25    E56B          4944     	MOV	A, LIPO_ADC_LIMIT_L		
0A27    2455          4945     ADD A , # 85 
0A29    F56B          4946     	MOV	LIPO_ADC_LIMIT_L, A
0A2B    E56C          4947     	MOV	A, LIPO_ADC_LIMIT_H		
0A2D    3400          4948     ADDC A , # 0 
0A2F    F56C          4949     	MOV	LIPO_ADC_LIMIT_H, A
                      4950     	; Set (x+1)S lower limit
0A31    EA            4951     MOV A , R2 
0A32    2C            4952     ADD A , R4 
0A33    FA            4953     MOV R2 , A 
0A34    EB            4954     MOV A , R3 
0A35    3D            4955     ADDC A , R5 
0A36    FB            4956     MOV R3 , A 
0A37    80E5          4957     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      4958     
                      4959     MEASURE_LIPO_ADJUST: 
0A39    AE6B          4960     MOV R6 , LIPO_ADC_LIMIT_L 
0A3B    AF6C          4961     MOV R7 , LIPO_ADC_LIMIT_H 
                      4962     	; Calculate 3.125%
0A3D    C3            4963     	CLR	C
0A3E    E56C          4964     	MOV	A, LIPO_ADC_LIMIT_H
0A40    13            4965     	RRC	A
0A41    F9            4966     MOV R1 , A 
0A42    E56B          4967     	MOV	A, LIPO_ADC_LIMIT_L	
0A44    13            4968     	RRC	A
0A45    F8            4969     MOV R0 , A 
0A46    C3            4970     	CLR	C
0A47    E9            4971     MOV A , R1 
0A48    13            4972     	RRC	A
0A49    F9            4973     MOV R1 , A 
0A4A    E8            4974     MOV A , R0 
0A4B    13            4975     	RRC	A
0A4C    F8            4976     MOV R0 , A 
0A4D    E56B          4977     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0A4F    28            4978     ADD A , R0 
0A50    F569          4979     	MOV	LIPO_ADC_REFERENCE_L, A
0A52    E56C          4980     	MOV	A, LIPO_ADC_LIMIT_H
0A54    39            4981     ADDC A , R1 
0A55    F56A          4982     	MOV	LIPO_ADC_REFERENCE_H, A
                      4983     	; Divide three times to get to 3.125%
0A57    7A03          4984     MOV R2 , # 3 
                      4985     MEASURE_LIPO_DIVIDE_LOOP: 
0A59    C3            4986     	CLR	C
0A5A    E9            4987     MOV A , R1 
0A5B    13            4988     	RRC	A
0A5C    F9            4989     MOV R1 , A 
0A5D    E8            4990     MOV A , R0 
0A5E    13            4991     	RRC	A
0A5F    F8            4992     MOV R0 , A 
0A60    DAF7          4993     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      4994     
                      4995     	; Add the programmed number of 0.1V (or 3.125% increments)
0A62    AA20          4996     MOV R2 , BIT_ACCESS 
0A64    1A            4997     DEC R2 
0A65    7009          4998     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      4999     
0A67    756B00        5000     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0A6A    756C00        5001     	MOV	LIPO_ADC_LIMIT_H, #0
0A6D    020A80        5002     	JMP	MEASURE_LIPO_EXIT	
                      5003     
                      5004     MEASURE_LIPO_LIMIT_ON: 
0A70    1A            5005     DEC R2 
0A71    EA            5006     MOV A , R2 
0A72    6008          5007     	JZ	MEASURE_LIPO_UPDATE
                      5008     
                      5009     MEASURE_LIPO_ADD_LOOP: 
0A74    EE            5010     MOV A , R6 
0A75    28            5011     ADD A , R0 
0A76    FE            5012     MOV R6 , A 
0A77    EF            5013     MOV A , R7 
0A78    39            5014     ADDC A , R1 
0A79    FF            5015     MOV R7 , A 
0A7A    DAF8          5016     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      5017     
                      5018     MEASURE_LIPO_UPDATE: 
                      5019     	; Set ADC limit
0A7C    8E6B          5020     MOV LIPO_ADC_LIMIT_L , R6 
0A7E    8F6C          5021     MOV LIPO_ADC_LIMIT_H , R7 
                      5022     MEASURE_LIPO_EXIT: 
0A80    22            5023     	RET
                      5024     
                      5025     
                      5026     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5027     ;
                      5028     ; Start ADC conversion
                      5029     ;
                      5030     ; No assumptions
                      5031     ;
                      5032     ; Start conversion used for measuring power supply voltage
                      5033     ;
                      5034     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5035     START_ADC_CONVERSION: 
                      5036     	; Start adc
                      5037     	START_ADC 
0A81    75E890        5037+1   MOV ADC0CN , # 90H  ; ADC START
0A84    22            5038     	RET
                      5039     
                      5040     
                      5041     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5042     ;
                      5043     ; Check temperature, power supply voltage and limit power
                      5044     ;
                      5045     ; No assumptions
                      5046     ;
                      5047     ; Used to limit main motor power in order to maintain the required voltage
                      5048     ;
                      5049     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5050     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      5051     	; Load programmed low voltage limit
0A85    7883          5052     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0A87    E6            5053     MOV A , @ R0 
0A88    FF            5054     MOV R7 , A 
                      5055     	; Wait for ADC conversion to complete
                      5056     	GET_ADC_STATUS 
0A89    E5E8          5056+1   MOV A , ADC0CN 
0A8B    20ECF7        5057     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      5058     	; Read ADC result
                      5059     	READ_ADC_RESULT
0A8E    A8BD          5059+1   MOV R0 , ADC0L 
0A90    A9BE          5059+1   MOV R1 , ADC0H 
                      5060     	; Stop ADC
                      5061     	STOP_ADC
                      5062     
0A92    056D          5063     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0A94    C3            5064     	CLR	C
0A95    E56D          5065     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0A97    9408          5066     SUBB A , # 8 
0A99    4052          5067     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      5068     
0A9B    756D00        5069     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0A9E    E9            5070     MOV A , R1 
0A9F    FA            5071     MOV R2 , A 
0AA0    79A0          5072     MOV R1 , # PGM_ENABLE_TEMP_PROT 
0AA2    E7            5073     MOV A , @ R1 
0AA3    6044          5074     	JZ	TEMP_CHECK_EXIT			; No - branch
                      5075     
0AA5    EA            5076     MOV A , R2 
0AA6    7007          5077     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      5078     
0AA8    E56E          5079     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0AAA    601B          5080     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0AAC    020ABB        5081     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      5082     
                      5083     TEMP_AVERAGE_INC_DEC: 
0AAF    C3            5084     	CLR	C
0AB0    E8            5085     MOV A , R0 
0AB1    956E          5086     	SUBB	A, CURRENT_AVERAGE_TEMP
0AB3    6010          5087     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      5088     
0AB5    E56E          5089     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0AB7    5006          5090     	JNC	TEMP_AVERAGE_INC				
                      5091     
0AB9    600C          5092     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      5093     TEMP_AVERAGE_DEC: 
0ABB    14            5094     	DEC	A						; Decrement average
0ABC    020AC7        5095     	JMP	TEMP_AVERAGE_UPDATED
                      5096     
                      5097     TEMP_AVERAGE_INC: 
0ABF    04            5098     	INC	A						; Increment average
0AC0    60F9          5099     	JZ	TEMP_AVERAGE_DEC
0AC2    020AC7        5100     	JMP	TEMP_AVERAGE_UPDATED
                      5101     
                      5102     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0AC5    E56E          5103     	MOV	A, CURRENT_AVERAGE_TEMP
                      5104     TEMP_AVERAGE_UPDATED: 
0AC7    F56E          5105     	MOV	CURRENT_AVERAGE_TEMP, A
0AC9    C3            5106     	CLR	C
0ACA    946D          5107     SUBB A , # 109 
0ACC    401B          5108     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5109     
0ACE    755EC0        5110     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      5111     
0AD1    C3            5112     	CLR	C
0AD2    9404          5113     SUBB A , # 4 
0AD4    4013          5114     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5115     
0AD6    755E80        5116     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      5117     
0AD9    C3            5118     	CLR	C
0ADA    9404          5119     SUBB A , # 4 
0ADC    400B          5120     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5121     
0ADE    755E40        5122     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      5123     
0AE1    C3            5124     	CLR	C
0AE2    9404          5125     SUBB A , # 4 
0AE4    4003          5126     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      5127     
0AE6    755E00        5128     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      5129     
                      5130     TEMP_CHECK_EXIT: 
                      5131     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0AE9    75BB0E        5131+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0AEC    22            5132     	RET
                      5133     
                      5134     CHECK_VOLTAGE_START: 
                      5135     IF MODE == 0 OR MODE == 2	; Main or multi
                      5136     	; Check if low voltage limiting is enabled
0AED    EF            5137     MOV A , R7 
0AEE    C3            5138     	CLR	C
0AEF    9401          5139     	SUBB	A, #1					; Is low voltage limit disabled?
0AF1    601B          5140     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      5141     
                      5142     	; Check if ADC is saturated
0AF3    C3            5143     	CLR	C
0AF4    E8            5144     MOV A , R0 
0AF5    94FF          5145     	SUBB	A, #0FFH
0AF7    E9            5146     MOV A , R1 
0AF8    9403          5147     	SUBB	A, #03H
0AFA    5012          5148     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      5149     
                      5150     	; Check voltage against limit
0AFC    C3            5151     	CLR	C
0AFD    E8            5152     MOV A , R0 
0AFE    956B          5153     	SUBB	A, LIPO_ADC_LIMIT_L
0B00    E9            5154     MOV A , R1 
0B01    956C          5155     	SUBB	A, LIPO_ADC_LIMIT_H
0B03    5009          5156     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      5157     
                      5158     	; Decrease pwm limit
0B05    E55E          5159     	MOV  A, PWM_LIMIT
0B07    601A          5160     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      5161     
0B09    155E          5162     	DEC	PWM_LIMIT					; Decrement limit
0B0B    020B23        5163     	JMP	CHECK_VOLTAGE_LIM
                      5164     
                      5165     CHECK_VOLTAGE_GOOD: 
                      5166     	; Increase pwm limit
0B0E    E55E          5167     	MOV  A, PWM_LIMIT
0B10    F4            5168     	CPL	A			
0B11    6010          5169     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      5170     
0B13    055E          5171     	INC	PWM_LIMIT					; Increment limit
                      5172     IF MODE == 2	; Multi
0B15    7888          5173     MOV R0 , # PGM_DIRECTION 
0B17    E6            5174     MOV A , @ R0 
0B18    B40308        5175     	CJNE	A, #3, CHECK_VOLTAGE_LIM
                      5176     
0B1B    E55E          5177     	MOV  A, PWM_LIMIT
0B1D    2404          5178     	ADD	A, #4			
0B1F    4002          5179     	JC	CHECK_VOLTAGE_LIM			; If limit max - branch
                      5180     
0B21    F55E          5181     	MOV	PWM_LIMIT, A				; Increment limit two steps more
                      5182     ENDIF
                      5183     
                      5184     CHECK_VOLTAGE_LIM: 
0B23    A85E          5185     MOV R0 , PWM_LIMIT 
0B25    C3            5186     	CLR	C
0B26    E524          5187     	MOV	A, CURRENT_PWM
0B28    98            5188     SUBB A , R0 
0B29    5002          5189     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      5190     
0B2B    A824          5191     MOV R0 , CURRENT_PWM 
                      5192     
                      5193     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      5194     	; Slow spoolup
0B2D    C3            5195     	CLR	C
0B2E    E8            5196     MOV A , R0 
0B2F    955F          5197     	SUBB	A, PWM_LIMIT_SPOOLUP
0B31    400A          5198     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      5199     
0B33    A85F          5200     MOV R0 , PWM_LIMIT_SPOOLUP 
0B35    E55F          5201     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0B37    F4            5202     	CPL	A
0B38    6003          5203     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      5204      
0B3A    855F5E        5205     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      5206     
                      5207     CHECK_VOLTAGE_EXIT: 
                      5208     IF MODE == 0	; Main 
                               	MOV  CURRENT_PWM_LIMITED, TEMP1
                               ENDIF
                      5211     IF MODE == 2	; Multi
                      5212     	; Set current pwm limited if closed loop mode
0B3D    7982          5213     MOV R1 , # PGM_GOV_MODE 
0B3F    B70402        5214     CJNE @ R1 , # 4 , CHECK_VOLTAGE_SET_PWM 
0B42    614E          5215     	AJMP	CHECK_VOLTAGE_PWM_DONE
                      5216     
                      5217     CHECK_VOLTAGE_SET_PWM: 
                      5218     	; Limit pwm for low rpms
0B44    C3            5219     	CLR	C
0B45    E8            5220     MOV A , R0 
0B46    9560          5221     	SUBB	A, PWM_LIMIT_LOW_RPM
0B48    4002          5222     	JC	($+4)					; If current pwm below limit - branch
                      5223     
0B4A    A860          5224     MOV R0 , PWM_LIMIT_LOW_RPM 
                      5225     
0B4C    8825          5226     MOV CURRENT_PWM_LIMITED , R0 
                      5227     CHECK_VOLTAGE_PWM_DONE: 
                      5228     ENDIF
                      5229     ENDIF
                      5230     IF MODE == 1	; Tail
                               	; Increase pwm limit
                               	MOV  A, PWM_LIMIT
                               	CPL	A			
                               	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                               
                               	INC	PWM_LIMIT					; Increment limit
                               
                               CHECK_VOLTAGE_LIM:
                               ENDIF
                      5240     	; Set adc mux for next conversion
0B4E    E56D          5241     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0B50    B40703        5242     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      5243     
                      5244     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0B53    75BB10        5244+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5245     
                      5246     CHECK_VOLTAGE_RET: 
0B56    22            5247     	RET
                      5248     
                      5249     
                      5250     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5251     ;
                      5252     ; Set startup PWM routine
                      5253     ;
                      5254     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      5255     ;
                      5256     ; Used for pwm control during startup
                      5257     ;
                      5258     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5259     SET_STARTUP_PWM: 	
                      5260     	; Adjust startup power
0B57    7432          5261     MOV A , # 50 
0B59    79A3          5262     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0B5B    87F0          5263     MOV B , @ R1 
0B5D    A4            5264     	MUL	AB
0B5E    C5F0          5265     	XCH	A, B
0B60    A2F7          5266     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0B62    33            5267     	RLC	A
0B63    F8            5268     MOV R0 , A 
0B64    C3            5269     	CLR	C
0B65    E8            5270     MOV A , R0 
0B66    955E          5271     	SUBB	A, PWM_LIMIT	
0B68    4002          5272     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      5273     
0B6A    A85E          5274     MOV R0 , PWM_LIMIT 
                      5275     
                      5276     STARTUP_PWM_SET_PWM: 
                      5277     	; Set pwm variables
0B6C    8822          5278     MOV REQUESTED_PWM , R0 
0B6E    8824          5279     MOV CURRENT_PWM , R0 
0B70    8825          5280     MOV CURRENT_PWM_LIMITED , R0 
0B72    8861          5281     MOV PWM_SPOOLUP_BEG , R0 
0B74    22            5282     	RET
                      5283     
                      5284     
                      5285     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5286     ;
                      5287     ; Initialize all timings routine
                      5288     ;
                      5289     ; No assumptions
                      5290     ;
                      5291     ; Part of initialization before motor start
                      5292     ;
                      5293     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5294     INITIALIZE_ALL_TIMINGS:  
0B75    753A00        5295     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0B78    753B7F        5296     	MOV	COMM_PERIOD4X_H, #7FH
0B7B    22            5297     	RET
                      5298     
                      5299     
                      5300     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5301     ;
                      5302     ; Calculate next commutation timing routine
                      5303     ;
                      5304     ; No assumptions
                      5305     ;
                      5306     ; Called immediately after each commutation
                      5307     ; Also sets up timer 3 to wait advance timing
                      5308     ; Two entry points are used
                      5309     ;
                      5310     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5311     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
                      5312     	; Read commutation time
0B7C    75C820        5313     	MOV	TMR2CN, #20H		; Timer2 disabled
0B7F    A8CC          5314     MOV R0 , TMR2L 
0B81    A9CD          5315     MOV R1 , TMR2H 
0B83    75C824        5316     	MOV	TMR2CN, #24H		; Timer2 enabled
                      5317     IF MCU_50MHZ == 1
                               	CLR	C
                               	MOV	A, TEMP2
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	RRC	A
                               	MOV	TEMP1, A
                               ENDIF
                      5326     	; Calculate this commutation time
0B86    AA38          5327     MOV R2 , PREV_COMM_L 
0B88    AB39          5328     MOV R3 , PREV_COMM_H 
0B8A    8838          5329     MOV PREV_COMM_L , R0 
0B8C    8939          5330     MOV PREV_COMM_H , R1 
0B8E    C3            5331     	CLR	C
0B8F    E8            5332     MOV A , R0 
0B90    9A            5333     SUBB A , R2 
0B91    F8            5334     MOV R0 , A 
0B92    E9            5335     MOV A , R1 
0B93    9B            5336     SUBB A , R3 
                      5337     IF MCU_50MHZ == 1
                               	ANL	A, #7FH
                               ENDIF
0B94    F9            5340     MOV R1 , A 
                      5341     	; Calculate new commutation time 
0B95    AA3A          5342     MOV R2 , COMM_PERIOD4X_L 
0B97    AB3B          5343     MOV R3 , COMM_PERIOD4X_H 
0B99    AC3A          5344     MOV R4 , COMM_PERIOD4X_L 
0B9B    AD3B          5345     MOV R5 , COMM_PERIOD4X_H 
0B9D    7E04          5346     MOV R6 , # 4 
0B9F    7F02          5347     MOV R7 , # 2 
0BA1    C3            5348     	CLR	C
0BA2    EB            5349     MOV A , R3 
0BA3    9404          5350     	SUBB	A, #04H
0BA5    4002          5351     	JC	($+4)
                      5352     
0BA7    1E            5353     DEC R6 
0BA8    1F            5354     DEC R7 
                      5355     
0BA9    C3            5356     	CLR	C
0BAA    EB            5357     MOV A , R3 
0BAB    9408          5358     	SUBB	A, #08H
0BAD    4002          5359     	JC	($+4)
                      5360     
0BAF    1E            5361     DEC R6 
0BB0    1F            5362     DEC R7 
                      5363     
                      5364     CALC_NEXT_COMM_AVG_PERIOD_DIV: 
0BB1    C3            5365     	CLR	C
0BB2    ED            5366     MOV A , R5 
0BB3    13            5367     	RRC	A					; Divide by 2
0BB4    FD            5368     MOV R5 , A 
0BB5    EC            5369     MOV A , R4 
0BB6    13            5370     	RRC	A
0BB7    FC            5371     MOV R4 , A 
0BB8    DEF7          5372     DJNZ R6 , CALC_NEXT_COMM_AVG_PERIOD_DIV 
                      5373     
0BBA    C3            5374     	CLR	C
0BBB    EA            5375     MOV A , R2 
0BBC    9C            5376     SUBB A , R4 
0BBD    FA            5377     MOV R2 , A 
0BBE    EB            5378     MOV A , R3 
0BBF    9D            5379     SUBB A , R5 
0BC0    FB            5380     MOV R3 , A 
0BC1    EF            5381     MOV A , R7 
0BC2    6009          5382     	JZ	CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE
                      5383     
                      5384     CALC_NEXT_COMM_NEW_PERIOD_DIV: 
0BC4    C3            5385     	CLR	C
0BC5    E9            5386     MOV A , R1 
0BC6    13            5387     	RRC	A					; Divide by 2
0BC7    F9            5388     MOV R1 , A 
0BC8    E8            5389     MOV A , R0 
0BC9    13            5390     	RRC	A
0BCA    F8            5391     MOV R0 , A 
0BCB    DFF7          5392     DJNZ R7 , CALC_NEXT_COMM_NEW_PERIOD_DIV 
                      5393     
                      5394     CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE: 
0BCD    EA            5395     MOV A , R2 
0BCE    28            5396     ADD A , R0 
0BCF    FA            5397     MOV R2 , A 
0BD0    EB            5398     MOV A , R3 
0BD1    39            5399     ADDC A , R1 
0BD2    FB            5400     MOV R3 , A 
0BD3    8A3A          5401     MOV COMM_PERIOD4X_L , R2 
0BD5    8B3B          5402     MOV COMM_PERIOD4X_H , R3 
0BD7    4001          5403     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      5404     
0BD9    22            5405     	RET
                      5406     
                      5407     CALC_NEXT_COMM_SLOW: 
0BDA    753AFF        5408     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0BDD    753BFF        5409     	MOV	COMM_PERIOD4X_H, #0FFH
0BE0    22            5410     	RET
                      5411     
                      5412     
                      5413     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5414     ;
                      5415     ; Wait advance timing routine
                      5416     ;
                      5417     ; No assumptions
                      5418     ;
                      5419     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                      5420     ;
                      5421     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5422     WAIT_ADVANCE_TIMING: 	
0BE1    306002        5423     JNB FLAGS0 . 0 , ( $+5 ) 
0BE4    61E1          5424     	AJMP	WAIT_ADVANCE_TIMING
                      5425     
                      5426     	; Setup next wait time
0BE6    854C50        5427     	MOV	NEXT_WT_L, WT_ZC_TIMEOUT_L
0BE9    854D51        5428     	MOV	NEXT_WT_H, WT_ZC_TIMEOUT_H
0BEC    D260          5429     SETB FLAGS0 . 0 
0BEE    43E680        5430     	ORL	EIE1, #80H	; Enable timer3 interrupts
0BF1    22            5431     	RET
                      5432     
                      5433     
                      5434     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5435     ;
                      5436     ; Calculate new wait times routine
                      5437     ;
                      5438     ; No assumptions
                      5439     ;
                      5440     ; Calculates new wait times
                      5441     ;
                      5442     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5443     CALC_NEW_WAIT_TIMES: 	
                      5444     	; Load programmed commutation timing
0BF2    7892          5445     MOV R0 , # PGM_COMM_TIMING 
0BF4    E6            5446     MOV A , @ R0 
0BF5    FF            5447     MOV R7 , A 
0BF6    C3            5448     	CLR	C
0BF7    E535          5449     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0BF9    9482          5450     	SUBB	A, #130
0BFB    4001          5451     	JC	($+3)
                      5452     
0BFD    0F            5453     INC R7 
                      5454     
0BFE    C3            5455     	CLR	C
0BFF    E535          5456     	MOV	A, DEMAG_DETECTED_METRIC
0C01    94A0          5457     	SUBB	A, #160
0C03    4001          5458     	JC	($+3)
                      5459     
0C05    0F            5460     INC R7 
                      5461     
0C06    C3            5462     	CLR	C
0C07    EF            5463     MOV A , R7 
0C08    9406          5464     	SUBB	A, #6
0C0A    4002          5465     	JC	($+4)
                      5466     
0C0C    7F05          5467     MOV R7 , # 5 
                      5468     
0C0E    7E02          5469     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
0C10    1E            5470     DEC R6 
0C11    307201        5471     JNB FLAGS2 . 2 , ( $+4 ) 
                      5472     
0C14    0E            5473     INC R6 
                      5474     
0C15    C3            5475     	CLR	C
0C16    E53B          5476     	MOV	A, COMM_PERIOD4X_H		; More reduction for higher rpms
0C18    9403          5477     	SUBB	A, #3				; 104k eRPM
0C1A    5006          5478     	JNC	CALC_NEW_WAIT_PER_LOW
                      5479     
0C1C    0E            5480     INC R6 
0C1D    0E            5481     INC R6 
                      5482     
0C1E    307201        5483     JNB FLAGS2 . 2 , CALC_NEW_WAIT_PER_LOW 
                      5484     
0C21    0E            5485     INC R6 
                      5486     
                      5487     CALC_NEW_WAIT_PER_LOW: 
0C22    C3            5488     	CLR	C
0C23    E53B          5489     	MOV	A, COMM_PERIOD4X_H		; More reduction for higher rpms
0C25    9402          5490     	SUBB	A, #2				; 156k eRPM
0C27    5006          5491     	JNC	CALC_NEW_WAIT_PER_HIGH
                      5492     
0C29    0E            5493     INC R6 
0C2A    0E            5494     INC R6 
                      5495     
0C2B    307201        5496     JNB FLAGS2 . 2 , CALC_NEW_WAIT_PER_HIGH 
                      5497     
0C2E    0E            5498     INC R6 
                      5499     
                      5500     CALC_NEW_WAIT_PER_HIGH: 
                      5501     	; Load current commutation timing
0C2F    A93B          5502     MOV R1 , COMM_PERIOD4X_H 
0C31    A83A          5503     MOV R0 , COMM_PERIOD4X_L 
0C33    7A04          5504     MOV R2 , # 4 
                      5505     DIVIDE_WAIT_TIMES: 
0C35    C3            5506     	CLR	C
0C36    E9            5507     MOV A , R1 
0C37    13            5508     	RRC	A					; Divide by 2
0C38    F9            5509     MOV R1 , A 
0C39    E8            5510     MOV A , R0 
0C3A    13            5511     	RRC	A
0C3B    F8            5512     MOV R0 , A 
0C3C    DAF7          5513     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      5514     
0C3E    C3            5515     	CLR	C
0C3F    E8            5516     MOV A , R0 
0C40    9E            5517     SUBB A , R6 
0C41    F8            5518     MOV R0 , A 
0C42    E9            5519     MOV A , R1 
0C43    9400          5520     	SUBB	A, #0
0C45    F9            5521     MOV R1 , A 
0C46    4009          5522     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      5523     
0C48    C3            5524     	CLR	C
0C49    E8            5525     MOV A , R0 
0C4A    9402          5526     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0C4C    E9            5527     MOV A , R1 
0C4D    9400          5528     	SUBB	A, #0
0C4F    5004          5529     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      5530     
                      5531     LOAD_MIN_TIME: 
0C51    7802          5532     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0C53    E4            5533     	CLR	A
0C54    F9            5534     MOV R1 , A 
                      5535     
                      5536     ADJUST_TIMING: 
0C55    E9            5537     MOV A , R1 
0C56    FB            5538     MOV R3 , A 
0C57    E8            5539     MOV A , R0 
0C58    FA            5540     MOV R2 , A 
0C59    C3            5541     	CLR	C
0C5A    E9            5542     MOV A , R1 
0C5B    13            5543     	RRC	A					; Divide by 2
0C5C    FD            5544     MOV R5 , A 
0C5D    E8            5545     MOV A , R0 
0C5E    13            5546     	RRC	A
0C5F    FC            5547     MOV R4 , A 
0C60    884C          5548     MOV WT_ZC_TIMEOUT_L , R0 
0C62    894D          5549     MOV WT_ZC_TIMEOUT_H , R1 
0C64    C3            5550     	CLR	C
0C65    EF            5551     MOV A , R7 
0C66    9403          5552     	SUBB	A, #3				; Is timing normal?
0C68    6037          5553     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      5554     
0C6A    EF            5555     MOV A , R7 
0C6B    20E00D        5556     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      5557     
0C6E    E8            5558     MOV A , R0 
0C6F    2C            5559     ADD A , R4 
0C70    F8            5560     MOV R0 , A 
0C71    E9            5561     MOV A , R1 
0C72    3D            5562     ADDC A , R5 
0C73    F9            5563     MOV R1 , A 
0C74    EC            5564     MOV A , R4 
0C75    FA            5565     MOV R2 , A 
0C76    ED            5566     MOV A , R5 
0C77    FB            5567     MOV R3 , A 
0C78    020C8E        5568     	JMP	STORE_TIMES_UP_OR_DOWN
                      5569     
                      5570     ADJUST_TIMING_TWO_STEPS: 
0C7B    E8            5571     MOV A , R0 
0C7C    28            5572     ADD A , R0 
0C7D    F8            5573     MOV R0 , A 
0C7E    E9            5574     MOV A , R1 
0C7F    39            5575     ADDC A , R1 
0C80    F9            5576     MOV R1 , A 
0C81    C3            5577     	CLR	C
0C82    E8            5578     MOV A , R0 
0C83    9402          5579     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0C85    F8            5580     MOV R0 , A 
0C86    E9            5581     MOV A , R1 
0C87    9400          5582     	SUBB	A, #0
0C89    F9            5583     MOV R1 , A 
0C8A    7A02          5584     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0C8C    E4            5585     	CLR	A
0C8D    FB            5586     MOV R3 , A 
                      5587     
                      5588     STORE_TIMES_UP_OR_DOWN: 
0C8E    C3            5589     	CLR	C
0C8F    EF            5590     MOV A , R7 
0C90    9403          5591     	SUBB	A, #3				; Is timing higher than normal?
0C92    400D          5592     	JC	STORE_TIMES_DECREASE	; No - branch
                      5593     
                      5594     STORE_TIMES_INCREASE: 
0C94    8A4E          5595     MOV WT_COMM_L , R2 
0C96    8B4F          5596     MOV WT_COMM_H , R3 
0C98    8848          5597     MOV WT_ADVANCE_L , R0 
0C9A    8949          5598     MOV WT_ADVANCE_H , R1 
0C9C    8C4A          5599     MOV WT_ZC_SCAN_L , R4 
0C9E    8D4B          5600     MOV WT_ZC_SCAN_H , R5 
0CA0    22            5601     	RET
                      5602     
                      5603     STORE_TIMES_DECREASE: 
0CA1    884E          5604     MOV WT_COMM_L , R0 
0CA3    894F          5605     MOV WT_COMM_H , R1 
0CA5    8A48          5606     MOV WT_ADVANCE_L , R2 
0CA7    8B49          5607     MOV WT_ADVANCE_H , R3 
0CA9    8C4A          5608     MOV WT_ZC_SCAN_L , R4 
0CAB    8D4B          5609     MOV WT_ZC_SCAN_H , R5 
0CAD    22            5610     	RET
                      5611     
                      5612     
                      5613     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5614     ;
                      5615     ; Wait before zero cross scan routine
                      5616     ;
                      5617     ; No assumptions
                      5618     ;
                      5619     ; Waits for the zero cross scan wait time to elapse
                      5620     ; Also sets up timer 3 for the zero cross scan timeout time
                      5621     ;
                      5622     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5623     WAIT_BEFORE_ZC_SCAN: 	
0CAE    306002        5624     JNB FLAGS0 . 0 , ( $+5 ) 
0CB1    81AE          5625     	AJMP	WAIT_BEFORE_ZC_SCAN
                      5626     
0CB3    D260          5627     SETB FLAGS0 . 0 
0CB5    43E680        5628     	ORL	EIE1, #80H			; Enable timer3 interrupts
0CB8    E52D          5629     	MOV	A, FLAGS1
0CBA    5406          5630     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0CBC    6027          5631     	JZ	WAIT_BEFORE_ZC_EXIT		
                      5632     
0CBE    A83A          5633     MOV R0 , COMM_PERIOD4X_L 
0CC0    A93B          5634     MOV R1 , COMM_PERIOD4X_H 
                      5635     	; Break deadlock cyclic patterns during startup
0CC2    E534          5636     	MOV	A, STARTUP_OK_CNT
0CC4    9408          5637     	SUBB	A, #8
0CC6    5006          5638     	JNC	WAIT_BEFORE_ZC_RANDOM_DONE
                      5639     
0CC8    E8            5640     MOV A , R0 
0CC9    20E002        5641     	JB	ACC.0, WAIT_BEFORE_ZC_RANDOM_DONE	; Use LSB as a random number
                      5642     
0CCC    A94D          5643     MOV R1 , WT_ZC_TIMEOUT_H 
                      5644     
                      5645     WAIT_BEFORE_ZC_RANDOM_DONE: 
                      5646     IF MCU_50MHZ == 1
                               	CLR	C
                               	MOV	A, TEMP1
                               	RLC	A
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	RLC	A
                               	MOV	TEMP2, A
                               ENDIF
0CCE    759100        5655     	MOV	TMR3CN, #00H			; Timer3 disabled
0CD1    C3            5656     	CLR	C
0CD2    E4            5657     	CLR	A
0CD3    98            5658     SUBB A , R0 
0CD4    F594          5659     	MOV	TMR3L, A
0CD6    E4            5660     	CLR	A
0CD7    99            5661     SUBB A , R1 
0CD8    F595          5662     	MOV	TMR3H, A
0CDA    759104        5663     	MOV	TMR3CN, #04H			; Timer3 enabled
0CDD    D260          5664     SETB FLAGS0 . 0 
0CDF    53917F        5665     	ANL	TMR3CN, #07FH			; Clear interrupt flag
0CE2    43E680        5666     	ORL	EIE1, #80H			; Enable timer3 interrupts
                      5667     
                      5668     WAIT_BEFORE_ZC_EXIT: 
0CE5    22            5669     	RET
                      5670     
                      5671     
                      5672     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5673     ;
                      5674     ; Wait for comparator to go low/high routines
                      5675     ;
                      5676     ; No assumptions
                      5677     ;
                      5678     ; Waits for the zero cross scan wait time to elapse
                      5679     ; Then scans for comparator going low/high
                      5680     ;
                      5681     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5682     WAIT_FOR_COMP_OUT_LOW: 
0CE6    D265          5683     SETB FLAGS0 . 5 
0CE8    753D00        5684     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0CEB    752000        5685     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0CEE    020CF9        5686     	JMP	WAIT_FOR_COMP_OUT_START
                      5687     
                      5688     WAIT_FOR_COMP_OUT_HIGH: 
0CF1    D265          5689     SETB FLAGS0 . 5 
0CF3    753D00        5690     	MOV	COMPARATOR_READ_CNT, #0		; Reset number of comparator reads
0CF6    752040        5691     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      5692     
                      5693     WAIT_FOR_COMP_OUT_START: 
0CF9    E52D          5694     	MOV	A, FLAGS1					; Clear demag detected flag if start phases
0CFB    5406          5695     	ANL	A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0CFD    6002          5696     	JZ	($+4)
                      5697     		
0CFF    C265          5698     CLR FLAGS0 . 5 
                      5699     
0D01    D2AF          5700     	SETB	EA						; Enable interrupts
0D03    206005        5701     JB FLAGS0 . 0 , WAIT_FOR_COMP_OUT_NOT_TIMED_OUT 
                      5702     
0D06    E53D          5703     	MOV	A, COMPARATOR_READ_CNT		; Check that comparator has been read
0D08    6001          5704     	JZ	WAIT_FOR_COMP_OUT_NOT_TIMED_OUT	; If not read - branch
                      5705     
0D0A    22            5706     	RET							; Return
                      5707     
                      5708     
                      5709     WAIT_FOR_COMP_OUT_NOT_TIMED_OUT: 
                      5710     	; Set number of comparator readings
0D0B    7801          5711     MOV R0 , # 1 
0D0D    7A02          5712     MOV R2 , # 2 
0D0F    C3            5713     	CLR	C						; Set number of readings higher for lower speeds
0D10    E53B          5714     	MOV 	A, COMM_PERIOD4X_H			
0D12    9405          5715     	SUBB	A, #05H
0D14    4002          5716     	JC	($+4)
                      5717     
0D16    7802          5718     MOV R0 , # 2 
                      5719     
0D18    C3            5720     	CLR	C
0D19    E53B          5721     	MOV 	A, COMM_PERIOD4X_H			
0D1B    940A          5722     	SUBB	A, #0AH
0D1D    4002          5723     	JC	($+4)
                      5724     
0D1F    7803          5725     MOV R0 , # 3 
                      5726     
0D21    C3            5727     	CLR	C						; Set number of consecutive readings higher for lower speeds
0D22    E53B          5728     	MOV 	A, COMM_PERIOD4X_H			
0D24    940F          5729     	SUBB	A, #0FH
0D26    4002          5730     	JC	($+4)
                      5731     
0D28    7A03          5732     MOV R2 , # 3 
                      5733     
0D2A    306904        5734     JNB FLAGS1 . 1 , COMP_WAIT_ON_COMP_ABLE 
                      5735     
0D2D    781E          5736     MOV R0 , # 30 
0D2F    7A01          5737     MOV R2 , # 1 
                      5738     
                      5739     COMP_WAIT_ON_COMP_ABLE: 
0D31    206007        5740     JB FLAGS0 . 0 , COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT 
                      5741     
0D34    E53D          5742     	MOV	A, COMPARATOR_READ_CNT			; Check that comparator has been read
0D36    6003          5743     	JZ	COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT	; If not read - branch
                      5744     
0D38    D2AF          5745     	SETB	EA							; Enable interrupts
0D3A    22            5746     	RET								; Yes - return
                      5747     
                      5748     
                      5749     COMP_WAIT_ON_COMP_ABLE_NOT_TIMED_OUT: 
0D3B    D2AF          5750     	SETB	EA							; Enable interrupts
0D3D    00            5751     	NOP								; Allocate only just enough time to capture interrupt
0D3E    00            5752     	NOP
0D3F    C2AF          5753     	CLR	EA							; Disable interrupts
0D41    C3            5754     	CLR	C
0D42    E53B          5755     	MOV	A, COMM_PERIOD4X_H				; Reduce required distance to pwm transition for higher speeds
0D44    FB            5756     MOV R3 , A 
0D45    940F          5757     	SUBB	A, #0FH
0D47    4002          5758     	JC	($+4)
                      5759     
0D49    7B0F          5760     MOV R3 , # 0FH 
                      5761     
0D4B    EB            5762     MOV A , R3 
0D4C    04            5763     	INC	A
0D4D    307301        5764     JNB FLAGS2 . 3 , ( $+4 ) 
                      5765     
0D50    23            5766     	RL	A
                      5767     
0D51    206201        5768     JB FLAGS0 . 2 , ( $+4 ) 
                      5769     
0D54    23            5770     	RL	A
                      5771     
0D55    F9            5772     MOV R1 , A 
0D56    306902        5773     JNB FLAGS1 . 1 , ( $+5 ) 
                      5774     
0D59    7982          5775     MOV R1 , # 130 
                      5776     
                      5777     IF MCU_50MHZ == 0
0D5B    E58B          5778     	MOV	A, TL1
                      5779     ELSE
                               	MOV	A, TH1
                               	RRC	A
                               	MOV	A, TL1
                               	RRC	A
                               ENDIF
0D5D    C3            5785     	CLR	C
0D5E    99            5786     SUBB A , R1 
0D5F    40D0          5787     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle
                      5788     
0D61    053D          5789     	INC	COMPARATOR_READ_CNT			; Increment comparator read count
0D63    EA            5790     MOV A , R2 
0D64    FB            5791     MOV R3 , A 
                      5792     READ_COMP_LOOP: 
                      5793     	READ_COMP_OUT					; Read comparator output
0D65    E59B          5793+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0D67    5440          5794     	ANL	A, #40H
0D69    B52004        5795     	CJNE	A, BIT_ACCESS, COMP_READ_WRONG
0D6C    DBF7          5796     DJNZ R3 , READ_COMP_LOOP 
0D6E    A194          5797     	AJMP	COMP_READ_OK
                      5798     	
                      5799     COMP_READ_WRONG: 
0D70    206502        5800     JB FLAGS0 . 5 , ( $+5 ) 
0D73    81F9          5801     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct, and timeout already extended - go back and restart
                      5802     
0D75    C265          5803     CLR FLAGS0 . 5 
0D77    759100        5804     	MOV	TMR3CN, #00H				; Timer3 disabled
0D7A    AE3A          5805     MOV R6 , COMM_PERIOD4X_L 
0D7C    AF3B          5806     MOV R7 , COMM_PERIOD4X_H 
                      5807     IF MCU_50MHZ == 1
                               	CLR	C
                               	MOV	A, TEMP7
                               	RLC	A
                               	MOV	TEMP7, A
                               	MOV	A, TEMP8
                               	RLC	A
                               	MOV	TEMP8, A
                               ENDIF
0D7E    C3            5816     	CLR	C
0D7F    E4            5817     	CLR	A
0D80    9E            5818     SUBB A , R6 
0D81    F594          5819     	MOV	TMR3L, A
0D83    E4            5820     	CLR	A
0D84    9F            5821     SUBB A , R7 
0D85    F595          5822     	MOV	TMR3H, A
0D87    759104        5823     	MOV	TMR3CN, #04H				; Timer3 enabled
0D8A    D260          5824     SETB FLAGS0 . 0 
0D8C    53917F        5825     	ANL	TMR3CN, #07FH				; Clear interrupt flag in case there are pending interrupts
0D8F    43E680        5826     	ORL	EIE1, #80H				; Enable timer3 interrupts
0D92    81F9          5827     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      5828     
                      5829     COMP_READ_OK: 
0D94    306502        5830     JNB FLAGS0 . 5 , ( $+5 ) 
0D97    81F9          5831     	AJMP	WAIT_FOR_COMP_OUT_START
                      5832     
0D99    D896          5833     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      5834     
0D9B    D2AF          5835     	SETB	EA						; Enable interrupts
0D9D    22            5836     	RET							
                      5837     
                      5838     
                      5839     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5840     ;
                      5841     ; Evaluate comparator integrity
                      5842     ;
                      5843     ; No assumptions
                      5844     ;
                      5845     ; Checks comparator signal behaviour versus expected behaviour
                      5846     ;
                      5847     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5848     EVALUATE_COMPARATOR_INTEGRITY: 
0D9E    30690B        5849     JNB FLAGS1 . 1 , EVAL_COMP_CHECK_TIMEOUT 
                      5850     
0DA1    0534          5851     	INC	STARTUP_OK_CNT					; Increment ok counter
0DA3    206016        5852     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      5853     
0DA6    753400        5854     	MOV	STARTUP_OK_CNT, #0				; Reset ok counter
0DA9    020DBC        5855     	JMP	EVAL_COMP_EXIT
                      5856     
                      5857     EVAL_COMP_CHECK_TIMEOUT: 
0DAC    20600D        5858     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0DAF    20650A        5859     JB FLAGS0 . 5 , EVAL_COMP_EXIT 
0DB2    206B07        5860     JB FLAGS1 . 3 , EVAL_COMP_EXIT 
0DB5    1581          5861     	DEC	SP							; Routine exit without "ret" command
0DB7    1581          5862     	DEC	SP
0DB9    02163D        5863     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      5864     
                      5865     EVAL_COMP_EXIT: 
0DBC    22            5866     	RET
                      5867     
                      5868     
                      5869     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5870     ;
                      5871     ; Setup commutation timing routine
                      5872     ;
                      5873     ; No assumptions
                      5874     ;
                      5875     ; Sets up and starts wait from commutation to zero cross
                      5876     ;
                      5877     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5878     SETUP_COMM_WAIT:  
0DBD    A84E          5879     MOV R0 , WT_COMM_L 
0DBF    A94F          5880     MOV R1 , WT_COMM_H 
                      5881     IF MCU_50MHZ == 1
                               	CLR	C
                               	MOV	A, TEMP1
                               	RLC	A
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	RLC	A
                               	MOV	TEMP2, A
                               ENDIF
0DC1    759100        5890     	MOV	TMR3CN, #00H		; Timer3 disabled
0DC4    53917F        5891     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0DC7    C3            5892     	CLR	C
0DC8    E4            5893     	CLR	A
0DC9    98            5894     SUBB A , R0 
0DCA    F594          5895     	MOV	TMR3L, A
0DCC    E4            5896     	CLR	A
0DCD    99            5897     SUBB A , R1 
0DCE    F595          5898     	MOV	TMR3H, A
0DD0    759104        5899     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5900     	; Setup next wait time
0DD3    854850        5901     	MOV	NEXT_WT_L, WT_ADVANCE_L
0DD6    854951        5902     	MOV	NEXT_WT_H, WT_ADVANCE_H
0DD9    D260          5903     SETB FLAGS0 . 0 
0DDB    43E680        5904     	ORL	EIE1, #80H		; Enable timer3 interrupts
0DDE    22            5905     	RET
                      5906     
                      5907     
                      5908     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5909     ;
                      5910     ; Wait for commutation routine
                      5911     ;
                      5912     ; No assumptions
                      5913     ;
                      5914     ; Waits from zero cross to commutation 
                      5915     ;
                      5916     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5917     WAIT_FOR_COMM:  
                      5918     	; Update demag metric
0DDF    7800          5919     MOV R0 , # 0 
0DE1    306405        5920     JNB FLAGS0 . 4 , ( $+8 ) 
0DE4    306502        5921     JNB FLAGS0 . 5 , ( $+5 ) 
                      5922     
0DE7    7801          5923     MOV R0 , # 1 
                      5924     
0DE9    E535          5925     	MOV	A, DEMAG_DETECTED_METRIC	; Sliding average of 8, 256 when demag and 0 when not. Limited to minimum 120
0DEB    75F007        5926     	MOV	B, #7
0DEE    A4            5927     	MUL	AB					; Multiply by 7
0DEF    F9            5928     MOV R1 , A 
0DF0    E5F0          5929     	MOV	A, B					; Add new value for current demag status
0DF2    28            5930     ADD A , R0 
0DF3    F5F0          5931     	MOV	B, A
0DF5    E9            5932     MOV A , R1 
0DF6    A2F0          5933     	MOV	C, B.0				; Divide by 8
0DF8    13            5934     	RRC	A					
0DF9    A2F1          5935     	MOV	C, B.1
0DFB    13            5936     	RRC	A
0DFC    A2F2          5937     	MOV	C, B.2
0DFE    13            5938     	RRC	A
0DFF    F535          5939     	MOV	DEMAG_DETECTED_METRIC, A
0E01    C3            5940     	CLR	C
0E02    9478          5941     	SUBB	A, #120				; Limit to minimum 120
0E04    5003          5942     	JNC	($+5)
                      5943     
0E06    753578        5944     	MOV	DEMAG_DETECTED_METRIC, #120
                      5945     
0E09    C3            5946     	CLR	C
0E0A    E535          5947     	MOV	A, DEMAG_DETECTED_METRIC	; Check demag metric
0E0C    9536          5948     	SUBB	A, DEMAG_PWR_OFF_THRESH
0E0E    4008          5949     	JC	WAIT_FOR_COMM_WAIT		; Cut power if many consecutive demags. This will help retain sync during hard accelerations
                      5950     
0E10    D266          5951     SETB FLAGS0 . 6 
                      5952     	ALL_NFETS_OFF
0E12    D291          5952+1   SETB P1 . 1 
0E14    D293          5952+1   SETB P1 . 3 
0E16    D295          5952+1   SETB P1 . 5 
                      5953     
                      5954     WAIT_FOR_COMM_WAIT: 
0E18    306002        5955     JNB FLAGS0 . 0 , ( $+5 ) 
0E1B    C118          5956     	AJMP	WAIT_FOR_COMM_WAIT					
                      5957     
                      5958     	; Setup next wait time
0E1D    854A50        5959     	MOV	NEXT_WT_L, WT_ZC_SCAN_L
0E20    854B51        5960     	MOV	NEXT_WT_H, WT_ZC_SCAN_H
0E23    D260          5961     SETB FLAGS0 . 0 
0E25    43E680        5962     	ORL	EIE1, #80H			; Enable timer3 interrupts
0E28    22            5963     	RET
                      5964     
                      5965     
                      5966     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5967     ;
                      5968     ; Commutation routines
                      5969     ;
                      5970     ; No assumptions
                      5971     ;
                      5972     ; Performs commutation switching 
                      5973     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      5974     ;
                      5975     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5976     COMM1COMM2: 	
                      5977     	SET_RPM_OUT
0E29    C2AF          5978     	CLR 	EA					; Disable all interrupts
                      5979     	ALL_PFETS_OFF				; All pfets off
0E2B    C290          5979+1   CLR P1 . 0 
0E2D    C292          5979+1   CLR P1 . 2 
0E2F    C294          5979+1   CLR P1 . 4 
0E31    30720B        5980     JNB FLAGS2 . 2 , COMM12_NONDAMP 
0E34    9001FF        5981     	MOV	DPTR, #PWM_CNFET_APFET_ON	
0E37    7428          5982     MOV A , # 40 
0E39    D5E0FD        5983     	DJNZ ACC,	$
0E3C    020E3F        5984     	JMP	COMM12_PRECH_DONE		; Do not do precharge when running damped
                      5985     COMM12_NONDAMP: 
                      5986     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	MOV	A, COMM_PERIOD4X_H
                               	ANL	A, #0F8H				; Check if comm period is less than 8
                               	JZ	COMM12_PRECH_DONE
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      5997     COMM12_PRECH_DONE: 
                      5998     	APFET_ON					; Ap on
0E3F    207D02        5998+1   JB FLAGS3 . 5 , ( $+5 ) 
0E42    D290          5998+1   SETB P1 . 0 
0E44    307D02        5998+1   JNB FLAGS3 . 5 , ( $+5 ) 
0E47    D294          5998+1   SETB P1 . 4 
                      5999     	SET_COMP_PHASE_B 			; Set comparator to phase B
0E49    759F10        5999+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E4C    753C02        6000     	MOV	COMM_PHASE, #2
0E4F    020F7E        6001     	JMP	COMM_EXIT
                      6002     
                      6003     COMM2COMM3: 	
                      6004     	CLEAR_RPM_OUT
0E52    C2AF          6005     	CLR 	EA					; Disable all interrupts
                      6006     	CNFET_OFF					; Cn off
0E54    207D02        6006+1   JB FLAGS3 . 5 , ( $+5 ) 
0E57    D295          6006+1   SETB P1 . 5 
0E59    307D02        6006+1   JNB FLAGS3 . 5 , ( $+5 ) 
0E5C    D291          6006+1   SETB P1 . 1 
0E5E    307217        6007     JNB FLAGS2 . 2 , COMM23_NONDAMP 
0E61    9001DC        6008     	MOV	DPTR, #PWM_BNFET_APFET_ON	
                      6009     	BPFET_OFF				
0E64    C292          6009+1   CLR P1 . 2 
                      6010     	CPFET_OFF				
0E66    207D02        6010+1   JB FLAGS3 . 5 , ( $+5 ) 
0E69    C294          6010+1   CLR P1 . 4 
0E6B    307D02        6010+1   JNB FLAGS3 . 5 , ( $+5 ) 
0E6E    C290          6010+1   CLR P1 . 0 
0E70    7428          6011     MOV A , # 40 
0E72    D5E0FD        6012     	DJNZ ACC,	$
0E75    020E7B        6013     	JMP	COMM23_NFET
                      6014     COMM23_NONDAMP: 
0E78    90013F        6015     	MOV	DPTR, #PWM_BFET_ON	
                      6016     COMM23_NFET: 
0E7B    306206        6017     JNB FLAGS0 . 2 , COMM23_CP 
                      6018     	BNFET_ON					; Yes - Bn on
0E7E    E525          6018+1   MOV A , CURRENT_PWM_LIMITED 
0E80    6002          6018+1   JZ ( $+4 ) 
0E82    C293          6018+1   CLR P1 . 3 
                      6019     COMM23_CP: 
                      6020     	SET_COMP_PHASE_C 			; Set comparator to phase C
0E84    207D03        6020+1   JB FLAGS3 . 5 , ( $+6 ) 
0E87    759F13        6020+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0E8A    307D03        6020+1   JNB FLAGS3 . 5 , ( $+6 ) 
0E8D    759F11        6020+1   MOV CPT0MX , # 11H 
0E90    753C03        6021     	MOV	COMM_PHASE, #3
0E93    020F7E        6022     	JMP	COMM_EXIT
                      6023     
                      6024     COMM3COMM4: 	
0E96    C2AF          6025     	CLR 	EA					; Disable all interrupts
                      6026     	ALL_PFETS_OFF				; All pfets off
0E98    C290          6026+1   CLR P1 . 0 
0E9A    C292          6026+1   CLR P1 . 2 
0E9C    C294          6026+1   CLR P1 . 4 
0E9E    30720B        6027     JNB FLAGS2 . 2 , COMM34_NONDAMP 
0EA1    9001B9        6028     	MOV	DPTR, #PWM_BNFET_CPFET_ON
0EA4    7428          6029     MOV A , # 40 
0EA6    D5E0FD        6030     	DJNZ ACC,	$
0EA9    020EAC        6031     	JMP	COMM34_PRECH_DONE		; Do not do precharge when running damped
                      6032     COMM34_NONDAMP: 
                      6033     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	MOV	A, COMM_PERIOD4X_H
                               	ANL	A, #0F8H				; Check if comm period is less than 8
                               	JZ	COMM34_PRECH_DONE
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      6044     COMM34_PRECH_DONE: 
                      6045     	CPFET_ON					; Cp on
0EAC    207D02        6045+1   JB FLAGS3 . 5 , ( $+5 ) 
0EAF    D294          6045+1   SETB P1 . 4 
0EB1    307D02        6045+1   JNB FLAGS3 . 5 , ( $+5 ) 
0EB4    D290          6045+1   SETB P1 . 0 
                      6046     	SET_COMP_PHASE_A 			; Set comparator to phase A
0EB6    207D03        6046+1   JB FLAGS3 . 5 , ( $+6 ) 
0EB9    759F11        6046+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0EBC    307D03        6046+1   JNB FLAGS3 . 5 , ( $+6 ) 
0EBF    759F13        6046+1   MOV CPT0MX , # 13H 
0EC2    753C04        6047     	MOV	COMM_PHASE, #4
0EC5    020F7E        6048     	JMP	COMM_EXIT
                      6049     
                      6050     COMM4COMM5: 	
0EC8    C2AF          6051     	CLR 	EA					; Disable all interrupts
                      6052     	BNFET_OFF					; Bn off
0ECA    D293          6052+1   SETB P1 . 3 
0ECC    307217        6053     JNB FLAGS2 . 2 , COMM45_NONDAMP 
0ECF    900196        6054     	MOV	DPTR, #PWM_ANFET_CPFET_ON
                      6055     	APFET_OFF				
0ED2    207D02        6055+1   JB FLAGS3 . 5 , ( $+5 ) 
0ED5    C290          6055+1   CLR P1 . 0 
0ED7    307D02        6055+1   JNB FLAGS3 . 5 , ( $+5 ) 
0EDA    C294          6055+1   CLR P1 . 4 
                      6056     	BPFET_OFF				
0EDC    C292          6056+1   CLR P1 . 2 
0EDE    7428          6057     MOV A , # 40 
0EE0    D5E0FD        6058     	DJNZ ACC,	$
0EE3    020EE9        6059     	JMP	COMM45_NFET
                      6060     COMM45_NONDAMP: 
0EE6    90012D        6061     	MOV	DPTR, #PWM_AFET_ON
                      6062     COMM45_NFET: 
0EE9    30620E        6063     JNB FLAGS0 . 2 , COMM45_CP 
                      6064     	ANFET_ON					; Yes - An on
0EEC    E525          6064+1   MOV A , CURRENT_PWM_LIMITED 
0EEE    600A          6064+1   JZ ( $+12 ) 
0EF0    207D02        6064+1   JB FLAGS3 . 5 , ( $+5 ) 
0EF3    C291          6064+1   CLR P1 . 1 
0EF5    307D02        6064+1   JNB FLAGS3 . 5 , ( $+5 ) 
0EF8    C295          6064+1   CLR P1 . 5 
                      6065     COMM45_CP: 
                      6066     	SET_COMP_PHASE_B 			; Set comparator to phase B
0EFA    759F10        6066+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EFD    753C05        6067     	MOV	COMM_PHASE, #5
0F00    020F7E        6068     	JMP	COMM_EXIT
                      6069     
                      6070     COMM5COMM6: 	
0F03    C2AF          6071     	CLR 	EA					; Disable all interrupts
                      6072     	ALL_PFETS_OFF				; All pfets off
0F05    C290          6072+1   CLR P1 . 0 
0F07    C292          6072+1   CLR P1 . 2 
0F09    C294          6072+1   CLR P1 . 4 
0F0B    30720B        6073     JNB FLAGS2 . 2 , COMM56_NONDAMP 
0F0E    90016B        6074     	MOV	DPTR, #PWM_ANFET_BPFET_ON
0F11    7428          6075     MOV A , # 40 
0F13    D5E0FD        6076     	DJNZ ACC,	$
0F16    020F19        6077     	JMP	COMM56_PRECH_DONE		; Do not do precharge when running damped
                      6078     COMM56_NONDAMP: 
                      6079     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	MOV	A, COMM_PERIOD4X_H
                               	ANL	A, #0F8H				; Check if comm period is less than 8
                               	JZ	COMM56_PRECH_DONE
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      6090     COMM56_PRECH_DONE: 
                      6091     	BPFET_ON					; Bp on
0F19    D292          6091+1   SETB P1 . 2 
                      6092     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F1B    207D03        6092+1   JB FLAGS3 . 5 , ( $+6 ) 
0F1E    759F13        6092+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F21    307D03        6092+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F24    759F11        6092+1   MOV CPT0MX , # 11H 
0F27    753C06        6093     	MOV	COMM_PHASE, #6
0F2A    020F7E        6094     	JMP	COMM_EXIT
                      6095     
                      6096     COMM6COMM1: 	
0F2D    C2AF          6097     	CLR 	EA					; Disable all interrupts
                      6098     	ANFET_OFF					; An off
0F2F    207D02        6098+1   JB FLAGS3 . 5 , ( $+5 ) 
0F32    D291          6098+1   SETB P1 . 1 
0F34    307D02        6098+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F37    D295          6098+1   SETB P1 . 5 
0F39    30721F        6099     JNB FLAGS2 . 2 , COMM61_NONDAMP 
0F3C    90022A        6100     	MOV	DPTR, #PWM_CNFET_BPFET_ON
                      6101     	APFET_OFF				
0F3F    207D02        6101+1   JB FLAGS3 . 5 , ( $+5 ) 
0F42    C290          6101+1   CLR P1 . 0 
0F44    307D02        6101+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F47    C294          6101+1   CLR P1 . 4 
                      6102     	CPFET_OFF				
0F49    207D02        6102+1   JB FLAGS3 . 5 , ( $+5 ) 
0F4C    C294          6102+1   CLR P1 . 4 
0F4E    307D02        6102+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F51    C290          6102+1   CLR P1 . 0 
0F53    7428          6103     MOV A , # 40 
0F55    D5E0FD        6104     	DJNZ ACC,	$
0F58    020F5E        6105     	JMP	COMM61_NFET
                      6106     COMM61_NONDAMP: 
0F5B    900151        6107     	MOV	DPTR, #PWM_CFET_ON
                      6108     COMM61_NFET: 
0F5E    30620E        6109     JNB FLAGS0 . 2 , COMM61_CP 
                      6110     	CNFET_ON					; Yes - Cn on
0F61    E525          6110+1   MOV A , CURRENT_PWM_LIMITED 
0F63    600A          6110+1   JZ ( $+12 ) 
0F65    207D02        6110+1   JB FLAGS3 . 5 , ( $+5 ) 
0F68    C295          6110+1   CLR P1 . 5 
0F6A    307D02        6110+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F6D    C291          6110+1   CLR P1 . 1 
                      6111     COMM61_CP: 
                      6112     	SET_COMP_PHASE_A 			; Set comparator to phase A
0F6F    207D03        6112+1   JB FLAGS3 . 5 , ( $+6 ) 
0F72    759F11        6112+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F75    307D03        6112+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F78    759F13        6112+1   MOV CPT0MX , # 13H 
0F7B    753C01        6113     	MOV	COMM_PHASE, #1
                      6114     
                      6115     COMM_EXIT: 
                      6116     IF MODE >= 1	; Tail or multi
0F7E    306B13        6117     JNB FLAGS1 . 3 , COMM_DIR_CHANGE_DONE 
                      6118     
0F81    120F99        6119     	CALL	SWITCH_POWER_OFF		; Switch off power
0F84    7428          6120     MOV A , # 40 
0F86    D5E0FD        6121     	DJNZ ACC,	$
0F89    7401          6122     MOV A , # 1 
0F8B    D5E0FD        6123     	DJNZ ACC,	$
                      6124     	ALL_PFETS_ON				; All pfets on - Break
0F8E    D290          6124+1   SETB P1 . 0 
0F90    D292          6124+1   SETB P1 . 2 
0F92    D294          6124+1   SETB P1 . 4 
                      6125     
                      6126     COMM_DIR_CHANGE_DONE: 
                      6127     ENDIF
0F94    C266          6128     CLR FLAGS0 . 6 
0F96    D2AF          6129     	SETB	EA					; Enable all interrupts
0F98    22            6130     	RET
                      6131     
                      6132     
                      6133     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6134     ;
                      6135     ; Switch power off routine
                      6136     ;
                      6137     ; No assumptions
                      6138     ;
                      6139     ; Switches all fets off 
                      6140     ;
                      6141     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6142     SWITCH_POWER_OFF: 
0F99    90012B        6143     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      6144     	ALL_NFETS_OFF			; Turn off all nfets
0F9C    D291          6144+1   SETB P1 . 1 
0F9E    D293          6144+1   SETB P1 . 3 
0FA0    D295          6144+1   SETB P1 . 5 
                      6145     	ALL_PFETS_OFF			; Turn off all pfets
0FA2    C290          6145+1   CLR P1 . 0 
0FA4    C292          6145+1   CLR P1 . 2 
0FA6    C294          6145+1   CLR P1 . 4 
0FA8    C262          6146     CLR FLAGS0 . 2 
0FAA    22            6147     	RET			
                      6148     
                      6149     
                      6150     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6151     ;
                      6152     ; Set default parameters
                      6153     ;
                      6154     ; No assumptions
                      6155     ;
                      6156     ; Sets default programming parameters
                      6157     ;
                      6158     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6159     SET_DEFAULT_PARAMETERS: 
                      6160     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_SPOOLUP_TIME
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               ENDIF
                      6225     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup rpm	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup accel
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Damping force	
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Startup method	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	; Throttle rate	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0FFH	
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                               ENDIF
                      6290     IF MODE == 2	; Multi
0FAB    7880          6291     MOV R0 , # PGM_GOV_P_GAIN 
0FAD    7609          6292     MOV @ R0 , # 9 
0FAF    08            6293     INC R0 
0FB0    7609          6294     MOV @ R0 , # 9 
0FB2    08            6295     INC R0 
0FB3    7604          6296     MOV @ R0 , # 4 
0FB5    08            6297     INC R0 
0FB6    7601          6298     MOV @ R0 , # 1 
0FB8    08            6299     INC R0 
0FB9    7603          6300     MOV @ R0 , # 3 
0FBB    08            6301     INC R0 
0FBC    76FF          6302     MOV @ R0 , # 0FFH 
0FBE    08            6303     INC R0 
0FBF    760B          6304     MOV @ R0 , # 11 
0FC1    08            6305     INC R0 
0FC2    7601          6306     MOV @ R0 , # 1 
0FC4    08            6307     INC R0 
0FC5    7601          6308     MOV @ R0 , # 1 
0FC7    08            6309     INC R0 
0FC8    7601          6310     MOV @ R0 , # 1 
                      6311     
0FCA    788C          6312     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
0FCC    7600          6313     MOV @ R0 , # 0 
0FCE    08            6314     INC R0 
0FCF    76FF          6315     MOV @ R0 , # 0FFH 
0FD1    08            6316     INC R0 
0FD2    76FF          6317     MOV @ R0 , # 0FFH 
0FD4    08            6318     INC R0 
0FD5    76FF          6319     MOV @ R0 , # 0FFH 
0FD7    08            6320     INC R0 
0FD8    76FF          6321     MOV @ R0 , # 0FFH 
0FDA    08            6322     INC R0 
0FDB    76FF          6323     MOV @ R0 , # 0FFH 
0FDD    08            6324     INC R0 
0FDE    7603          6325     MOV @ R0 , # 3 
0FE0    08            6326     INC R0 
0FE1    76FF          6327     MOV @ R0 , # 0FFH 
0FE3    08            6328     INC R0 
0FE4    76FF          6329     MOV @ R0 , # 0FFH 
0FE6    08            6330     INC R0 
0FE7    76FF          6331     MOV @ R0 , # 0FFH 
0FE9    08            6332     INC R0 
0FEA    7603          6333     MOV @ R0 , # 3 
0FEC    08            6334     INC R0 
0FED    76FA          6335     MOV @ R0 , # 250 
0FEF    08            6336     INC R0 
0FF0    76C8          6337     MOV @ R0 , # 200 
0FF2    08            6338     INC R0 
0FF3    7650          6339     MOV @ R0 , # 80 
0FF5    08            6340     INC R0 
0FF6    7605          6341     MOV @ R0 , # 5 
0FF8    08            6342     INC R0 
0FF9    76FF          6343     MOV @ R0 , # 0FFH 
0FFB    08            6344     INC R0 
0FFC    7602          6345     MOV @ R0 , # 2 
0FFE    08            6346     INC R0 
0FFF    7600          6347     MOV @ R0 , # 0 
1001    08            6348     INC R0 
1002    767D          6349     MOV @ R0 , # 125 
1004    08            6350     INC R0 
1005    76FF          6351     MOV @ R0 , # 0FFH 
1007    08            6352     INC R0 
1008    7600          6353     MOV @ R0 , # 0 
                      6354     ENDIF
100A    22            6355     	RET
                      6356     
                      6357     
                      6358     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6359     ;
                      6360     ; Decode parameters
                      6361     ;
                      6362     ; No assumptions
                      6363     ;
                      6364     ; Decodes programming parameters
                      6365     ;
                      6366     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6367     DECODE_PARAMETERS: 
                      6368     	; Load programmed pwm frequency
100B    7887          6369     MOV R0 , # PGM_PWM_FREQ 
100D    E6            6370     MOV A , @ R0 
100E    FF            6371     MOV R7 , A 
100F    C272          6372     CLR FLAGS2 . 2 
                      6373     IF DAMPED_MODE_ENABLE == 1
1011    BF0302        6374     CJNE R7 , # 3 , ( $+5 ) 
1014    D272          6375     SETB FLAGS2 . 2 
                      6376     ENDIF
                      6377     	; Load programmed direction
1016    7888          6378     MOV R0 , # PGM_DIRECTION 
                      6379     IF MODE >= 1	; Tail or multi
1018    E6            6380     MOV A , @ R0 
1019    C3            6381     	CLR	C
101A    9403          6382     	SUBB	A, #3
101C    6008          6383     	JZ	DECODE_PARAMS_DIR_SET
                      6384     ENDIF
                      6385     
101E    C27D          6386     CLR FLAGS3 . 5 
1020    E6            6387     MOV A , @ R0 
1021    30E102        6388     	JNB	ACC.1, ($+5)
1024    D27D          6389     SETB FLAGS3 . 5 
                      6390     DECODE_PARAMS_DIR_SET: 
1026    C27E          6391     CLR FLAGS3 . 6 
1028    7889          6392     MOV R0 , # PGM_INPUT_POL 
102A    E6            6393     MOV A , @ R0 
102B    30E102        6394     	JNB	ACC.1, ($+5)
102E    D27E          6395     SETB FLAGS3 . 6 
1030    C3            6396     	CLR	C
1031    EF            6397     MOV A , R7 
1032    9402          6398     	SUBB	A, #2
1034    6008          6399     	JZ	DECODE_PWM_FREQ_LOW
                      6400     
1036    758E01        6401     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
1039    D273          6402     SETB FLAGS2 . 3 
103B    021043        6403     	JMP	DECODE_PWM_FREQ_END
                      6404     
                      6405     DECODE_PWM_FREQ_LOW: 
103E    758E00        6406     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
1041    C273          6407     CLR FLAGS2 . 3 
                      6408     
                      6409     DECODE_PWM_FREQ_END: 
1043    22            6410     	RET
                      6411     
                      6412     
                      6413     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6414     ;
                      6415     ; Decode governor gain
                      6416     ;
                      6417     ; No assumptions
                      6418     ;
                      6419     ; Decodes governor gains
                      6420     ;
                      6421     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6422     DECODE_GOVERNOR_GAINS: 
                      6423     	; Decode governor gains
1044    7880          6424     MOV R0 , # PGM_GOV_P_GAIN 
1046    E6            6425     MOV A , @ R0 
1047    14            6426     	DEC	A	
1048    900080        6427     	MOV	DPTR, #GOV_GAIN_TABLE
104B    93            6428     	MOVC A, @A+DPTR	
104C    78A1          6429     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
104E    F6            6430     MOV @ R0 , A 
104F    7881          6431     MOV R0 , # PGM_GOV_I_GAIN 
1051    E6            6432     MOV A , @ R0 
1052    14            6433     	DEC	A	
1053    900080        6434     	MOV	DPTR, #GOV_GAIN_TABLE
1056    93            6435     	MOVC A, @A+DPTR	
1057    78A2          6436     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1059    F6            6437     MOV @ R0 , A 
105A    120F99        6438     	CALL	SWITCH_POWER_OFF		; Reset DPTR
105D    22            6439     	RET
                      6440     
                      6441     
                      6442     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6443     ;
                      6444     ; Decode startup power
                      6445     ;
                      6446     ; No assumptions
                      6447     ;
                      6448     ; Decodes startup power
                      6449     ;
                      6450     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6451     DECODE_STARTUP_POWER: 
                      6452     	; Decode startup power
105E    7886          6453     MOV R0 , # PGM_STARTUP_PWR 
1060    E6            6454     MOV A , @ R0 
1061    14            6455     	DEC	A	
1062    90008D        6456     	MOV	DPTR, #STARTUP_POWER_TABLE
1065    93            6457     	MOVC A, @A+DPTR	
1066    78A3          6458     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1068    F6            6459     MOV @ R0 , A 
1069    120F99        6460     	CALL	SWITCH_POWER_OFF			; Reset DPTR
106C    22            6461     	RET
                      6462     
                      6463     
                      6464     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6465     ;
                      6466     ; Decode main spoolup time
                      6467     ;
                      6468     ; No assumptions
                      6469     ;
                      6470     ; Decodes main spoolup time
                      6471     ;
                      6472     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6473     DECODE_MAIN_SPOOLUP_TIME: 
                      6474     IF MODE == 0	; Main
                               	; Decode spoolup time
                               	MOV	TEMP1, #PGM_MAIN_SPOOLUP_TIME		
                               	MOV	A, @TEMP1
                               	MOV	TEMP1, A		; Store
                               	JNZ	($+3)		; If not zero - branch
                               	
                               	INC	TEMP1
                               
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, #17		; Limit to 17 max
                               	JC	($+4)
                               
                               	MOV	TEMP1, #17
                               
                               	MOV	A, TEMP1
                               	ADD	A, TEMP1
                               	ADD	A, TEMP1		; Now 3x
                               	MOV	MAIN_SPOOLUP_TIME_3X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		; Now 10x
                               	MOV	MAIN_SPOOLUP_TIME_10X, A
                               	ADD	A, MAIN_SPOOLUP_TIME_3X
                               	ADD	A, TEMP1		
                               	ADD	A, TEMP1		; Now 15x
                               	MOV	MAIN_SPOOLUP_TIME_15X, A
                               ENDIF
106D    22            6503     	RET
                      6504     
                      6505     
                      6506     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6507     ;
                      6508     ; Decode demag compensation
                      6509     ;
                      6510     ; No assumptions
                      6511     ;
                      6512     ; Decodes demag comp
                      6513     ;
                      6514     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6515     DECODE_DEMAG_COMP: 
                      6516     	; Decode demag compensation
106E    789C          6517     MOV R0 , # PGM_DEMAG_COMP 
1070    E6            6518     MOV A , @ R0 
1071    7536FF        6519     	MOV	DEMAG_PWR_OFF_THRESH, #255	; Set default
1074    75370C        6520     	MOV	LOW_RPM_PWR_SLOPE, #12		; Set default
1077    B40206        6521     	CJNE	A, #2, DECODE_DEMAG_HIGH
                      6522     
107A    7536A0        6523     	MOV	DEMAG_PWR_OFF_THRESH, #160	; Settings for demag comp low
107D    75370A        6524     	MOV	LOW_RPM_PWR_SLOPE, #10		
                      6525     
                      6526     DECODE_DEMAG_HIGH: 
1080    B40306        6527     	CJNE	A, #3, DECODE_DEMAG_DONE
                      6528     
1083    753682        6529     	MOV	DEMAG_PWR_OFF_THRESH, #130	; Settings for demag comp high
1086    753705        6530     	MOV	LOW_RPM_PWR_SLOPE, #5		
                      6531     
                      6532     DECODE_DEMAG_DONE: 
1089    22            6533     	RET
                      6534     
                      6535     
                      6536     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6537     ;
                      6538     ; Set BEC voltage
                      6539     ;
                      6540     ; No assumptions
                      6541     ;
                      6542     ; Sets the BEC output voltage low or high
                      6543     ;
                      6544     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6545     SET_BEC_VOLTAGE: 
                      6546     	; Set bec voltage
                      6547     IF HIGH_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
                      6557     IF HIGH_BEC_VOLTAGE == 2
                               	SET_BEC_0				; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	CJNE	A, #1, SET_BEC_VOLTAGE_2	
                               
                               	SET_BEC_1				; Set to level 1
                               
                               SET_BEC_VOLTAGE_2:
                               	CJNE	A, #2, SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_2				; Set to level 2
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
108A    22            6572     	RET
                      6573     
                      6574     
                      6575     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6576     ;
                      6577     ; Find throttle gain
                      6578     ;
                      6579     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      6580     ;
                      6581     ; Finds throttle gain from throttle calibration values
                      6582     ;
                      6583     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6584     FIND_THROTTLE_GAIN: 
                      6585     	; Load programmed minimum and maximum throttle
108B    7896          6586     MOV R0 , # PGM_PPM_MIN_THROTTLE 
108D    E6            6587     MOV A , @ R0 
108E    FA            6588     MOV R2 , A 
108F    7897          6589     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1091    E6            6590     MOV A , @ R0 
1092    FB            6591     MOV R3 , A 
                      6592     	; Check if full range is chosen
1093    307F04        6593     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      6594     
1096    7A00          6595     MOV R2 , # 0 
1098    7BFF          6596     MOV R3 , # 255 
                      6597     
                      6598     FIND_THROTTLE_GAIN_CALCULATE: 
                      6599     	; Calculate difference
109A    C3            6600     	CLR	C
109B    EB            6601     MOV A , R3 
109C    9A            6602     SUBB A , R2 
109D    FC            6603     MOV R4 , A 
                      6604     	; Check that difference is minimum 130
109E    C3            6605     	CLR	C
109F    9482          6606     	SUBB	A, #130
10A1    5002          6607     	JNC	($+4)
                      6608     
10A3    7C82          6609     MOV R4 , # 130 
                      6610     
                      6611     	; Find gain
10A5    756F00        6612     	MOV	PPM_THROTTLE_GAIN, #0
                      6613     TEST_THROTTLE_GAIN: 
10A8    056F          6614     	INC	PPM_THROTTLE_GAIN
10AA    EC            6615     MOV A , R4 
10AB    856FF0        6616     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
10AE    A4            6617     	MUL	AB
10AF    C3            6618     	CLR	C
10B0    E5F0          6619     	MOV	A, B
10B2    9480          6620     	SUBB	A, #128
10B4    40F2          6621     	JC	TEST_THROTTLE_GAIN
10B6    22            6622     	RET
                      6623     
                      6624     
                      6625     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6626     ;
                      6627     ; Average throttle 
                      6628     ;
                      6629     ; Outputs result in Temp3
                      6630     ;
                      6631     ; Averages throttle calibration readings
                      6632     ;
                      6633     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6634     AVERAGE_THROTTLE: 
10B7    D27F          6635     SETB FLAGS3 . 7 
10B9    118B          6636     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
10BB    1206D5        6637     	CALL WAIT30MS		
10BE    7A00          6638     MOV R2 , # 0 
10C0    7B00          6639     MOV R3 , # 0 
10C2    7C10          6640     MOV R4 , # 16 
                      6641     AVERAGE_THROTTLE_MEAS: 
10C4    1206CB        6642     	CALL	WAIT3MS			; Wait for new RC pulse value
10C7    E559          6643     	MOV	A, NEW_RCP		; Get new RC pulse value
10C9    2A            6644     ADD A , R2 
10CA    FA            6645     MOV R2 , A 
10CB    7400          6646     	MOV	A, #0
10CD    3B            6647     ADDC A , R3 
10CE    FB            6648     MOV R3 , A 
10CF    DCF3          6649     DJNZ R4 , AVERAGE_THROTTLE_MEAS 
                      6650     
10D1    7C04          6651     MOV R4 , # 4 
                      6652     AVERAGE_THROTTLE_DIV: 
10D3    C3            6653     	CLR	C
10D4    EB            6654     MOV A , R3 
10D5    13            6655     	RRC	A      
10D6    FB            6656     MOV R3 , A 
10D7    EA            6657     MOV A , R2 
10D8    13            6658     	RRC	A      
10D9    FA            6659     MOV R2 , A 
10DA    DCF7          6660     DJNZ R4 , AVERAGE_THROTTLE_DIV 
                      6661     
10DC    FE            6662     MOV R6 , A 
10DD    C27F          6663     CLR FLAGS3 . 7 
10DF    118B          6664     	CALL	FIND_THROTTLE_GAIN	; Set throttle gain
10E1    22            6665     	RET
                      6666     
                      6667     
                      6668     
                      6669     
                      6670     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6671     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6672     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6673     ;
                      6674     ; Main program start
                      6675     ;
                      6676     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6677     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6678     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6679     
                      6680     RESET: 
                      6681     	; Check flash lock byte
10E2    E5EF          6682     	MOV	A, RSTSRC			
10E4    20E603        6683     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      6684     
10E7    752000        6685     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      6686     
10EA    0520          6687     	INC	BIT_ACCESS
10EC    903FFF        6688     MOV DPTR , # 16383 
10EF    E520          6689     	MOV	A, BIT_ACCESS
10F1    14            6690     	DEC	A
10F2    6006          6691     	JZ	LOCK_BYTE_TEST
                      6692     
10F4    901DFF        6693     MOV DPTR , # 7679 
10F7    14            6694     	DEC	A
10F8    6000          6695     	JZ	LOCK_BYTE_TEST
                      6696     
                      6697     LOCK_BYTE_TEST: 
10FA    93            6698     	MOVC A, @A+DPTR		; Read lock byte
10FB    04            6699     	INC	A				
10FC    6003          6700     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      6701     
                      6702     IF ONE_S_CAPABLE == 0		
10FE    75EF12        6703     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      6704     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      6707     
                      6708     LOCK_BYTE_OK: 
                      6709     	; Select register bank 0 for main program routines
1101    C2D3          6710     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      6711     	; Disable the WDT.
1103    53D9BF        6712     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      6713     	; Initialize stack
1106    7581C0        6714     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      6715     	; Initialize VDD monitor
1109    43FF80        6716     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
110C    1206C6        6717     	CALL	WAIT1MS			; Wait at least 100us
                      6718     IF ONE_S_CAPABLE == 0		
110F    75EF02        6719     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      6720     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      6723     	; Set clock frequency
1112    43B203        6724     	ORL	OSCICN, #03H		; Set clock divider to 1
1115    E5B3          6725     	MOV	A, OSCICL				
1117    2404          6726     	ADD	A, #04H			; 24.5MHz to 25MHz (~0.5% per step)
1119    20E702        6727     	JB	ACC.7, RESET_CAL_DONE	; Is carry (7bit) set? - skip next instruction
                      6728     
111C    F5B3          6729     	MOV	OSCICL, A
                      6730     
                      6731     RESET_CAL_DONE: 
                      6732     	; Switch power off
111E    120F99        6733     	CALL	SWITCH_POWER_OFF
                      6734     	; Ports initialization
1121    7580FF        6735     MOV P0 , # 255 
1124    75A400        6736     MOV P0MDOUT , # 0 
1127    75F1B2        6737     MOV P0MDIN , # -78 
112A    75D4EF        6738     MOV P0SKIP , # 239 
112D    75906A        6739     MOV P1 , # 106 
1130    75A53F        6740     MOV P1MDOUT , # 63 
1133    75F23F        6741     MOV P1MDIN , # 63 
1136    75D540        6742     MOV P1SKIP , # 64 
                      6743     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
1139    75A601        6746     MOV P2MDOUT , # 1 
                      6747     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      6754     	; Initialize the XBAR and related functionality
                      6755     	INITIALIZE_XBAR		
113C    75E241        6755+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      6756     	; Set default programmed parameters
113F    120FAB        6757     	CALL	SET_DEFAULT_PARAMETERS
                      6758     	; Read all programmed parameters
1142    1216B0        6759     	CALL ERASE_AND_STORE_ALL_IN_EEPROM
                      6760     	; Set beep strength
1145    7898          6761     MOV R0 , # PGM_BEEP_STRENGTH 
1147    8670          6762     MOV BEEP_STRENGTH , @ R0 
                      6763     	; Initializing beep
1149    C2AF          6764     	CLR	EA				; Disable interrupts explicitly
114B    1206DF        6765     	CALL WAIT200MS	
                      6766     
                      6767     	; 
114E    120704        6768     	CALL BEEP_F4
1151    120704        6769     	CALL BEEP_F4
1154    1206DA        6770     	CALL WAIT100MS
1157    1206DA        6771     	CALL WAIT100MS
115A    1206DA        6772     	CALL WAIT100MS
115D    1206DA        6773     	CALL WAIT100MS
1160    120704        6774     	CALL BEEP_F4
1163    120704        6775     	CALL BEEP_F4
1166    1206DA        6776     	CALL WAIT100MS
1169    1206DA        6777     	CALL WAIT100MS
116C    1206D5        6778     	CALL WAIT30MS
116F    1206D5        6779     	CALL WAIT30MS
1172    120704        6780     	CALL BEEP_F4
1175    1206D5        6781     	CALL WAIT30MS
1178    1206D5        6782     	CALL WAIT30MS
117B    120704        6783     	CALL BEEP_F4
117E    120704        6784     	CALL BEEP_F4
1181    1206DA        6785     	CALL WAIT100MS
1184    1206DA        6786     	CALL WAIT100MS
1187    1206DA        6787     	CALL WAIT100MS
118A    1206DA        6788     	CALL WAIT100MS
118D    120704        6789     	CALL BEEP_F4
1190    120704        6790     	CALL BEEP_F4
1193    1206DA        6791     	CALL WAIT100MS
1196    1206DA        6792     	CALL WAIT100MS
1199    1206DA        6793     	CALL WAIT100MS
119C    1206DA        6794     	CALL WAIT100MS
                      6795     
119F    1206FD        6796     	CALL BEEP_F3
11A2    1206FD        6797     	CALL BEEP_F3
11A5    1206DA        6798     	CALL WAIT100MS
11A8    1206DA        6799     	CALL WAIT100MS
11AB    1206DA        6800     	CALL WAIT100MS
11AE    1206DA        6801     	CALL WAIT100MS
11B1    1206EF        6802     	CALL BEEP_F1
11B4    1206EF        6803     	CALL BEEP_F1
11B7    1206DA        6804     	CALL WAIT100MS
11BA    1206DA        6805     	CALL WAIT100MS
11BD    1206D5        6806     	CALL WAIT30MS
11C0    1206D5        6807     	CALL WAIT30MS
11C3    1206FD        6808     	CALL BEEP_F3
11C6    1206D5        6809     	CALL WAIT30MS
11C9    1206D5        6810     	CALL WAIT30MS
11CC    120704        6811     	CALL BEEP_F4
11CF    120704        6812     	CALL BEEP_F4
11D2    1206DA        6813     	CALL WAIT100MS
11D5    1206DA        6814     	CALL WAIT100MS
11D8    1206DA        6815     	CALL WAIT100MS
11DB    1206DA        6816     	CALL WAIT100MS
11DE    1206DA        6817     	CALL WAIT100MS
11E1    1206DA        6818     	CALL WAIT100MS
11E4    1206DA        6819     	CALL WAIT100MS
11E7    1206DA        6820     	CALL WAIT100MS
                      6821     
                      6822     	;; 
                      6823     	;; 
                      6824     	; call beep_f4
                      6825     	; call wait100ms
                      6826     	; call wait100ms
                      6827     	; call beep_f2
                      6828     	; call wait100ms
                      6829     	; call wait100ms
                      6830     	; call beep_f3
                      6831     	; call wait100ms
                      6832     	; call wait100ms
                      6833     	; call beep_f1
                      6834     	; call wait100ms
                      6835     	; call wait100ms
                      6836     
                      6837     	;; 
                      6838     	; call beep_f4
                      6839     	; call wait30ms
                      6840     	; call wait30ms
                      6841     	; call beep_f3
                      6842     	; call wait30ms
                      6843     	; call wait30ms
                      6844     	; call beep_f2
                      6845     	; call wait30ms
                      6846     	; call wait30ms
                      6847     	; call beep_f3
                      6848     	; call wait30ms
                      6849     	; call wait30ms
                      6850     	; call beep_f1
                      6851     	; call wait100ms
                      6852     	; call wait100ms
                      6853     	; call wait100ms
                      6854     	; call wait100ms	
                      6855     	; call wait100ms
                      6856     	; call wait100ms
                      6857     
                      6858     IF MODE <= 1	; Main or tail
                               	; Wait for receiver to initialize
                               	CALL	WAIT1S
                               	CALL	WAIT200MS
                               	CALL	WAIT200MS
                               	CALL	WAIT100MS
                               ENDIF
                      6865     
                      6866     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6867     ;
                      6868     ; No signal entry point
                      6869     ;
                      6870     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6871     INIT_NO_SIGNAL: 
                      6872     	; Disable interrupts explicitly
11EA    C2AF          6873     	CLR	EA				
                      6874     	; Clear RAM
11EC    E4            6875     	CLR	A				; Clear accumulator
11ED    F8            6876     MOV R0 , A 
                      6877     CLEAR_RAM: 	
11EE    F6            6878     MOV @ R0 , A 
11EF    D8FD          6879     DJNZ R0 , CLEAR_RAM 
                      6880     	; Check if input signal is high for more than 10ms
11F1    78C8          6881     MOV R0 , # 200 
                      6882     INPUT_HIGH_CHECK_1: 
11F3    79C8          6883     MOV R1 , # 200 
                      6884     INPUT_HIGH_CHECK_2: 
11F5    308404        6885     JNB 128 . 4 , BOOTLOADER_DONE 
11F8    D9FB          6886     DJNZ R1 , INPUT_HIGH_CHECK_2 
11FA    D8F7          6887     DJNZ R0 , INPUT_HIGH_CHECK_1 
                      6888     
                      6889     	; ljmp	1C00h			; Jump to bootloader
                      6890     
                      6891     BOOTLOADER_DONE: 
                      6892     	; Set default programmed parameters
11FC    120FAB        6893     	CALL	SET_DEFAULT_PARAMETERS
                      6894     	; Read all programmed parameters
11FF    1216B0        6895     	CALL ERASE_AND_STORE_ALL_IN_EEPROM
                      6896     	; Decode parameters
1202    110B          6897     	CALL	DECODE_PARAMETERS
                      6898     	; Decode governor gains
1204    1144          6899     	CALL	DECODE_GOVERNOR_GAINS
                      6900     	; Decode startup power
1206    115E          6901     	CALL	DECODE_STARTUP_POWER
                      6902     	; Decode main spoolup time
1208    116D          6903     	CALL	DECODE_MAIN_SPOOLUP_TIME
                      6904     	; Decode demag compensation
120A    116E          6905     	CALL	DECODE_DEMAG_COMP
                      6906     	; Set BEC voltage
120C    118A          6907     	CALL	SET_BEC_VOLTAGE
                      6908     	; Find throttle gain from stored min and max settings
120E    118B          6909     	CALL	FIND_THROTTLE_GAIN
                      6910     	; Set beep strength
1210    7898          6911     MOV R0 , # PGM_BEEP_STRENGTH 
1212    8670          6912     MOV BEEP_STRENGTH , @ R0 
                      6913     	; Switch power off
1214    120F99        6914     	CALL	SWITCH_POWER_OFF
                      6915     	; Set clock frequency
                      6916     IF MCU_50MHZ == 1
                               	SET_MCU_CLK_25MHZ
                               ENDIF
                      6919     	; Timer control
1217    758850        6920     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      6921     	; Timer mode
121A    758912        6922     	MOV	TMOD, #12H		; Timer0 as 8bit, timer1 as 16bit
                      6923     	; Timer2: clk/12 for 128us and 32ms interrupts
121D    75C824        6924     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      6925     	; Timer3: clk/12 for commutation timing
1220    759104        6926     	MOV	TMR3CN, #04H		; Timer3 enabled
                      6927     	; PCA
1223    75D840        6928     	MOV	PCA0CN, #40H		; PCA enabled
                      6929     	; Enable interrupts
1226    75A822        6930     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
1229    75B802        6931     	MOV	IP, #02H			; High priority to timer0 interrupts
122C    75E690        6932     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      6933     	; Initialize comparator
122F    759B80        6934     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1232    759D00        6935     	MOV	CPT0MD, #00H		; Comparator response time 100ns
                      6936     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #00H		; Comparator response time 100ns
                               ENDIF
                      6940     	; Initialize ADC
                      6941     	INITIALIZE_ADC			; Initialize ADC operation
1235    75D10E        6941+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
1238    75BC58        6941+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
123B    75BB0E        6941+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
123E    75BA11        6941+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
1241    75E880        6941+1   MOV ADC0CN , # 80H  ; ADC ENABLED
1244    1206C6        6942     	CALL	WAIT1MS
1247    D2AF          6943     	SETB	EA				; Enable all interrupts
                      6944     	; Measure number of lipo cells
1249    1209E6        6945     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      6946     	; Initialize rc pulse
                      6947     	RCP_INT_ENABLE		 			; Enable interrupt
124C    43DA01        6947+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      6948     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
124F    C2D8          6948+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1251    C271          6949     CLR FLAGS2 . 1 
1253    1206DF        6950     	CALL WAIT200MS
                      6951     	; Set initial arm variable
1256    753001        6952     	MOV	INITIAL_ARM, #1
                      6953     
                      6954     	; Measure PWM frequency
                      6955     MEASURE_PWM_FREQ_INIT: 	
1259    D261          6956     SETB FLAGS0 . 1 
125B    7B03          6957     MOV R3 , # 3 
                      6958     MEASURE_PWM_FREQ_START: 	
125D    7A0C          6959     MOV R2 , # 12 
                      6960     MEASURE_PWM_FREQ_LOOP: 	
                      6961     	; Check if period diff was accepted
125F    E558          6962     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1261    7006          6963     	JNZ	MEASURE_PWM_FREQ_WAIT
                      6964     
1263    7A0C          6965     MOV R2 , # 12 
1265    DB02          6966     DJNZ R3 , ( $+4 ) 
1267    21EA          6967     	AJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      6968     
                      6969     MEASURE_PWM_FREQ_WAIT: 
1269    1206D5        6970     	CALL	WAIT30MS						; Wait 30ms for new pulse
126C    207002        6971     JB FLAGS2 . 0 , ( $+5 ) 
126F    21EA          6972     	AJMP	INIT_NO_SIGNAL					; Go back to detect input signal
                      6973     
1271    C270          6974     CLR FLAGS2 . 0 
1273    E559          6975     	MOV	A, NEW_RCP					; Load value
1275    C3            6976     	CLR	C
1276    9402          6977     SUBB A , # 2 
1278    40E3          6978     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      6979     
127A    E52F          6980     	MOV	A, FLAGS3						; Check pwm frequency flags
127C    541F          6981     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
127E    855B5A        6982     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1281    F55B          6983     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1283    B55AD7        6984     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      6985     
1286    DAD7          6986     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      6987     
                      6988     	; Clear measure pwm frequency flag
1288    C261          6989     CLR FLAGS0 . 1 
                      6990     	; Set up RC pulse interrupts after pwm frequency measurement
                      6991     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
128A    53DACF        6991+1   ANL PCA0CPM0 , # 0CFH 
128D    207E03        6991+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1290    43DA20        6991+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1293    307E03        6991+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1296    43DA10        6991+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      6992     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1299    C2D8          6992+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
129B    C271          6993     CLR FLAGS2 . 1 
                      6994     	; Test whether signal is OnShot125
129D    C275          6995     CLR FLAGS2 . 5 
129F    752800        6996     	MOV	RCP_OUTSIDE_RANGE_CNT, #0		; Reset out of range counter
12A2    1206DA        6997     	CALL WAIT100MS						; Wait for new RC pulse
12A5    307409        6998     JNB FLAGS2 . 4 , VALIDATE_RCP_START 
                      6999     
12A8    C3            7000     	CLR	C
12A9    E528          7001     	MOV	A, RCP_OUTSIDE_RANGE_CNT			; Check how many pulses were outside normal PPM range (800-2160us)
12AB    940A          7002     	SUBB	A, #10						
12AD    4002          7003     	JC	VALIDATE_RCP_START
                      7004     
12AF    D275          7005     SETB FLAGS2 . 5 
                      7006     
                      7007     	; Validate RC pulse
                      7008     VALIDATE_RCP_START: 	
12B1    1206CB        7009     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
12B4    7802          7010     MOV R0 , # 2 
12B6    307402        7011     JNB FLAGS2 . 4 , ( $+5 ) 
                      7012     
12B9    7800          7013     MOV R0 , # 0 
                      7014     
12BB    C3            7015     	CLR	C
12BC    E559          7016     	MOV	A, NEW_RCP					; Load value
12BE    98            7017     SUBB A , R0 
12BF    40F0          7018     	JC	VALIDATE_RCP_START				; No - start over
                      7019     
                      7020     	; Beep arm sequence start signal
12C1    C2AF          7021     	CLR 	EA							; Disable all interrupts
12C3    1206EF        7022     	CALL BEEP_F1						; Signal that RC pulse is ready
12C6    1206D5        7023     	CALL WAIT30MS
12C9    1206EF        7024     	CALL BEEP_F1
12CC    1206D5        7025     	CALL WAIT30MS
12CF    1206F6        7026     	CALL BEEP_F2
12D2    1206D5        7027     	CALL WAIT30MS
12D5    1206F6        7028     	CALL BEEP_F2
12D8    D2AF          7029     	SETB	EA							; Enable all interrupts
12DA    1206DF        7030     	CALL WAIT200MS	
                      7031     
                      7032     	; Arming sequence start
12DD    754600        7033     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      7034     ARMING_START: 
                      7035     IF MODE >= 1	; Tail or multi
12E0    7888          7036     MOV R0 , # PGM_DIRECTION 
12E2    E6            7037     MOV A , @ R0 
12E3    B40302        7038     	CJNE	A, #3, ($+5)
                      7039     
12E6    61BC          7040     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      7041     ENDIF
                      7042     
12E8    1206CB        7043     	CALL WAIT3MS
12EB    788C          7044     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
12ED    E6            7045     MOV A , @ R0 
12EE    C3            7046     	CLR	C
12EF    9401          7047     	SUBB	A, #1				; Is TX programming enabled?
12F1    5003          7048     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      7049     
12F3    0213BC        7050     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7051     
                      7052     ARMING_INITIAL_ARM_CHECK: 
12F6    E530          7053     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
12F8    C3            7054     	CLR	C
12F9    9401          7055     	SUBB	A, #1				; Is it the initial arm sequence?
12FB    5003          7056     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      7057     
12FD    0213BC        7058     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      7059     
                      7060     ARMING_PPM_CHECK: 
1300    207435        7061     JB FLAGS2 . 4 , THROTTLE_HIGH_CAL_START 
                      7062     
                      7063     	; PWM tx program entry
1303    C3            7064     	CLR	C
1304    E559          7065     	MOV	A, NEW_RCP			; Load new RC pulse value
1306    94FF          7066     SUBB A , # 255 
1308    5003          7067     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      7068     
130A    0213BC        7069     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      7070     
                      7071     PROGRAM_BY_TX_ENTRY_PWM: 	
130D    C2AF          7072     	CLR	EA					; Disable all interrupts
130F    120704        7073     	CALL BEEP_F4
1312    D2AF          7074     	SETB	EA					; Enable all interrupts
1314    1206DA        7075     	CALL WAIT100MS
1317    C3            7076     	CLR	C
1318    E559          7077     	MOV	A, NEW_RCP			; Load new RC pulse value
131A    9401          7078     SUBB A , # 1 
131C    50EF          7079     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      7080     
                      7081     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
131E    C2AF          7082     	CLR	EA					; Disable all interrupts
1320    1206EF        7083     	CALL BEEP_F1
1323    1206D0        7084     	CALL WAIT10MS
1326    1206EF        7085     	CALL BEEP_F1
1329    D2AF          7086     	SETB	EA					; Enable all interrupts
132B    1206DA        7087     	CALL WAIT100MS
132E    C3            7088     	CLR	C
132F    E559          7089     	MOV	A, NEW_RCP			; Load new RC pulse value
1331    94FF          7090     SUBB A , # 255 
1333    40E9          7091     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      7092     
1335    021816        7093     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7094     
                      7095     	; PPM throttle calibration and tx program entry
                      7096     THROTTLE_HIGH_CAL_START: 
                      7097     IF MODE <= 1	; Main or tail
                               	MOV	TEMP8, #5				; Set 3 seconds wait time
                               ELSE
1338    7F02          7100     MOV R7 , # 2 
                      7101     ENDIF
                      7102     THROTTLE_HIGH_CAL: 			
133A    D27F          7103     SETB FLAGS3 . 7 
133C    118B          7104     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
133E    1206DA        7105     	CALL WAIT100MS				; Wait for new throttle value
1341    C2AF          7106     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1343    C27F          7107     CLR FLAGS3 . 7 
1345    118B          7108     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1347    AE59          7109     MOV R6 , NEW_RCP 
1349    C3            7110     	CLR	C
134A    E559          7111     	MOV	A, NEW_RCP			; Load new RC pulse value
134C    947F          7112     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
134E    D2AF          7113     	SETB	EA					; Enable interrupts
1350    4074          7114     	JC	ARM_TARGET_UPDATED		; No - branch
                      7115     
1352    1206C6        7116     	CALL WAIT1MS		
1355    C2AF          7117     	CLR	EA					; Disable all interrupts
1357    120704        7118     	CALL BEEP_F4
135A    D2AF          7119     	SETB	EA					; Enable all interrupts
135C    DFDC          7120     DJNZ R7 , THROTTLE_HIGH_CAL 
                      7121     
135E    11B7          7122     	CALL	AVERAGE_THROTTLE
1360    C3            7123     	CLR	C
1361    EE            7124     MOV A , R6 
1362    9405          7125     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
1364    7897          7126     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1366    F6            7127     MOV @ R0 , A 
1367    1206DF        7128     	CALL WAIT200MS				
136A    1216B0        7129     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
136D    121799        7130     	CALL	SUCCESS_BEEP
                      7131     
                      7132     THROTTLE_LOW_CAL_START: 
1370    7F0A          7133     MOV R7 , # 10 
                      7134     THROTTLE_LOW_CAL: 			
1372    D27F          7135     SETB FLAGS3 . 7 
1374    118B          7136     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1376    1206DA        7137     	CALL WAIT100MS
1379    C2AF          7138     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
137B    C27F          7139     CLR FLAGS3 . 7 
137D    118B          7140     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
137F    AE59          7141     MOV R6 , NEW_RCP 
1381    C3            7142     	CLR	C
1382    E559          7143     	MOV	A, NEW_RCP			; Load new RC pulse value
1384    947F          7144     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
1386    D2AF          7145     	SETB	EA					; Enable interrupts
1388    50E6          7146     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      7147     
138A    1206C6        7148     	CALL WAIT1MS		
138D    C2AF          7149     	CLR	EA					; Disable all interrupts
138F    1206EF        7150     	CALL BEEP_F1
1392    1206D0        7151     	CALL WAIT10MS
1395    1206EF        7152     	CALL BEEP_F1
1398    D2AF          7153     	SETB	EA					; Enable all interrupts
139A    DFD6          7154     DJNZ R7 , THROTTLE_LOW_CAL 
                      7155     
139C    11B7          7156     	CALL	AVERAGE_THROTTLE
139E    EE            7157     MOV A , R6 
139F    2405          7158     	ADD	A, #5				; Add about 2%
13A1    7896          7159     MOV R0 , # PGM_PPM_MIN_THROTTLE 
13A3    F6            7160     MOV @ R0 , A 
13A4    1206DF        7161     	CALL WAIT200MS				
13A7    1216B0        7162     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
13AA    1217C8        7163     	CALL	SUCCESS_BEEP_INVERTED
                      7164     
                      7165     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
13AD    1206DA        7166     	CALL WAIT100MS
13B0    118B          7167     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13B2    C3            7168     	CLR	C
13B3    E559          7169     	MOV	A, NEW_RCP			; Load new RC pulse value
13B5    94FF          7170     SUBB A , # 255 
13B7    40F4          7171     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      7172     
13B9    021816        7173     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      7174     
                      7175     PROGRAM_BY_TX_CHECKED: 
13BC    C3            7176     	CLR	C
13BD    E559          7177     	MOV	A, NEW_RCP			; Load new RC pulse value
13BF    9546          7178     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
13C1    4003          7179     	JC	ARM_TARGET_UPDATED		; No - do not update
                      7180     
13C3    855946        7181     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      7182     
                      7183     ARM_TARGET_UPDATED: 
13C6    1206DA        7184     	CALL WAIT100MS				; Wait for new throttle value
13C9    7801          7185     MOV R0 , # 1 
13CB    7988          7186     MOV R1 , # PGM_DIRECTION 
13CD    E7            7187     MOV A , @ R1 
13CE    B40302        7188     	CJNE	A, #3, ($+5)			; No - branch
                      7189     
13D1    7805          7190     MOV R0 , # ( RCP_STOP+4 ) 
                      7191     
13D3    C3            7192     	CLR	C
13D4    E559          7193     	MOV	A, NEW_RCP			; Load new RC pulse value
13D6    98            7194     SUBB A , R0 
13D7    4002          7195     	JC	ARM_END_BEEP			; Yes - proceed
                      7196     
13D9    41E0          7197     	JMP	ARMING_START			; No - start over
                      7198     
                      7199     ARM_END_BEEP: 
                      7200     	; Beep arm sequence end signal
13DB    C2AF          7201     	CLR 	EA					; Disable all interrupts
13DD    120704        7202     	CALL BEEP_F4				; Signal that rcpulse is ready
13E0    1206D5        7203     	CALL WAIT30MS
13E3    120704        7204     	CALL BEEP_F4
13E6    1206D5        7205     	CALL WAIT30MS
13E9    1206FD        7206     	CALL BEEP_F3
13EC    1206D5        7207     	CALL WAIT30MS
13EF    1206FD        7208     	CALL BEEP_F3
13F2    D2AF          7209     	SETB	EA					; Enable all interrupts
13F4    1206DF        7210     	CALL WAIT200MS
                      7211     
                      7212     	; Clear initial arm variable
13F7    753000        7213     	MOV	INITIAL_ARM, #0
                      7214     
                      7215     	; Armed and waiting for power on
                      7216     WAIT_FOR_POWER_ON: 
13FA    E4            7217     	CLR	A
13FB    F531          7218     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
13FD    F532          7219     	MOV	POWER_ON_WAIT_CNT_H, A	
                      7220     WAIT_FOR_POWER_ON_LOOP: 
13FF    0531          7221     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1401    E531          7222     	MOV	A, POWER_ON_WAIT_CNT_L
1403    F4            7223     	CPL	A
1404    7039          7224     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      7225     
1406    0532          7226     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
1408    789A          7227     MOV R0 , # PGM_BEACON_DELAY 
140A    E6            7228     MOV A , @ R0 
140B    7819          7229     MOV R0 , # 25 
140D    14            7230     	DEC	A
140E    6012          7231     	JZ	BEEP_DELAY_SET
                      7232     
1410    7832          7233     MOV R0 , # 50 
1412    14            7234     	DEC	A
1413    600D          7235     	JZ	BEEP_DELAY_SET
                      7236     
1415    787D          7237     MOV R0 , # 125 
1417    14            7238     	DEC	A
1418    6008          7239     	JZ	BEEP_DELAY_SET
                      7240     
141A    78FA          7241     MOV R0 , # 250 
141C    14            7242     	DEC	A
141D    6003          7243     	JZ	BEEP_DELAY_SET
                      7244     
141F    753200        7245     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      7246     
                      7247     BEEP_DELAY_SET: 
1422    C3            7248     	CLR	C
1423    E532          7249     	MOV	A, POWER_ON_WAIT_CNT_H
1425    98            7250     SUBB A , R0 
1426    4017          7251     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      7252     
1428    1532          7253     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
142A    7531B4        7254     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
142D    7899          7255     MOV R0 , # PGM_BEACON_STRENGTH 
142F    8670          7256     MOV BEEP_STRENGTH , @ R0 
1431    C2AF          7257     	CLR 	EA					; Disable all interrupts
1433    120704        7258     	CALL BEEP_F4				; Signal that there is no signal
1436    D2AF          7259     	SETB	EA					; Enable all interrupts
1438    7898          7260     MOV R0 , # PGM_BEEP_STRENGTH 
143A    8670          7261     MOV BEEP_STRENGTH , @ R0 
143C    1206DA        7262     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      7263     
                      7264     WAIT_FOR_POWER_ON_NO_BEEP: 
143F    1206D0        7265     	CALL WAIT10MS
1442    E529          7266     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
1444    7005          7267     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      7268     
1446    307402        7269     JNB FLAGS2 . 4 , WAIT_FOR_POWER_ON_PPM_NOT_MISSING 
                      7270     
1449    21EA          7271     	JMP	INIT_NO_SIGNAL					; If ppm and pulses missing - go back to detect input signal
                      7272     
                      7273     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
144B    7801          7274     MOV R0 , # 1 
144D    207402        7275     JB FLAGS2 . 4 , ( $+5 ) 
                      7276     
1450    7806          7277     MOV R0 , # ( RCP_STOP+5 ) 
                      7278     
1452    C3            7279     	CLR	C
1453    E559          7280     	MOV	A, NEW_RCP			; Load new RC pulse value
1455    98            7281     SUBB A , R0 
1456    40A7          7282     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      7283     
                      7284     IF MODE >= 1	; Tail or multi
1458    7888          7285     MOV R0 , # PGM_DIRECTION 
145A    E6            7286     MOV A , @ R0 
145B    C3            7287     	CLR	C
145C    9403          7288     	SUBB	A, #3
145E    6003          7289     	JZ 	WAIT_FOR_POWER_ON_CHECK_TIMEOUT	; Do not wait if bidirectional operation
                      7290     ENDIF
                      7291     
1460    1206DA        7292     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      7293     
                      7294     WAIT_FOR_POWER_ON_CHECK_TIMEOUT: 
1463    E529          7295     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1465    7002          7296     	JNZ	($+4)				; If it is not zero - proceed
                      7297     
1467    21EA          7298     	AJMP	INIT_NO_SIGNAL			; If it is zero (pulses missing) - go back to detect input signal
                      7299     
                      7300     
                      7301     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7302     ;
                      7303     ; Start entry point
                      7304     ;
                      7305     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7306     INIT_START: 
1469    C2AF          7307     	CLR	EA
146B    120F99        7308     	CALL SWITCH_POWER_OFF
146E    E4            7309     	CLR	A
146F    F522          7310     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1471    F523          7311     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1473    F524          7312     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1475    F525          7313     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1477    D2AF          7314     	SETB	EA
1479    7885          7315     MOV R0 , # PGM_MOTOR_IDLE 
147B    8662          7316     MOV PWM_MOTOR_IDLE , @ R0 
147D    F53E          7317     	MOV	GOV_TARGET_L, A		; Set target to zero
147F    F53F          7318     	MOV	GOV_TARGET_H, A
1481    F540          7319     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1483    F541          7320     	MOV	GOV_INTEGRAL_H, A
1485    F542          7321     	MOV	GOV_INTEGRAL_X, A
1487    F56D          7322     	MOV	ADC_CONVERSION_CNT, A
1489    F547          7323     	MOV	GOV_ACTIVE, A
148B    F52C          7324     	MOV	FLAGS0, A				; Clear flags0
148D    F52D          7325     	MOV	FLAGS1, A				; Clear flags1
148F    F535          7326     	MOV	DEMAG_DETECTED_METRIC, A	; Clear demag metric
1491    120B75        7327     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      7328     	;**** **** **** **** ****
                      7329     	; Motor start beginning
                      7330     	;**** **** **** **** **** 
1494    756D08        7331     MOV ADC_CONVERSION_CNT , # 8 
                      7332     	SET_ADC_IP_TEMP
1497    75BB10        7332+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
149A    1206C6        7333     	CALL WAIT1MS
149D    120A81        7334     	CALL START_ADC_CONVERSION
                      7335     READ_INITIAL_TEMP: 
                      7336     	GET_ADC_STATUS 
14A0    E5E8          7336+1   MOV A , ADC0CN 
14A2    20ECFB        7337     	JB	AD0BUSY, READ_INITIAL_TEMP
                      7338     	READ_ADC_RESULT						; Read initial temperature
14A5    A8BD          7338+1   MOV R0 , ADC0L 
14A7    A9BE          7338+1   MOV R1 , ADC0H 
14A9    E9            7339     MOV A , R1 
14AA    7001          7340     	JNZ	($+3)							; Is reading below 256?
                      7341     
14AC    F8            7342     MOV R0 , A 
                      7343     
14AD    886E          7344     MOV CURRENT_AVERAGE_TEMP , R0 
14AF    120A85        7345     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
14B2    756D08        7346     MOV ADC_CONVERSION_CNT , # 8 
                      7347     	SET_ADC_IP_TEMP
14B5    75BB10        7347+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      7348     	; Set up start operating conditions
14B8    7887          7349     MOV R0 , # PGM_PWM_FREQ 
14BA    E6            7350     MOV A , @ R0 
14BB    FE            7351     MOV R6 , A 
14BC    7602          7352     MOV @ R0 , # 2 
14BE    110B          7353     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
14C0    7887          7354     MOV R0 , # PGM_PWM_FREQ 
14C2    EE            7355     MOV A , R6 
14C3    F6            7356     MOV @ R0 , A 
                      7357     	; Set max allowed power
14C4    C2AF          7358     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
14C6    755EFF        7359     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
14C9    120B57        7360     	CALL SET_STARTUP_PWM
14CC    85225E        7361     	MOV	PWM_LIMIT, REQUESTED_PWM
14CF    85225F        7362     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
14D2    852260        7363     	MOV	PWM_LIMIT_LOW_RPM, REQUESTED_PWM
14D5    D2AF          7364     	SETB	EA
14D7    752201        7365     	MOV	REQUESTED_PWM, #1			; Set low pwm again after calling set_startup_pwm
14DA    752401        7366     	MOV	CURRENT_PWM, #1
14DD    752501        7367     	MOV	CURRENT_PWM_LIMITED, #1	
14E0    855D64        7368     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
14E3    756501        7369     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      7370     	; Begin startup sequence
                      7371     IF MCU_50MHZ == 1
                               	SET_MCU_CLK_50MHZ
                               ENDIF
14E6    D268          7374     SETB FLAGS1 . 0 
14E8    D269          7375     SETB FLAGS1 . 1 
14EA    753400        7376     	MOV	STARTUP_OK_CNT, #0			; Reset ok counter
14ED    120F03        7377     	CALL COMM5COMM6				; Initialize commutation
14F0    120F2D        7378     	CALL COMM6COMM1				
14F3    120B75        7379     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
14F6    120B7C        7380     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
14F9    120BF2        7381     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
14FC    02150A        7382     	JMP	RUN1
                      7383     
                      7384     
                      7385     
                      7386     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7387     ;
                      7388     ; Run entry point
                      7389     ;
                      7390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7391     DAMPED_TRANSITION: 
                      7392     	; Transition from nondamped to damped if applicable
14FF    120F99        7393     	CALL	SWITCH_POWER_OFF		; Switch off power while changing pwm mode
1502    110B          7394     	CALL	DECODE_PARAMETERS		; Set programmed parameters
1504    756D00        7395     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      7396     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
1507    75BB0E        7396+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      7397     
                      7398     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      7399     ; Out_cA changes from low to high
                      7400     RUN1: 
150A    120CF1        7401     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
150D    120D9E        7402     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
1510    120DBD        7403     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
1513    1207EE        7404     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
1516    120DDF        7405     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
1519    120E29        7406     	CALL COMM1COMM2			; Commutate
151C    120B7C        7407     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
151F    120BE1        7408     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1522    120BF2        7409     	CALL CALC_NEW_WAIT_TIMES
1525    120CAE        7410     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      7411     
                      7412     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      7413     ; Out_cB changes from high to low
                      7414     RUN2: 
1528    120CE6        7415     	CALL WAIT_FOR_COMP_OUT_LOW
152B    120D9E        7416     	CALL	EVALUATE_COMPARATOR_INTEGRITY
152E    120DBD        7417     	CALL SETUP_COMM_WAIT	
1531    12084C        7418     	CALL CALC_GOVERNOR_PROP_ERROR
1534    1209AA        7419     	CALL	SET_PWM_LIMIT_LOW_RPM
1537    120DDF        7420     	CALL WAIT_FOR_COMM
153A    120E52        7421     	CALL COMM2COMM3
153D    120B7C        7422     	CALL CALC_NEXT_COMM_TIMING
1540    120BE1        7423     	CALL WAIT_ADVANCE_TIMING
1543    120BF2        7424     	CALL CALC_NEW_WAIT_TIMES
1546    120CAE        7425     	CALL WAIT_BEFORE_ZC_SCAN	
                      7426     
                      7427     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      7428     ; Out_cC changes from low to high
                      7429     RUN3: 
1549    120CF1        7430     	CALL WAIT_FOR_COMP_OUT_HIGH
154C    120D9E        7431     	CALL	EVALUATE_COMPARATOR_INTEGRITY
154F    120DBD        7432     	CALL SETUP_COMM_WAIT	
1552    120885        7433     	CALL CALC_GOVERNOR_INT_ERROR
1555    120DDF        7434     	CALL WAIT_FOR_COMM
1558    120E96        7435     	CALL COMM3COMM4
155B    120B7C        7436     	CALL CALC_NEXT_COMM_TIMING
155E    120BE1        7437     	CALL WAIT_ADVANCE_TIMING
1561    120BF2        7438     	CALL CALC_NEW_WAIT_TIMES
1564    120CAE        7439     	CALL WAIT_BEFORE_ZC_SCAN	
                      7440     
                      7441     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      7442     ; Out_cA changes from high to low
                      7443     RUN4: 
1567    120CE6        7444     	CALL WAIT_FOR_COMP_OUT_LOW
156A    120D9E        7445     	CALL	EVALUATE_COMPARATOR_INTEGRITY
156D    120DBD        7446     	CALL SETUP_COMM_WAIT	
1570    1208E2        7447     	CALL CALC_GOVERNOR_PROP_CORRECTION
1573    120DDF        7448     	CALL WAIT_FOR_COMM
1576    120EC8        7449     	CALL COMM4COMM5
1579    120B7C        7450     	CALL CALC_NEXT_COMM_TIMING
157C    120BE1        7451     	CALL WAIT_ADVANCE_TIMING
157F    120BF2        7452     	CALL CALC_NEW_WAIT_TIMES
1582    120CAE        7453     	CALL WAIT_BEFORE_ZC_SCAN	
                      7454     
                      7455     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      7456     ; Out_cB changes from low to high
                      7457     RUN5: 
1585    120CF1        7458     	CALL WAIT_FOR_COMP_OUT_HIGH
1588    120D9E        7459     	CALL	EVALUATE_COMPARATOR_INTEGRITY
158B    120DBD        7460     	CALL SETUP_COMM_WAIT	
158E    120947        7461     	CALL CALC_GOVERNOR_INT_CORRECTION
1591    120DDF        7462     	CALL WAIT_FOR_COMM
1594    120F03        7463     	CALL COMM5COMM6
1597    120B7C        7464     	CALL CALC_NEXT_COMM_TIMING
159A    120BE1        7465     	CALL WAIT_ADVANCE_TIMING
159D    120BF2        7466     	CALL CALC_NEW_WAIT_TIMES
15A0    120CAE        7467     	CALL WAIT_BEFORE_ZC_SCAN	
                      7468     
                      7469     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      7470     ; Out_cC changes from high to low
                      7471     RUN6: 
15A3    120CE6        7472     	CALL WAIT_FOR_COMP_OUT_LOW
15A6    120A81        7473     	CALL START_ADC_CONVERSION
15A9    120D9E        7474     	CALL	EVALUATE_COMPARATOR_INTEGRITY
15AC    120DBD        7475     	CALL SETUP_COMM_WAIT	
15AF    120A85        7476     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
15B2    120DDF        7477     	CALL WAIT_FOR_COMM
15B5    120F2D        7478     	CALL COMM6COMM1
15B8    120B7C        7479     	CALL CALC_NEXT_COMM_TIMING
15BB    120BE1        7480     	CALL WAIT_ADVANCE_TIMING
15BE    120BF2        7481     	CALL CALC_NEW_WAIT_TIMES
15C1    120CAE        7482     	CALL WAIT_BEFORE_ZC_SCAN	
                      7483     
                      7484     	; Check if it is direct startup
15C4    306938        7485     JNB FLAGS1 . 1 , NORMAL_RUN_CHECKS 
15C7    206B35        7486     JB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      7487     
                      7488     	; Set spoolup power variables
15CA    85615E        7489     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
15CD    85615F        7490     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
15D0    855D64        7491     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
15D3    756501        7492     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      7493     	; Check startup ok counter
15D6    7932          7494     MOV R1 , # 50 
15D8    7A0A          7495     MOV R2 , # 10 
15DA    C3            7496     	CLR	C
15DB    E534          7497     	MOV	A, STARTUP_OK_CNT			; Load ok counter
15DD    99            7498     SUBB A , R1 
15DE    4012          7499     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      7500     
15E0    C269          7501     CLR FLAGS1 . 1 
15E2    D26A          7502     SETB FLAGS1 . 2 
15E4    8A33          7503     MOV STARTUP_ROT_CNT , R2 
                      7504     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      7508     IF MODE == 2	; Multi
15E6    85615E        7509     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
15E9    755FFF        7510     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
15EC    756020        7511     	MOV	PWM_LIMIT_LOW_RPM, #20H
                      7512     ENDIF
15EF    0215FF        7513     	JMP	NORMAL_RUN_CHECKS
                      7514     
                      7515     DIRECT_START_CHECK_RCP: 
15F2    C3            7516     	CLR	C
15F3    E559          7517     	MOV	A, NEW_RCP				; Load new pulse value
15F5    9401          7518     SUBB A , # 1 
15F7    4003          7519     	JC	($+5)
                      7520     
15F9    02150A        7521     	LJMP	RUN1						; Continue to run 
                      7522     
15FC    02163D        7523     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      7524     
                      7525     
                      7526     NORMAL_RUN_CHECKS: 
                      7527     	; Check if it is initial run phase
15FF    306A1E        7528     JNB FLAGS1 . 2 , INITIAL_RUN_PHASE_DONE 
1602    206B1B        7529     JB FLAGS1 . 3 , INITIAL_RUN_PHASE_DONE 
                      7530     
                      7531     	; Decrement startup rotaton count
1605    E533          7532     	MOV	A, STARTUP_ROT_CNT
1607    14            7533     	DEC	A
                      7534     	; Check number of nondamped rotations
1608    7007          7535     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      7536     
160A    C26A          7537     CLR FLAGS1 . 2 
                      7538     IF MODE == 2	; Multi
160C    755EFF        7539     	MOV	PWM_LIMIT, #0FFH
                      7540     ENDIF
160F    81FF          7541     	JMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      7542     
                      7543     NORMAL_RUN_CHECK_STARTUP_ROT: 
1611    F533          7544     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      7545     
1613    C3            7546     	CLR	C
1614    E559          7547     	MOV	A, NEW_RCP				; Load new pulse value
1616    9401          7548     SUBB A , # 1 
1618    4003          7549     	JC	($+5)
                      7550     
161A    02150A        7551     	LJMP	RUN1						; Continue to run 
                      7552     
161D    02163D        7553     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      7554     
                      7555     INITIAL_RUN_PHASE_DONE: 
                      7556     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      7569     	; Exit run loop after a given time
1620    C3            7570     	CLR	C
1621    E55C          7571     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1623    94FA          7572     SUBB A , # 250 
1625    5016          7573     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      7574     
                      7575     RUN6_CHECK_RCP_TIMEOUT: 
1627    307404        7576     JNB FLAGS2 . 4 , RUN6_CHECK_SPEED 
                      7577     
162A    E529          7578     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
162C    600F          7579     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      7580     
                      7581     RUN6_CHECK_SPEED: 
162E    C3            7582     	CLR	C
162F    E53B          7583     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1631    78F0          7584     MOV R0 , # 0F0H 
1633    306B02        7585     JNB FLAGS1 . 3 , ( $+5 ) 
                      7586     
1636    7860          7587     MOV R0 , # 60H 
                      7588     
1638    98            7589     SUBB A , R0 
1639    5002          7590     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
163B    A10A          7591     	JMP	RUN1						; Go back to run 1
                      7592     
                      7593     
                      7594     RUN_TO_WAIT_FOR_POWER_ON: 	
163D    C2AF          7595     	CLR	EA
163F    120F99        7596     	CALL SWITCH_POWER_OFF
1642    7887          7597     MOV R0 , # PGM_PWM_FREQ 
1644    E6            7598     MOV A , @ R0 
1645    FE            7599     MOV R6 , A 
1646    7602          7600     MOV @ R0 , # 2 
1648    110B          7601     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
164A    7887          7602     MOV R0 , # PGM_PWM_FREQ 
164C    EE            7603     MOV A , R6 
164D    F6            7604     MOV @ R0 , A 
164E    E4            7605     	CLR	A
164F    F522          7606     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1651    F523          7607     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1653    F524          7608     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1655    F525          7609     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1657    F562          7610     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1659    C268          7611     CLR FLAGS1 . 0 
                      7612     IF MCU_50MHZ == 1
                               	SET_MCU_CLK_25MHZ
                               ENDIF
165B    D2AF          7615     	SETB	EA
165D    1206C6        7616     	CALL	WAIT1MS					; Wait for pwm to be stopped
1660    120F99        7617     	CALL SWITCH_POWER_OFF
                      7618     IF MODE == 0	; Main
                               	JNB	FLAGS2.RCP_PPM, RUN_TO_NEXT_STATE_MAIN	; If flag is not set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      7638     IF MODE >= 1	; Tail or multi
1663    307406        7639     JNB FLAGS2 . 4 , JMP_WAIT_FOR_POWER_ON 
                      7640     
1666    E529          7641     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1668    7002          7642     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      7643     
166A    21EA          7644     	JMP	INIT_NO_SIGNAL				; If it is zero (pulses missing) - go back to detect input signal
                      7645     
                      7646     JMP_WAIT_FOR_POWER_ON: 
166C    61FA          7647     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      7648     ENDIF
                      7649     
                      7650     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7651     
                      7652     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      8308     
                      8309     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      8310     
                      8311     
                      8312     END
MACRO ASSEMBLER BLHELI                                      08/03/15 09:08:18 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   1611H   A 
DECODE_DEMAG_HIGH.  C ADDR   1080H   A 
COMP_WAIT_ON_COMP~  C ADDR   0D31H   A 
CALC_NEXT_COMM_SL~  C ADDR   0BDAH   A 
CHECK_TEMP_VOLTAG~  C ADDR   0A85H   A 
MEASURE_LIPO_WAIT~  C ADDR   09F7H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0975H   A 
GOVERNOR_CORR_NEG~  C ADDR   0936H   A 
PCA_INT_PPM_BELOW~  C ADDR   0593H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
TIMER0_OVERFLOW_V~  D ADDR   0076H   A 
PPM_THROTTLE_GAIN.  D ADDR   006FH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006CH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0006h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
SBUF0. . . . . . .  D ADDR   0099H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
POLARIS_THUNDER_4~  N NUMB   008Fh            
POLARIS_THUNDER_3~  N NUMB   008Dh            
POLARIS_THUNDER_1~  N NUMB   0087h            
FUNCTION_BEEP. . .  C ADDR   17FDH   A 
INIT_START . . . .  C ADDR   1469H   A 
PROGRAM_BY_TX_ENT~  C ADDR   130DH   A 
FIND_THROTTLE_GAI~  C ADDR   109AH   A 
COMM45_NFET. . . .  C ADDR   0EE9H   A 
COMM45_NONDAMP . .  C ADDR   0EE6H   A 
COMM4COMM5 . . . .  C ADDR   0EC8H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0B2DH   A 
SET_PWM_DEMAG_DONE  C ADDR   09C6H   A 
PCA_INT_RESTORE_E~  C ADDR   0510H   A 
T2H_INT_RCP_STOP .  C ADDR   03C9H   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
MAIN_SPOOLUP_TIME~  D ADDR   0068H   A 
PWM_MOTOR_IDLE . .  D ADDR   0062H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003BH   A 
PWM_START. . . . .  N NUMB   0032h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
PLATINUM_50AV3_TA~  N NUMB   00A1h            
PLATINUM_PRO_30A_~  N NUMB   009Ah            
POLARIS_THUNDER_4~  N NUMB   0090h            
H_KING_35A_TAIL. .  N NUMB   0080h            
PARAVAL_BEEP . . .  C ADDR   180BH   A 
STORE_MULTI_FUNC_~  C ADDR   1784H   A 
DECODE_STARTUP_PO~  C ADDR   105EH   A 
GOVERNOR_CHECK_PWM  C ADDR   08C2H   A 
GOVERNOR_ACTIVATE.  C ADDR   0813H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DEMAG_DETECTED_ME~  D ADDR   0035H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
SIGNATURE_001. . .  N NUMB   00F3h            
RTX_PORT . . . . .  N NUMB   0080h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
B. . . . . . . . .  D ADDR   00F0H   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
P2 . . . . . . . .  D ADDR   00A0H   A 
PLATINUM_50AV3_MU~  N NUMB   00A2h            
POLARIS_THUNDER_6~  N NUMB   0092h            
H_KING_35A_MULTI .  N NUMB   0081h            
TURNIGY_AE_25A_MA~  N NUMB   0043h            
TURNIGY_AE_20A_TA~  N NUMB   0041h            
TURNIGY_PLUSH_10A~  N NUMB   001Fh            
XP_35A_SW_TAIL . .  N NUMB   0014h            
STORE_MULTI_FUNC_~  C ADDR   1789H   A 
WRITE_EEPROM_SIGN~  C ADDR   1722H   A 
WAIT_FOR_POWER_ON.  C ADDR   13FAH   A 
THROTTLE_LOW_CAL_~  C ADDR   1370H   A 
ARMING_INITIAL_AR~  C ADDR   12F6H   A 
PROGRAM_BY_TX_CHE~  C ADDR   13BCH   A 
ERASE_AND_STORE_A~  C ADDR   16B0H   A 
SET_DEFAULT_PARAM~  C ADDR   0FABH   A 
COMM56_NONDAMP . .  C ADDR   0F19H   A 
COMM23_CP. . . . .  C ADDR   0E84H   A 
COMP_READ_OK . . .  C ADDR   0D94H   A 
READ_COMP_LOOP . .  C ADDR   0D65H   A 
CALC_NEXT_COMM_TI~  C ADDR   0B7CH   A 
COMM5COMM6 . . . .  C ADDR   0F03H   A 
CALC_GOVERNOR_INT~  C ADDR   094EH   A 
CALC_GOVERNOR_TAR~  C ADDR   084BH   A 
PCA_INT_STORE_DATA  C ADDR   0533H   A 
T2_INT_RCP_GAIN_P~  C ADDR   035AH   A 
T2_INT_RCP_UPDATE~  C ADDR   031CH   A 
RESET. . . . . . .  C ADDR   10E2H   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   00A1H   A 
PGM_ENABLE_TEMP_P~  I ADDR   00A0H   A 
_PGM_THROTTLE_RATE  I ADDR   009BH   A 
_PGM_STARTUP_RPM .  I ADDR   008FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   0049H   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0003h            
STARTUP_PHASE. . .  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
SIGNATURE_002. . .  N NUMB   0030h            
LOCK_BYTE_ADDRESS~  N NUMB   1DFFh            
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
SP . . . . . . . .  D ADDR   0081H   A 
POLARIS_THUNDER_6~  N NUMB   0093h            
SKYWALKER_20A_MAIN  N NUMB   0058h            
TURNIGY_AE_30A_TA~  N NUMB   0047h            
TURNIGY_AE_20A_MU~  N NUMB   0042h            
XP_35A_SW_MULTI. .  N NUMB   0015h            
XP_7A_MAIN . . . .  N NUMB   0004h            
FUNCTION_NEXT. . .  C ADDR   187DH   A 
THROTTLE_HIGH_CAL.  C ADDR   133AH   A 
INITIALIZE_ALL_TI~  C ADDR   0B75H   A 
STARTUP_PWM_SET_P~  C ADDR   0B6CH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006BH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
RTX_PIN. . . . . .  N NUMB   0004h            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
POLARIS_THUNDER_8~  N NUMB   0095h            
TURNIGY_KFORCE_12~  N NUMB   0053h            
TURNIGY_AE_45A_MA~  N NUMB   0049h            
TURNIGY_AE_30A_MU~  N NUMB   0048h            
TURNIGY_PLUSH_30A~  N NUMB   002Bh            
TURNIGY_PLUSH_12A~  N NUMB   0022h            
XP_3A_TAIL . . . .  N NUMB   0002h            
PARAVAL_NEXT . . .  C ADDR   1867H   A 
WRITE_EEPROM_BYTE.  C ADDR   16F6H   A 
MEASURE_PWM_FREQ_~  C ADDR   1259H   A 
COMM61_CP. . . . .  C ADDR   0F6FH   A 
COMM_EXIT. . . . .  C ADDR   0F7EH   A 
COMM12_PRECH_DONE.  C ADDR   0E3FH   A 
CALC_GOVERNOR_INT~  C ADDR   0947H   A 
PCA_INT_PPM_CHECK~  C ADDR   05AEH   A 
PCA_INT_PWM_DIVIDE  C ADDR   065FH   A 
PCA_INT_LIMITED. .  C ADDR   0682H   A 
T2_INT_PWM_UPDATE.  C ADDR   0361H   A 
T0_INT_PWM_OFF_DA~  C ADDR   00DEH   A 
EEP_DUMMY. . . . .  C ADDR   1A24H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A13H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003AH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
RTX_MDIN . . . . .  N NUMB   00F1h            
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
MODE . . . . . . .  N NUMB   0002h            
POLARIS_THUNDER_8~  N NUMB   0096h            
SKYWALKER_40A_MAIN  N NUMB   005Bh            
TURNIGY_KFORCE_12~  N NUMB   0054h            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
SUPERMICRO_3P5A_M~  N NUMB   0019h            
XP_3A_MULTI. . . .  N NUMB   0003h            
FUNC_PARAVAL_WAIT.  C ADDR   182DH   A 
WRITE_TAG. . . . .  C ADDR   174BH   A 
READ_EEPROM_STORE~  C ADDR   1687H   A 
RUN1 . . . . . . .  C ADDR   150AH   A 
WAIT_FOR_POWER_ON~  C ADDR   1463H   A 
MEASURE_PWM_FREQ_~  C ADDR   1269H   A 
CLEAR_RAM. . . . .  C ADDR   11EEH   A 
SET_BEC_VOLTAGE. .  C ADDR   108AH   A 
DECODE_DEMAG_DONE.  C ADDR   1089H   A 
DECODE_GOVERNOR_G~  C ADDR   1044H   A 
WAIT_FOR_COMM. . .  C ADDR   0DDFH   A 
MEASURE_LIPO_ADD_~  C ADDR   0A74H   A 
CALC_GOVERNOR_PRO~  C ADDR   0884H   A 
DIV_U16_BY_U16_DI~  C ADDR   0767H   A 
WAIT100MS. . . . .  C ADDR   06DAH   A 
WAIT1MS. . . . . .  C ADDR   06C6H   A 
STARTUP_POWER_TAB~  C ADDR   008DH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
SKIP_T2_INT. . . .  D ADDR   0074H   A 
TX_PGM_BEEP_NO . .  D ADDR   0073H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
RTX_MDOUT. . . . .  N NUMB   00A4h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
PSCTL. . . . . . .  D ADDR   008FH   A 
SKYPUP_6A_MAIN . .  N NUMB   00BBh            
PLATINUM_PRO_30A_~  N NUMB   009Bh            
TURNIGY_KFORCE_12~  N NUMB   0055h            
FUNCTION_PARAVAL_~  C ADDR   17F7H   A 
STORE_NEW_VALUE_I~  C ADDR   1753H   A 
RUN2 . . . . . . .  C ADDR   1528H   A 
ARMING_PPM_CHECK .  C ADDR   1300H   A 
DECODE_MAIN_SPOOL~  C ADDR   106DH   A 
COMM45_CP. . . . .  C ADDR   0EFAH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0CAEH   A 
CALC_NEW_WAIT_PER~  C ADDR   0C22H   A 
CHECK_VOLTAGE_PWM~  C ADDR   0B4EH   A 
MEASURE_LIPO_UPDA~  C ADDR   0A7CH   A 
GOVERNOR_CORR_INT~  C ADDR   0994H   A 
GOVERNOR_STORE_PR~  C ADDR   0880H   A 
DIV_U16_BY_U16_DI~  C ADDR   0771H   A 
WAIT200MS. . . . .  C ADDR   06DFH   A 
T2_INT_CURRENT_PW~  C ADDR   037BH   A 
T2_INT_RCP_GAIN_C~  C ADDR   0351H   A 
T2_INT_PULSES_ABS~  C ADDR   02CAH   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_MAIN_SPOOLUP_~  I ADDR   009FH   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   0048H   A 
GOV_ACTIVE . . . .  D ADDR   0047H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
IT01CF . . . . . .  D ADDR   00E4H   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Ch            
TURNIGY_AE_25A_TA~  N NUMB   0044h            
TURNIGY_PLUSH_60A~  N NUMB   0031h            
TURNIGY_PLUSH_10A~  N NUMB   0020h            
RUN3 . . . . . . .  C ADDR   1549H   A 
WAIT_BEFORE_ZC_RA~  C ADDR   0CCEH   A 
CHECK_VOLTAGE_EXIT  C ADDR   0B3DH   A 
GOVERNOR_LIMIT_IN~  C ADDR   097CH   A 
GOVERNOR_CHECK_IN~  C ADDR   08AAH   A 
DIV_U16_BY_U16_DI~  C ADDR   0788H   A 
WAIT3MS. . . . . .  C ADDR   06CBH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0041H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
RCP_PPM_ONESHOT125  N NUMB   0005h            
DIR_CHANGE_BRAKE .  N NUMB   0003h            
DEMAG_ENABLED. . .  N NUMB   0004h            
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
STA. . . . . . . .  B ADDR   00C0H.5 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
POLARIS_THUNDER_1~  N NUMB   0097h            
SKYWALKER_20A_TAIL  N NUMB   0059h            
TURNIGY_AE_25A_MU~  N NUMB   0045h            
TURNIGY_PLUSH_25A~  N NUMB   0028h            
TURNIGY_PLUSH_10A~  N NUMB   0021h            
XP_7A_TAIL . . . .  N NUMB   0005h            
BEEP_NO_ENTRY. . .  C ADDR   1825H   A 
JMP_WAIT_FOR_POWE~  C ADDR   166CH   A 
DIRECT_START_CHEC~  C ADDR   15F2H   A 
RUN4 . . . . . . .  C ADDR   1567H   A 
COMM34_PRECH_DONE.  C ADDR   0EACH   A 
STORE_TIMES_UP_OR~  C ADDR   0C8EH   A 
STORE_TIMES_DECRE~  C ADDR   0CA1H   A 
CALC_NEXT_COMM_NE~  C ADDR   0BC4H   A 
TEMP_AVERAGE_INC .  C ADDR   0ABFH   A 
GOVERNOR_CORR_INT~  C ADDR   09A5H   A 
MULT_S16_BY_U8_DI~  C ADDR   0797H   A 
PCA_INT_PPM_NEG_C~  C ADDR   061CH   A 
T2_INT_EXIT. . . .  C ADDR   03A1H   A 
_EEP_PGM_DAMPING_~  C ADDR   1A16H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
SKYWALKER_20A_MUL~  N NUMB   005Ah            
TURNIGY_AE_45A_TA~  N NUMB   004Ah            
TURNIGY_PLUSH_80A~  N NUMB   0034h            
TURNIGY_PLUSH_30A~  N NUMB   002Ch            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
XP_7A_MULTI. . . .  N NUMB   0006h            
READ_TAGS. . . . .  C ADDR   1731H   A 
RUN5 . . . . . . .  C ADDR   1585H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0C35H   A 
GOVERNOR_CORR_NEG~  C ADDR   0999H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0875H   A 
GOVERNOR_TARGET_C~  C ADDR   07F6H   A 
CALC_GOVERNOR_TAR~  C ADDR   07EEH   A 
PCA_INT_PWM_DIVID~  C ADDR   0666H   A 
T2_INT_CURRENT_PW~  C ADDR   0383H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   0070H   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   005Ch            
TURNIGY_AE_45A_MU~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_30A~  N NUMB   002Dh            
TURNIGY_PLUSH_18A~  N NUMB   0025h            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
SUPERMICRO_3P5A_T~  N NUMB   001Ah            
RUN6 . . . . . . .  C ADDR   15A3H   A 
ARMING_START . . .  C ADDR   12E0H   A 
MEASURE_PWM_FREQ_~  C ADDR   125FH   A 
GOVERNOR_DEACTIVA~  C ADDR   0800H   A 
PCA_INT_CHECK_LEG~  C ADDR   0677H   A 
PWM_NOFET_ON . . .  C ADDR   012BH   A 
T0_INT_PWM_OFF_CO~  C ADDR   00FFH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STARTUP_ROT_CNT. .  D ADDR   0033H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
SKYPUP_6A_TAIL . .  N NUMB   00BCh            
ALIGN_RCE_BL15P_M~  N NUMB   006Dh            
SKYWALKER_40A_MUL~  N NUMB   005Dh            
TURNIGY_KFORCE_12~  N NUMB   0056h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
SUPERMICRO_3P5A_M~  N NUMB   001Bh            
DP_3A_MAIN . . . .  N NUMB   0016h            
ARM_TARGET_UPDATED  C ADDR   13C6H   A 
EVALUATE_COMPARAT~  C ADDR   0D9EH   A 
TEMP_CHECK_EXIT. .  C ADDR   0AE9H   A 
GOVERNOR_APPLY_PR~  C ADDR   091DH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
_PGM_STARTUP_ACCEL  I ADDR   0090H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0040H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
MASTER . . . . . .  B ADDR   00C0H.7 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SKYPUP_6A_MULTI. .  N NUMB   00BDh            
TURNIGY_KFORCE_12~  N NUMB   0057h            
TURNIGY_PLUSH_60A~  N NUMB   0032h            
WRITE_EEPROM_BLOC~  C ADDR   16D3H   A 
NORMAL_RUN_CHECKS.  C ADDR   15FFH   A 
INIT_NO_SIGNAL . .  C ADDR   11EAH   A 
COMM56_PRECH_DONE.  C ADDR   0F19H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0CF9H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0BE1H   A 
CHECK_VOLTAGE_SET~  C ADDR   0B44H   A 
CALC_GOVERNOR_PRO~  C ADDR   084CH   A 
PCA_INT_PPM_UNIDI~  C ADDR   0616H   A 
T2_INT_PPM_TIMEOU~  C ADDR   0308H   A 
PWM_BNFET_APFET_ON  C ADDR   01DCH   A 
PWM_ANFET_BPFET_ON  C ADDR   016BH   A 
T0_INT_PWM_OFF_EX~  C ADDR   0111H   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_COM . . . . .  N NUMB   0003h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
POLARIS_THUNDER_1~  N NUMB   0098h            
ALIGN_RCE_BL35P_M~  N NUMB   0073h            
TURNIGY_PLUSH_60A~  N NUMB   0033h            
TURNIGY_PLUSH_25A~  N NUMB   0029h            
WRITE_EEPROM_BLOC~  C ADDR   16E1H   A 
READ_ALL_EEPROM_P~  C ADDR   166EH   A 
PROGRAM_BY_TX_ENT~  C ADDR   13ADH   A 
CALC_NEXT_COMM_NE~  C ADDR   0BCDH   A 
PWM_CNFET_APFET_ON  C ADDR   01FFH   A 
PWM_ANFET_CPFET_ON  C ADDR   0196H   A 
T0_INT . . . . . .  C ADDR   00A5H   A 
_EEP_PGM_STARTUP_~  C ADDR   1A18H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
SKIP_T2H_INT . . .  D ADDR   0075H   A 
MAIN_SPOOLUP_TIME~  D ADDR   0066H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
INITIAL_RUN_PHASE.  N NUMB   0002h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0001h            
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
POLARIS_THUNDER_1~  N NUMB   0099h            
TURNIGY_PLUSH_80A~  N NUMB   0035h            
TURNIGY_PLUSH_25A~  N NUMB   002Ah            
DECODE_DEMAG_COMP.  C ADDR   106EH   A 
EVAL_COMP_EXIT . .  C ADDR   0DBCH   A 
MEASURE_LIPO_ADJU~  C ADDR   0A39H   A 
PCA_INT_SET_TIMEO~  C ADDR   069BH   A 
PWM_CNFET_BPFET_ON  C ADDR   022AH   A 
PWM_BNFET_CPFET_ON  C ADDR   01B9H   A 
PWM_AFET_ON. . . .  C ADDR   012DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0104H   A 
T0_INT_PWM_ON_EXE~  C ADDR   00B8H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
PREV_COMM_H. . . .  D ADDR   0039H   A 
RCP_TIMEOUT_CNT. .  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0003h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
ACK. . . . . . . .  B ADDR   00C0H.1 A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
TURNIGY_PLUSH_80A~  N NUMB   0036h            
TURNIGY_PLUSH_18A~  N NUMB   0026h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
BOOTLOADER_DONE. .  C ADDR   11FCH   A 
AVERAGE_THROTTLE .  C ADDR   10B7H   A 
DECODE_PARAMS_DIR~  C ADDR   1026H   A 
SETUP_COMM_WAIT. .  C ADDR   0DBDH   A 
CHECK_VOLTAGE_LIM.  C ADDR   0B23H   A 
CALC_GOVERNOR_INT~  C ADDR   08E1H   A 
T0_INT_PFETS_OFF_~  C ADDR   027FH   A 
PWM_BFET_ON. . . .  C ADDR   013FH   A 
T2_INT . . . . . .  C ADDR   02AEH   A 
_PGM_DAMPING_FORCE  I ADDR   0093H   A 
LIPO_ADC_REFERENC~  D ADDR   006AH   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
NEXT_WT_H. . . . .  D ADDR   0051H   A 
STARTUP_OK_CNT . .  D ADDR   0034H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0005h            
APFET. . . . . . .  N NUMB   0000h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
ALIGN_RCE_BL15P_T~  N NUMB   006Eh            
RCTIMER_6A_MAIN. .  N NUMB   0067h            
TURNIGY_PLUSH_NFE~  N NUMB   003Dh            
TURNIGY_PLUSH_18A~  N NUMB   0027h            
DP_3A_TAIL . . . .  N NUMB   0017h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
ARM_END_BEEP . . .  C ADDR   13DBH   A 
THROTTLE_HIGH_CAL~  C ADDR   1338H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0CE6H   A 
LOAD_MIN_TIME. . .  C ADDR   0C51H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0BF2H   A 
SET_STARTUP_PWM. .  C ADDR   0B57H   A 
GOVERNOR_STORE_IN~  C ADDR   08DBH   A 
GOVERNOR_ACTIVATE~  C ADDR   083DH   A 
T2H_INT_EXIT . . .  C ADDR   03DAH   A 
PWM_CFET_ON. . . .  C ADDR   0151H   A 
T0_INT_PWM_ON_EXI~  C ADDR   025DH   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   03E6H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0072H   A 
ADC_CONVERSION_CNT  D ADDR   006DH   A 
PWM_LIMIT_LOW_RPM.  D ADDR   0060H   A 
GOV_ARM_TARGET . .  D ADDR   0046H   A 
RCP_PPM. . . . . .  N NUMB   0004h            
RCP_OUTSIDE_RANGE~  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0002h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TXMODE . . . . . .  B ADDR   00C0H.6 A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
EMAX_20A_MAIN. . .  N NUMB   00ACh            
TAROT_30A_MAIN . .  N NUMB   00A6h            
ALIGN_RCE_BL15P_M~  N NUMB   006Fh            
DP_3A_MULTI. . . .  N NUMB   0018h            
FUNC_PARAVAL . . .  C ADDR   1828H   A 
WAIT1S_LOOP. . . .  C ADDR   1793H   A 
STORE_MULTI_FUNC_1  C ADDR   1757H   A 
RUN6_CHECK_RCP_TI~  C ADDR   1627H   A 
AVERAGE_THROTTLE_~  C ADDR   10D3H   A 
ADJUST_TIMING. . .  C ADDR   0C55H   A 
MEASURE_LIPO_DIVI~  C ADDR   0A59H   A 
MEASURE_LIPO_START  C ADDR   09E6H   A 
CALC_GOVERNOR_PRO~  C ADDR   0946H   A 
GOVERNOR_INT_MIN_~  C ADDR   08D6H   A 
GOVERNOR_LIMIT_PR~  C ADDR   087CH   A 
BEEP_F1. . . . . .  C ADDR   06EFH   A 
PCA_INT_PPM_OUTSI~  C ADDR   059CH   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006EH   A 
PWM_SPOOLUP_BEG. .  D ADDR   0061H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004BH   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0004h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
ACKRQ. . . . . . .  B ADDR   00C0H.3 A 
TMR3L. . . . . . .  D ADDR   0094H   A 
ALIGN_RCE_BL35P_T~  N NUMB   0074h            
STORE_MULTI_FUNC_2  C ADDR   175CH   A 
INITIAL_RUN_PHASE~  C ADDR   1620H   A 
TEST_THROTTLE_GAIN  C ADDR   10A8H   A 
GOVERNOR_STORE_PR~  C ADDR   0944H   A 
GOVERNOR_CHECK_PR~  C ADDR   0908H   A 
MULT_S16_BY_U8_PO~  C ADDR   07B1H   A 
DIV_U16_BY_U16 . .  C ADDR   075FH   A 
BEEP_ONOFF . . . .  C ADDR   0712H   A 
BEEP_F2. . . . . .  C ADDR   06F6H   A 
PCA_INT_PPM_BIDIR~  C ADDR   05E7H   A 
PCA_INT_CHECK_DIFF  C ADDR   0526H   A 
T2_INT_SKIP_START.  C ADDR   030CH   A 
T0_INT_PWM_OFF_FU~  C ADDR   0124H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0013h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
PREV_COMM_L. . . .  D ADDR   0038H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
XROTOR_10A_MAIN. .  N NUMB   00B2h            
EMAX_40A_MAIN. . .  N NUMB   00AFh            
ALIGN_RCE_BL35P_M~  N NUMB   0075h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ah            
TURNIGY_KFORCE_70~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   004Ch            
XP_25A_MAIN. . . .  N NUMB   0010h            
PARAVAL_NO_ENTRY .  C ADDR   1822H   A 
STORE_MULTI_FUNC_3  C ADDR   1761H   A 
SUCCESS_BEEP_INVE~  C ADDR   17C8H   A 
SUCCESS_BEEP . . .  C ADDR   1799H   A 
FIND_THROTTLE_GAIN  C ADDR   108BH   A 
COMM_DIR_CHANGE_D~  C ADDR   0F94H   A 
TEMP_AVERAGE_INC_~  C ADDR   0AAFH   A 
GOVERNOR_INT_MAX_~  C ADDR   08CFH   A 
GOVERNOR_LIMIT_IN~  C ADDR   08B3H   A 
BEEP_F3. . . . . .  C ADDR   06FDH   A 
PCA_INT_FAIL_MINI~  C ADDR   044AH   A 
T0_INT_PWM_ON_EXI~  C ADDR   02A7H   A 
T0_INT_PWM_OFF_EX~  C ADDR   0121H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0063H   A 
NEXT_WT_L. . . . .  D ADDR   0050H   A 
WT_ZC_TIMEOUT_H. .  D ADDR   004DH   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
COMM_TIME_RED. . .  N NUMB   0001h            
P1_INIT. . . . . .  N NUMB   006Ah            
TEMP_LIMIT . . . .  N NUMB   006Dh            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
XROTOR_20A_MAIN. .  N NUMB   00B5h            
PLATINUM_PRO_150A~  N NUMB   009Dh            
TURNIGY_PLUSH_NFE~  N NUMB   003Ah            
XP_12A_TAIL. . . .  N NUMB   000Bh            
STORE_MULTI_FUNC_4  C ADDR   1766H   A 
DAMPED_TRANSITION.  C ADDR   14FFH   A 
BEEP_DELAY_SET . .  C ADDR   1422H   A 
PROGRAM_BY_TX_ENT~  C ADDR   131EH   A 
LOCK_BYTE_OK . . .  C ADDR   1101H   A 
AVERAGE_THROTTLE_~  C ADDR   10C4H   A 
DECODE_PWM_FREQ_L~  C ADDR   103EH   A 
CALC_NEW_WAIT_PER~  C ADDR   0C2FH   A 
SET_PWM_LIMIT_LOW~  C ADDR   09E3H   A 
BEEP_F4. . . . . .  C ADDR   0704H   A 
PCA_INT_PPM_MAX_C~  C ADDR   0646H   A 
PCA_INT_RESTORE_E~  C ADDR   0512H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A3H   A 
_PGM_STARTUP_METH~  I ADDR   0095H   A 
_PGM_VOLT_COMP . .  I ADDR   0091H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
H_KING_10A_MAIN. .  N NUMB   0079h            
ALIGN_RCE_BL35X_M~  N NUMB   0070h            
RCTIMER_6A_TAIL. .  N NUMB   0068h            
TURNIGY_PLUSH_NFE~  N NUMB   003Eh            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   188EH   A 
STORE_MULTI_FUNC_5  C ADDR   176BH   A 
READ_EEPROM_BYTE .  C ADDR   16F2H   A 
THROTTLE_LOW_CAL .  C ADDR   1372H   A 
COMP_READ_WRONG. .  C ADDR   0D70H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0AC7H   A 
GOVERNOR_APPLY_IN~  C ADDR   0980H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0913H   A 
BEEP_OFF . . . . .  C ADDR   0753H   A 
WAIT10MS . . . . .  C ADDR   06D0H   A 
PCA_INT_PPM_BIDIR~  C ADDR   05EEH   A 
RCP_INT_FALL_CHEC~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXIT  C ADDR   029DH   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Dh            
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0071H   A 
WT_ZC_SCAN_L . . .  D ADDR   004AH   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
P0_SKIP. . . . . .  N NUMB   00EFh            
DEFAULT_PGM_MAIN_~  N NUMB   000Bh            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
STO. . . . . . . .  B ADDR   00C0H.4 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
XROTOR_40A_MAIN. .  N NUMB   00B8h            
EMAX_20A_TAIL. . .  N NUMB   00ADh            
TAROT_30A_TAIL . .  N NUMB   00A7h            
H_KING_20A_MAIN. .  N NUMB   007Ch            
RCTIMER_6A_MULTI .  N NUMB   0069h            
HIMODEL_COOL_22A_~  N NUMB   005Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0037h            
XP_7A_FAST_MULTI .  N NUMB   0009h            
STORE_MULTI_FUNC_6  C ADDR   1770H   A 
READ_TAG . . . . .  C ADDR   173AH   A 
RESET_CAL_DONE . .  C ADDR   111EH   A 
DECODE_PARAMETERS.  C ADDR   100BH   A 
STORE_TIMES_INCRE~  C ADDR   0C94H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0B0EH   A 
MEASURE_LIPO_CELLS  C ADDR   09E6H   A 
CALC_GOVERNOR_INT~  C ADDR   0885H   A 
PCA_INT_PPM_CALCU~  C ADDR   05C4H   A 
PCA_INT_EXIT . . .  C ADDR   06AFH   A 
T2_INT_RCP_UPDATE~  C ADDR   0339H   A 
T0_INT_PFETS_OFF_~  C ADDR   0291H   A 
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
COMPARATOR_READ_C~  D ADDR   003DH   A 
PWM_TIMER0_OVERFL~  N NUMB   0003h            
_SPARE_REG . . . .  D ADDR   002BH   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0040h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
ARBLOST. . . . . .  B ADDR   00C0H.2 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
TMR3CN . . . . . .  D ADDR   0091H   A 
EMAX_20A_MULTI . .  N NUMB   00AEh            
TAROT_30A_MULTI. .  N NUMB   00A8h            
HIMODEL_COOL_41A_~  N NUMB   0064h            
TURNIGY_PLUSH_6A_~  N NUMB   001Ch            
STORE_MULTI_FUNC_7  C ADDR   1775H   A 
RUN6_CHECK_SPEED .  C ADDR   162EH   A 
WAIT_FOR_POWER_ON~  C ADDR   144BH   A 
SWITCH_POWER_OFF .  C ADDR   0F99H   A 
WAIT30MS . . . . .  C ADDR   06D5H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0637H   A 
PCA_INT_CHECK_1KHZ  C ADDR   0501H   A 
T2H_INT. . . . . .  C ADDR   03B0H   A 
WT_ZC_TIMEOUT_L. .  D ADDR   004CH   A 
GOV_INTEGRAL_X . .  D ADDR   0042H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0028h            
MCU_50MHZ. . . . .  N NUMB   0000h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
XROTOR_10A_TAIL. .  N NUMB   00B3h            
EMAX_40A_TAIL. . .  N NUMB   00B0h            
EAZY_3AV2_MAIN . .  N NUMB   00A3h            
ALIGN_RCE_BL15X_T~  N NUMB   006Bh            
HIMODEL_COOL_33A_~  N NUMB   0061h            
TURNIGY_KFORCE_70~  N NUMB   0050h            
TURNIGY_KFORCE_40~  N NUMB   004Dh            
XP_25A_TAIL. . . .  N NUMB   0011h            
FUNC_PARAVAL_CONT~  C ADDR   185AH   A 
WAIT1S . . . . . .  C ADDR   1791H   A 
STORE_MULTI_FUNC_8  C ADDR   177AH   A 
WRITE_TAGS . . . .  C ADDR   1744H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   163DH   A 
EVAL_COMP_CHECK_T~  C ADDR   0DACH   A 
COMP_WAIT_ON_COMP~  C ADDR   0D3BH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D0BH   A 
ADJUST_TIMING_TWO~  C ADDR   0C7BH   A 
CHECK_VOLTAGE_RET.  C ADDR   0B56H   A 
CALC_GOVERNOR_PRO~  C ADDR   08E9H   A 
GOVERNOR_ACTIVATE~  C ADDR   0844H   A 
WAITXMS_M. . . . .  C ADDR   06E6H   A 
PCA_INT_CHECK_2KHZ  C ADDR   04F0H   A 
T0_INT_PFETS_OFF_~  C ADDR   0268H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
GOV_TARGET_H . . .  D ADDR   003FH   A 
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
PX1. . . . . . . .  B ADDR   00B8H.2 A 
IP . . . . . . . .  D ADDR   00B8H   A 
XROTOR_20A_TAIL. .  N NUMB   00B6h            
XROTOR_10A_MULTI .  N NUMB   00B4h            
EMAX_40A_MULTI . .  N NUMB   00B1h            
SKYIII_30A_MAIN. .  N NUMB   00A9h            
PLATINUM_PRO_150A~  N NUMB   009Eh            
POLARIS_THUNDER_2~  N NUMB   0088h            
H_KING_50A_MAIN. .  N NUMB   0082h            
GAUI_GE_183_18A_M~  N NUMB   0076h            
ALIGN_RCE_BL15X_M~  N NUMB   006Ch            
TURNIGY_KFORCE_70~  N NUMB   0051h            
TURNIGY_KFORCE_40~  N NUMB   004Eh            
TURNIGY_PLUSH_NFE~  N NUMB   003Bh            
XP_25A_MULTI . . .  N NUMB   0012h            
STORE_MULTI_FUNC_9  C ADDR   177FH   A 
READ_INITIAL_TEMP.  C ADDR   14A0H   A 
WAIT_FOR_POWER_ON~  C ADDR   143FH   A 
DECODE_PWM_FREQ_E~  C ADDR   1043H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0E18H   A 
START_ADC_CONVERS~  C ADDR   0A81H   A 
MULT_S16_BY_U8_EX~  C ADDR   07E5H   A 
PCA_INT_PPM_LIMIT~  C ADDR   0658H   A 
T2H_INT_RCP_GOV_P~  C ADDR   03DAH   A 
T2_INT_PWM_MIN_RUN  C ADDR   0361H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
LOW_RPM_PWR_SLOPE.  D ADDR   0037H   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MUX_A. . . . . . .  N NUMB   0002h            
PFETON_DELAY . . .  N NUMB   0001h            
HIGH_BEC_VOLTAGE .  N NUMB   0000h            
PSW. . . . . . . .  D ADDR   00D0H   A 
XROTOR_20A_MULTI .  N NUMB   00B7h            
PLATINUM_PRO_150A~  N NUMB   009Fh            
POLARIS_THUNDER_3~  N NUMB   008Bh            
POLARIS_THUNDER_1~  N NUMB   0085h            
H_KING_10A_TAIL. .  N NUMB   007Ah            
ALIGN_RCE_BL35X_T~  N NUMB   0071h            
TURNIGY_PLUSH_NFE~  N NUMB   003Ch            
XP_18A_TAIL. . . .  N NUMB   000Eh            
STORE_IN_RAM_EXIT.  C ADDR   178EH   A 
VALIDATE_RCP_START  C ADDR   12B1H   A 
LOCK_BYTE_TEST . .  C ADDR   10FAH   A 
COMM12_NONDAMP . .  C ADDR   0E3FH   A 
COMM1COMM2 . . . .  C ADDR   0E29H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0AC5H   A 
TEMP_AVERAGE_DEC .  C ADDR   0ABBH   A 
CALC_GOVERNOR_PRO~  C ADDR   08E2H   A 
WAITXMS_O. . . . .  C ADDR   06E4H   A 
PCA_INT_PPM_TIMEO~  C ADDR   06A4H   A 
PCA_INT_CHECK_4KHZ  C ADDR   04DFH   A 
RCP_INT_CHECK_12K~  C ADDR   04BDH   A 
T0_INT_PWM_OFF . .  C ADDR   00BAH   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   00C8h            
MUX_B. . . . . . .  N NUMB   0000h            
RCP_IN . . . . . .  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Bh            
ONE_S_CAPABLE. . .  N NUMB   0000h            
ADC0GTH. . . . . .  D ADDR   00C4H   A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
XROTOR_40A_TAIL. .  N NUMB   00B9h            
POLARIS_THUNDER_4~  N NUMB   008Eh            
H_KING_20A_TAIL. .  N NUMB   007Dh            
H_KING_10A_MULTI .  N NUMB   007Bh            
ALIGN_RCE_BL35X_M~  N NUMB   0072h            
HIMODEL_COOL_22A_~  N NUMB   005Fh            
TURNIGY_PLUSH_NFE~  N NUMB   0038h            
XP_18A_MULTI . . .  N NUMB   000Fh            
READ_EEPROM_EXIT .  C ADDR   16AFH   A 
WAIT_FOR_POWER_ON~  C ADDR   13FFH   A 
INPUT_HIGH_CHECK_1  C ADDR   11F3H   A 
WAIT_BEFORE_ZC_EX~  C ADDR   0CE5H   A 
CHECK_VOLTAGE_STA~  C ADDR   0AEDH   A 
SET_PWM_LIMIT_LOW~  C ADDR   09AAH   A 
CALC_GOVERNOR_INT~  C ADDR   09A9H   A 
GOVERNOR_LIMIT_IN~  C ADDR   08BCH   A 
MULT_S16_BY_U8_DI~  C ADDR   07CAH   A 
BEEP . . . . . . .  C ADDR   070BH   A 
PCA_INT_PPM_BIDIR~  C ADDR   0601H   A 
RCP_INT_FALL_NOT_~  C ADDR   0566H   A 
PCA_INT_FALL . . .  C ADDR   0543H   A 
T2_INT_PWM_EXIT. .  C ADDR   0398H   A 
T2_INT_SKIP_END. .  C ADDR   0314H   A 
TX_PGM_PARAMS_MUL~  C ADDR   009AH   A 
EEP_PGM_TEMP_PROT~  C ADDR   1A23H   A 
_EEP_PGM_THROTTLE~  C ADDR   1A1EH   A 
_EEP_PGM_STARTUP_~  C ADDR   1A12H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A2H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
MAIN_SPOOLUP_TIME~  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003CH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
MUX_C. . . . . . .  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   000Bh            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
SI . . . . . . . .  B ADDR   00C0H.0 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
XROTOR_40A_MULTI .  N NUMB   00BAh            
PLATINUM_50AV3_MA~  N NUMB   00A0h            
H_KING_35A_MAIN. .  N NUMB   007Fh            
H_KING_20A_MULTI .  N NUMB   007Eh            
HIMODEL_COOL_41A_~  N NUMB   0065h            
HIMODEL_COOL_22A_~  N NUMB   0060h            
TURNIGY_PLUSH_NFE~  N NUMB   0039h            
TURNIGY_PLUSH_6A_~  N NUMB   001Dh            
ERASE_FLASH. . . .  C ADDR   170BH   A 
PROGRAM_BY_TX. . .  C ADDR   1816H   A 
INPUT_HIGH_CHECK_2  C ADDR   11F5H   A 
COMM23_NFET. . . .  C ADDR   0E7BH   A 
COMM23_NONDAMP . .  C ADDR   0E78H   A 
COMM2COMM3 . . . .  C ADDR   0E52H   A 
CALC_NEXT_COMM_AV~  C ADDR   0BB1H   A 
MEASURE_LIPO_CELL~  C ADDR   0A1EH   A 
GOVERNOR_STORE_IN~  C ADDR   09A7H   A 
GOVERNOR_CHECK_IN~  C ADDR   0969H   A 
GOVERNOR_CORR_PRO~  C ADDR   0931H   A 
GOVERNOR_ACTIVATE~  C ADDR   0831H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   003EH   A 
DEMAG_PWR_OFF_THR~  D ADDR   0036H   A 
FLAGS0 . . . . . .  D ADDR   002CH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   003Fh            
P0_DIGITAL . . . .  N NUMB   FFFFFFB2h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
EAZY_3AV2_TAIL . .  N NUMB   00A4h            
POLARIS_THUNDER_6~  N NUMB   0091h            
HIMODEL_COOL_41A_~  N NUMB   0066h            
HIMODEL_COOL_33A_~  N NUMB   0062h            
TURNIGY_AE_20A_MA~  N NUMB   0040h            
TURNIGY_PLUSH_6A_~  N NUMB   001Eh            
XP_35A_SW_MAIN . .  N NUMB   0013h            
FUNC_PARAVAL_STORE  C ADDR   1849H   A 
WRITE_EEPROM_BYTE~  C ADDR   16F7H   A 
READ_EEPROM_BLOCK1  C ADDR   1697H   A 
READ_EEPROM_READ .  C ADDR   1690H   A 
MEASURE_LIPO_EXIT.  C ADDR   0A80H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0919H   A 
GOVERNOR_CHECK_PR~  C ADDR   0869H   A 
PCA_INT_SECOND_ME~  C ADDR   0473H   A 
T2H_INT_RCP_STOP_~  C ADDR   03BDH   A 
PCA_INT. . . . . .  C ADDR   040CH   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
CLOCK_SET_AT_50MHZ  D ADDR   0077H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0001h            
P1_DIGITAL . . . .  N NUMB   003Fh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
SKYIII_30A_TAIL. .  N NUMB   00AAh            
EAZY_3AV2_MULTI. .  N NUMB   00A5h            
POLARIS_THUNDER_2~  N NUMB   0089h            
H_KING_50A_TAIL. .  N NUMB   0083h            
GAUI_GE_183_18A_T~  N NUMB   0077h            
HIMODEL_COOL_33A_~  N NUMB   0063h            
TURNIGY_AE_30A_MA~  N NUMB   0046h            
READ_EEPROM_BLOCK2  C ADDR   16A5H   A 
MEASURE_PWM_FREQ_~  C ADDR   125DH   A 
COMM61_NFET. . . .  C ADDR   0F5EH   A 
COMM61_NONDAMP . .  C ADDR   0F5BH   A 
COMM6COMM1 . . . .  C ADDR   0F2DH   A 
COMM34_NONDAMP . .  C ADDR   0EACH   A 
COMM3COMM4 . . . .  C ADDR   0E96H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0CF1H   A 
MEASURE_LIPO_LIMI~  C ADDR   0A70H   A 
GOVERNOR_CORR_PRO~  C ADDR   0942H   A 
PCA_INT_PPM_BIDIR~  C ADDR   05DEH   A 
PCA_INT_CHECK_8KHZ  C ADDR   04CEH   A 
_EEP_PGM_MAIN_SPO~  C ADDR   1A22H   A 
GOV_PROP_PWM . . .  D ADDR   0045H   A 
GOV_PROPORTIONAL_L  D ADDR   0043H   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
DEMAG_DETECTED . .  N NUMB   0005h            
RCP_SKIP_CNT . . .  D ADDR   002AH   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
SKYIII_30A_MULTI .  N NUMB   00ABh            
POLARIS_THUNDER_8~  N NUMB   0094h            
POLARIS_THUNDER_3~  N NUMB   008Ch            
POLARIS_THUNDER_2~  N NUMB   008Ah            
POLARIS_THUNDER_1~  N NUMB   0086h            
H_KING_50A_MULTI .  N NUMB   0084h            
GAUI_GE_183_18A_M~  N NUMB   0078h            
TURNIGY_KFORCE_12~  N NUMB   0052h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6268    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     88    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
